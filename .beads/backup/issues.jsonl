{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/polecats/quartz","await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T08:58:52Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b61e8488a5eaf50b2e1cde53650b7cb36fc41599f87037742faa6e3d6b773448","created_at":"2026-02-28T08:56:17Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"attached_molecule: cue-wisp-336ph\nattached_formula: mol-polecat-work\nattached_at: 2026-02-28T08:56:26Z\ndispatched_by: mayor\n\nCreate alerts/claude-usage.yaml with default alerting rules: session utilization \u003e80% (warning) and \u003e95% (critical), weekly utilization \u003e80% (warning) and \u003e95% (critical), poll errors for \u003e5min (critical). Include labels and annotations with meaningful summaries. Should work out of the box with standard Prometheus alertmanager.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-26p","is_template":0,"issue_type":"feature","last_activity":null,"metadata":"{}","mol_type":"","notes":"Implemented: alerts/claude-usage.yaml with 5 Prometheus alerting rules - session utilization warning (\u003e80%) and critical (\u003e95%), weekly utilization warning (\u003e80%) and critical (\u003e95%), poll errors sustained \u003e5min (critical). All rules include account label, meaningful summaries, and work with standard alertmanager.","original_size":null,"owner":"graeme@graemef.dev","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Add Prometheus alerting rules","updated_at":"2026-02-28T08:58:52Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/polecats/jasper","await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T09:00:36Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"1054f82e0b9f704bb32962bb609f0e4d4392cbd023f6023462a654dc874a1704","created_at":"2026-02-28T08:56:17Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"attached_molecule: cue-wisp-yj2t7\nattached_formula: mol-polecat-work\nattached_at: 2026-02-28T08:56:26Z\ndispatched_by: mayor\n\nCreate docker-compose.yaml with exporter + Prometheus + Grafana. Mount the Grafana dashboard and Prometheus scrape config automatically so it's zero-config after filling in accounts.yaml. Include a prometheus/prometheus.yaml scrape config and grafana/provisioning setup. Document in README that this is the fastest way to get a working stack.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-6ni","is_template":0,"issue_type":"feature","last_activity":null,"metadata":"{}","mol_type":"","notes":"Implemented Docker Compose quickstart: docker-compose.yaml with exporter + Prometheus + Grafana, prometheus/prometheus.yaml scrape config, grafana provisioning (datasource + dashboard directory), pre-built Claude Usage dashboard (claude-usage.json) covering all 7 metrics. README updated with quickstart section. Zero-config after filling in accounts.yaml.","original_size":null,"owner":"graeme@graemef.dev","payload":"","pinned":0,"priority":3,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Add Docker Compose quickstart","updated_at":"2026-02-28T09:00:36Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/polecats/onyx","await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"c87a57a54378d76287d708db69e72629eea373c95d6fc5cb860ea773f2b55ca4","created_at":"2026-02-28T08:57:38Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"attached_molecule: cue-wisp-i1sdy\nattached_formula: mol-polecat-work\nattached_at: 2026-02-28T08:57:45Z\ndispatched_by: mayor\n\nAdd org_id as an explicit OTEL attribute alongside 'account' on all metrics. This is the join key between the usage exporter and Claude Code OTEL metrics, which emit organization.id as a resource attribute. With both datasets in Prometheus/Grafana, you can correlate which CC host is consuming which account's quota — enabling alerts like 'host X needs its session key rotated'. Update the Grafana dashboard to include a correlation panel demonstrating this join: CC OTEL host metrics joined to usage exporter via org_id = organization_id.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-6z7","is_template":0,"issue_type":"feature","last_activity":null,"metadata":"{}","mol_type":"","notes":"Implementation: Added org_id attribute alongside account on all metrics in poller.go. Created Grafana dashboard at grafana/claude-usage-exporter.json with CC OTEL correlation panel (table join via org_id = organization_id). Updated README with org_id label docs and dashboard section.","original_size":null,"owner":"graeme@graemef.dev","payload":"","pinned":0,"priority":1,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"hooked","target":"","timeout_ns":0,"title":"Add org_id label to all metrics for CC OTEL correlation","updated_at":"2026-02-28T09:01:37Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/polecats/obsidian","await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"7ba42f6a1cfffb8d6fb0ed1ed77c28246de59c551759a17976cad205d201bc04","created_at":"2026-02-28T08:58:34Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"attached_molecule: cue-wisp-9nouy\nattached_formula: mol-polecat-work\nattached_at: 2026-02-28T09:37:02Z\ndispatched_by: mayor\n\nUpdate the Grafana dashboard (from cue-6ni) to add a correlation panel that joins usage exporter metrics with Claude Code OTEL metrics via org_id = organization_id. The panel should show: which hosts (from CC OTEL instance/resource labels) are active on each account, the account's current session and weekly utilization alongside the active hosts, making it easy to identify which host needs its session key rotated when an account is running low. Depends on cue-6ni (base dashboard) and cue-6z7 (org_id label on metrics).","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-b3g","is_template":0,"issue_type":"feature","last_activity":null,"metadata":"{}","mol_type":"","notes":"Implemented: Added 3 panels to the quickstart Grafana dashboard (grafana/dashboards/claude-usage.json):\n1. CC OTEL Correlation table — joins usage exporter metrics with CC OTEL resource_info via label_replace(organization_id → org_id). Shows account, org_id, host_name, session %, and weekly % with color-coded thresholds. Sorted by session % descending so high-utilization accounts are immediately visible for session key rotation.\n2. Session Utilization by Org bar gauge — horizontal gradient bars showing session utilization per account with org_id in legend for CC OTEL correlation.\n3. Weekly Utilization by Org bar gauge — same for weekly utilization.\nAlso added 'otel' tag to dashboard for discoverability.","original_size":null,"owner":"graeme@graemef.dev","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"in_progress","target":"","timeout_ns":0,"title":"Add CC OTEL correlation panel to Grafana dashboard","updated_at":"2026-02-28T09:41:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/polecats/obsidian","await_id":"","await_type":"","close_reason":"Completed with no code changes (already fixed or pushed directly to main)","closed_at":"2026-02-28T09:58:20Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"313b1d53d1acfaaaf993d6f0c8a0715c3d5ae125aa2351b22f8fc398064499cf","created_at":"2026-02-28T09:52:43Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"attached_molecule: cue-wisp-a4efj\nattached_formula: claude-usage-exporter-release\nattached_at: 2026-02-28T09:54:23Z\ndispatched_by: mayor\n\nRelease version 0.1.0 of claude-usage-exporter. Run the claude-usage-exporter-release formula.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-b8k","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"Release v0.1.0 — FINAL STATUS:\n\nCompleted steps:\n- [x] Verify orientation — correct repo\n- [x] Preflight git status — clean\n- [x] Preflight pull — up to date  \n- [x] Review changes — 14 commits, initial release\n- [x] Nix build .#default — passed\n- [x] Nix build .#dockerImage — passed\n- [x] Version 0.1.0 already set in flake.nix\n- [x] Created annotated tag v0.1.0\n- [x] Pushed tag v0.1.0 to origin\n- [x] CI release workflow passed (run 22518467145, 59s) — image pushed to ghcr.io\n- [x] Image verification — CI \"Push image\" step succeeded (no docker/packages API access to verify externally)\n\nBlocked step:\n- [ ] GitHub Release creation — PAT lacks contents:write (HTTP 403)\n  - Escalated: hq-wisp-du03v (severity: HIGH, routed to mayor)\n  - Release notes prepared in escalation\n\nThe release is functionally complete:\n- Tag v0.1.0 exists on origin\n- Docker image ghcr.io/graemef/claude-usage-exporter:v0.1.0 is published\n- Only the GitHub Release page needs to be created (cosmetic/discovery)","original_size":null,"owner":"graeme@graemef.dev","payload":"","pinned":0,"priority":1,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Release v0.1.0","updated_at":"2026-02-28T09:58:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"done","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":"2026-02-28T09:15:30Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3cdd49d4cf42adf426e029b30b39ba81c95b4ea617ad8a5b0f11363fed174a0f","created_at":"2026-02-28T08:56:22Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"cue-claude_usage_exporter-polecat-jasper\n\nrole_type: polecat\nrig: claude_usage_exporter\nagent_state: nuked\nhook_bead: null\ncleanup_status: null\nactive_mr: null\nnotification_level: null","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-claude_usage_exporter-polecat-jasper","is_template":0,"issue_type":"agent","last_activity":"2026-02-28T09:00:36Z","metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"cue-claude_usage_exporter-polecat-jasper","updated_at":"2026-02-28T09:15:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"done","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"02af94367caf861c0e296ade9a05e21a85259f49d9c4c01ac94840befd87507c","created_at":"2026-02-28T08:42:43Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"cue-claude_usage_exporter-polecat-obsidian\n\nrole_type: polecat\nrig: claude_usage_exporter\nagent_state: spawning\nhook_bead: cue-b8k\ncleanup_status: clean\nactive_mr: null\nnotification_level: null\nexit_type: COMPLETED\nbranch: polecat/obsidian/cue-b8k@mm659hut\ncompletion_time: 2026-02-28T09:58:20Z","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-claude_usage_exporter-polecat-obsidian","is_template":0,"issue_type":"agent","last_activity":"2026-02-28T09:58:22Z","metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"cue-claude_usage_exporter-polecat-obsidian","updated_at":"2026-02-28T09:58:22Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"working","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":"2026-02-28T09:15:30Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9d105de67a30c35ffd12cf58ae29c82bd59e76b28851b7c03436f6908671e77c","created_at":"2026-02-28T08:57:42Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"cue-claude_usage_exporter-polecat-onyx\n\nrole_type: polecat\nrig: claude_usage_exporter\nagent_state: spawning\nhook_bead: cue-6z7\ncleanup_status: null\nactive_mr: null\nnotification_level: null","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"cue-6z7","id":"cue-claude_usage_exporter-polecat-onyx","is_template":0,"issue_type":"agent","last_activity":"2026-02-28T08:57:48Z","metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"cue-claude_usage_exporter-polecat-onyx","updated_at":"2026-02-28T09:15:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"done","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":"2026-02-28T09:15:30Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"48af5493dfef628ebe4ea710ed04e3e841ae25c054e4e67aa915c2d1a5be331b","created_at":"2026-02-28T08:42:54Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"cue-claude_usage_exporter-polecat-quartz\n\nrole_type: polecat\nrig: claude_usage_exporter\nagent_state: nuked\nhook_bead: null\ncleanup_status: null\nactive_mr: null\nnotification_level: null","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-claude_usage_exporter-polecat-quartz","is_template":0,"issue_type":"agent","last_activity":"2026-02-28T09:09:11Z","metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"cue-claude_usage_exporter-polecat-quartz","updated_at":"2026-02-28T09:15:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"484bf54489e11fbc45f2a70212996e9518b7e0bb221fddd80b9edd682c32d1d0","created_at":"2026-02-28T08:40:10Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"Refinery for claude_usage_exporter - processes merge queue.\n\nrole_type: refinery\nrig: claude_usage_exporter\nagent_state: idle\nhook_bead: null\ncleanup_status: null\nactive_mr: null\nnotification_level: null","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-claude_usage_exporter-refinery","is_template":0,"issue_type":"agent","last_activity":"2026-02-28T10:06:23Z","metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Refinery for claude_usage_exporter - processes merge queue.","updated_at":"2026-02-28T10:06:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"ba812547b42f18524a3e052bc0f44a17df985dff341cb9cca6006941c67eb6bb","created_at":"2026-02-28T08:40:10Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"Witness for claude_usage_exporter - monitors polecat health and progress.\n\nrole_type: witness\nrig: claude_usage_exporter\nagent_state: idle\nhook_bead: null\ncleanup_status: null\nactive_mr: null\nnotification_level: null","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-claude_usage_exporter-witness","is_template":0,"issue_type":"agent","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Witness for claude_usage_exporter - monitors polecat health and progress.","updated_at":"2026-02-28T08:40:10Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/polecats/quartz","await_id":"","await_type":"","close_reason":"Completed with no code changes (already fixed or pushed directly to main)","closed_at":"2026-02-28T09:09:09Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"7c936bcd75278bc3b110caf2a79c13059ad764c54363cb84b80594d0e5ab8832","created_at":"2026-02-28T09:03:10Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"attached_molecule: cue-wisp-kdk7d\nattached_formula: mol-polecat-work\nattached_at: 2026-02-28T09:03:32Z\ndispatched_by: mayor\n\nCreate .beads/formulas/claude-usage-exporter-release.formula.toml adapted from my_round's release formula. Steps:\n\n1. verify-orientation — check pwd, git remote -v points to GraemeF/claude-usage-exporter, correct repo\n2. preflight-git — git status clean\n3. preflight-pull — git pull --rebase origin main\n4. review-changes — git log since last tag --oneline to understand what's being released\n5. run-build — nix build .#default and nix build .#dockerImage to verify it compiles (no test suite yet — note this in step)\n6. fix-failures — only if build failed, file beads and sling polecats\n7. bump-version — update version string in flake.nix (version = \"{{version}}\"), commit with 'chore: Release v{{version}}'\n8. create-tag — git tag -a v{{version}} -m 'Release v{{version}}'\n9. push-main — git push origin main\n10. push-tag — git push origin v{{version}} (triggers GHA docker build)\n11. wait-ci — monitor GHA, expect ~5 min\n12. create-gh-release — HANDWRITTEN notes required, DO NOT use --generate-notes. Use gh release create v{{version}} with sections: What's new, Fixes, Docker image pull command (ghcr.io/graemef/claude-usage-exporter:v{{version}}). Verify at GitHub releases page.\n13. verify-image — docker pull ghcr.io/graemef/claude-usage-exporter:v{{version}}, confirm it starts\n14. release-complete — summary\n\nNO deploy-verify step (no auto-deployment). Formula var: version (required, semver e.g. 1.0.0).","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-ctd","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"Implemented: Created .beads/formulas/claude-usage-exporter-release.formula.toml with 14 sequential steps: verify-orientation, preflight-git, preflight-pull, review-changes, run-build, fix-failures, bump-version, create-tag, push-main, push-tag, wait-ci, create-gh-release, verify-image, release-complete. Single required var: version (semver). Adapted from my-round-release formula. Key differences: nix build instead of make verify, flake.nix version bump instead of gleam.toml, no deploy-verify step, no test suite noted. Formula validated: parses correctly, all 14 steps with linear dependency chain.","original_size":null,"owner":"graeme@graemef.dev","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Create release formula","updated_at":"2026-02-28T09:09:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/polecats/obsidian","await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T09:51:33Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9e75147d3a89b73877b455ace7c4213232d6f9e70aa54a295c1b27f39421060e","created_at":"2026-02-28T08:40:22Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"attached_molecule: cue-wisp-hvvmr\nattached_formula: mol-polecat-work\nattached_at: 2026-02-28T09:27:23Z\ndispatched_by: mayor\n\nCreate .github/workflows/publish.yml. On push to main and on version tags: run nix build .#dockerImage, load the OCI archive, and push to ghcr.io/graemef/claude-usage-exporter. Tag with :latest on main and :\u003cversion\u003e on tags. Authenticate using GITHUB_TOKEN.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-dbv","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"Implemented: Added .github/workflows/publish.yml that triggers on push to main and calls the existing reusable docker.yml workflow. Tags image with main-\u003csha\u003e and :latest. Release tags already handled by existing release.yml.","original_size":null,"owner":"graeme@graemef.dev","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Add GitHub Actions: build \u0026 publish container image to ghcr.io","updated_at":"2026-02-28T09:51:33Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/polecats/obsidian","await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"0ede99ba2eadf24e06af4ce23ff7e9f898bc28576ac513e102adb18a48e2cae1","created_at":"2026-02-28T09:02:58Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"attached_molecule: cue-wisp-28kig\nattached_formula: mol-polecat-work\nattached_at: 2026-02-28T09:03:32Z\ndispatched_by: mayor\n\nAdapt from my_round workflows. Three files:\n\n1. .github/workflows/docker.yml — reusable workflow_call, inputs: version. Install Nix (cachix/install-nix-action@v30), nix build .#dockerImage, docker load \u003c result, tag and push to ghcr.io as :version and :latest. Use GITHUB_REPOSITORY lowercase for image name.\n\n2. .github/workflows/test.yml — on push to main (paths-ignore .beads/**) and pull_request and workflow_call. Jobs: build (nix build .#default), flake-check (nix flake check). Alert-on-failure job if main branch fails: create GitHub issue with ci-failure label (same pattern as my_round).\n\n3. .github/workflows/release.yml — on push to tags v*. concurrency group. Calls docker.yml with version: github.ref_name. NO deploy job. After docker job: create-release job using gh release create with --title and --notes (placeholder notes — the formula handles the real notes). Actually: the release workflow should NOT create the GH release — that is done manually via the formula with handwritten notes. So release.yml just calls docker.yml.\n\nNo gleam-specific steps. No deploy step.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-df8","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"Implemented three GHA workflows adapted from my_round patterns: test.yml (build + flake-check + alert-on-failure), docker.yml (reusable Nix docker build + ghcr.io push), release.yml (v* tag trigger calling docker workflow). No gleam steps, no deploy job, no GH release creation.","original_size":null,"owner":"graeme@graemef.dev","payload":"","pinned":0,"priority":1,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"in_progress","target":"","timeout_ns":0,"title":"Add GHA workflows (test, docker, release)","updated_at":"2026-02-28T09:54:26Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/polecats/quartz","await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T08:47:35Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"7ae4e8ab0e039962ca1366d60b50188283e2506a9c39738172d3fcf6d2b59e15","created_at":"2026-02-28T08:40:22Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"attached_molecule: cue-wisp-0u33\nattached_formula: mol-polecat-work\nattached_at: 2026-02-28T08:42:57Z\ndispatched_by: mayor\n\nCover: what it does, the adaptive polling behaviour (active vs idle intervals, reset burst window), Prometheus metrics exposed, OTLP support via env var, accounts.yaml config reference, nix run / docker usage examples.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-dl4","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"Implemented: README.md covering all six required topics — what it does, adaptive polling behaviour (active/idle/burst), Prometheus metrics table, OTLP env var support, accounts.yaml config reference, and nix run/docker usage examples.","original_size":null,"owner":"graeme@graemef.dev","payload":"","pinned":0,"priority":3,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Write README","updated_at":"2026-02-28T08:47:35Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/polecats/obsidian","await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T08:45:56Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"0ff2228750700de3ed2dc79416786cf709b91836d6ea69b22e050927ec6baec5","created_at":"2026-02-28T08:40:15Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"attached_molecule: cue-wisp-1oyv\nattached_formula: mol-polecat-work\nattached_at: 2026-02-28T08:42:46Z\ndispatched_by: mayor\n\nRun go mod tidy to generate go.sum, then nix build to compute the correct vendorHash. Replace the pkgs.lib.fakeHash placeholder in flake.nix with the real hash. Commit go.sum and the updated flake.nix.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-jx6","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"Implemented: ran go mod tidy to generate go.sum, ran nix build to compute vendorHash (sha256-9K619hTXYJ0h1c9ZEZLHNPwJxVRDTW0XFFMD55nGezk=), replaced pkgs.lib.fakeHash in flake.nix. Build verified successful.","original_size":null,"owner":"graeme@graemef.dev","payload":"","pinned":0,"priority":1,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Fix vendorHash in flake.nix","updated_at":"2026-02-28T08:45:56Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"84abc4ea5b22093869ee4703134b31fbf2407b5cc1f81eac556f606a2cecfa81","created_at":"2026-02-28T08:40:10Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"Rig identity bead for claude_usage_exporter.\n\nrepo: git@github.com:GraemeF/claude-usage-exporter.git\nprefix: cue\nstate: active","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-rig-claude_usage_exporter","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"claude_usage_exporter","updated_at":"2026-02-28T08:40:10Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/polecats/obsidian","await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"7e031a7f23cc2241c1c120aea00dc60be468aff508f8e6ef817033d8f6cf340f","created_at":"2026-02-28T08:56:17Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"attached_molecule: cue-wisp-2adtc\nattached_formula: mol-polecat-work\nattached_at: 2026-02-28T08:56:25Z\ndispatched_by: mayor\n\nCreate dashboards/claude-usage.json with panels: session and weekly utilization over time (line graph, per account), current utilization gauges with thresholds (green/yellow/red), time until reset (derived from reset unix timestamp), adaptive poll interval over time (shows the active/idle behaviour), poll error rate. Export as a portable dashboard JSON importable via Grafana UI or provisioning.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-sx0","is_template":0,"issue_type":"feature","last_activity":null,"metadata":"{}","mol_type":"","notes":"Implemented: dashboards/claude-usage.json with 7 panels — session/weekly utilization gauges (green\u003c50/yellow\u003c80/red thresholds), utilization-over-time timeseries, time-until-reset stats, adaptive poll interval history (stepAfter interpolation), poll error rate. Uses __inputs for portable datasource selection. Template variable for account filtering.","original_size":null,"owner":"graeme@graemef.dev","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"in_progress","target":"","timeout_ns":0,"title":"Add Grafana dashboard JSON","updated_at":"2026-02-28T09:03:35Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"cd04eafd6cb3229e545c808f5c4de8961b95bb943104a4d5769ed7d9069b3c8c","created_at":"2026-02-28T10:01:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nInbox should contain ONLY:\n- Unprocessed MERGE_READY messages (will process next cycle)\n- Active work items\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- PATROL: Wake up that was acknowledged → archive\n- HELP/Blocked that was handled → archive\n- MERGE_READY where merge completed but archive was missed → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Check for orphaned MR beads**\n\nLook for open MR beads with no corresponding branch:\n```bash\nbd list --type=merge-request --status=open\n```\n\nFor each open MR bead:\n1. Check if branch exists: `git ls-remote origin refs/heads/\u003cbranch\u003e`\n2. Determine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n3. If branch is gone, pick `\u003cverification-target\u003e`:\n   - If `origin/\u003cmerge-target\u003e` exists, use `\u003cmerge-target\u003e`.\n   - If `origin/\u003cmerge-target\u003e` is missing (e.g. deleted integration branch), use `main`.\n4. Verify landed work: `git log origin/\u003cverification-target\u003e --oneline | grep \"\u003csource_issue\u003e\"`\n5. If work found → close MR with reason \"Merged (verified on \u003cverification-target\u003e; merge target was \u003cmerge-target\u003e)\"\n6. If work NOT found → investigate before closing:\n   - Check source_issue validity (should be gt-xxxxx, not branch name)\n   - Search reflog/dangling commits if possible\n   - If unverifiable, close with reason \"Unverifiable - no audit trail\"\n   - File bead if this indicates lost work\n\n**NEVER close an MR bead without verifying the work landed or is unrecoverable.**\n\n**Goal**: Inbox should have ≤3 active messages at end of cycle.\nKeep only: pending MRs in queue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-00m67","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T10:01:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9fd4f8fe6af19dea2254cbcfdca80525f6869f79b5dc6d06ecb32289bda67fe0","created_at":"2026-02-28T10:01:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision. Use the signals from context-check to decide.\n\n**If you decide to continue patrolling:**\n\nUse await-event to subscribe to the refinery event channel with exponential backoff:\n\n```bash\ngt mol step await-event --channel refinery --agent-bead gt-\u003crig\u003e-refinery --backoff-base 30s --backoff-mult 2 --backoff-max 5m --cleanup\n```\n\nThis command:\n1. Watches `~/gt/events/refinery/` for event files (polling-based)\n2. Returns IMMEDIATELY when an event is emitted (MERGE_READY, PATROL_WAKE, MQ_SUBMIT)\n3. If no events, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on refinery agent bead for backoff state\n5. `--cleanup` auto-deletes processed event files\n\n**Supported events:**\n- `MERGE_READY` — from witness when polecat branch is pushed and ready to merge\n- `PATROL_WAKE` — from witness when MRs waiting but refinery appears idle\n- `MQ_SUBMIT` — from polecat via `gt mq submit`\n\n**On event received** (refinery-specific activity):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no events):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-event returns (either by event or timeout):\n1. **Re-assess session health** (check RSS, context, age again — conditions change)\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary: branches merged, test results, queue state\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If you decide to hand off:**\n\nReport and exit using `gt handoff` for clean session transition:\n\n```bash\ngt handoff -s \"Patrol complete\" -m \"Merged X branches, Y tests passed.\nQueue: empty/N remaining\nRSS: X MB, Session age: Xh\nNext: [any notes for successor]\"\n```\n\n`gt handoff` sends handoff mail to yourself, respawns with a fresh Claude instance,\nSessionStart hook runs gt prime, and your successor picks up from the hook.\n\n**DO NOT just exit.** Always use `gt handoff` for proper lifecycle.\n\n**IMPORTANT**: Never sleep-poll manually (e.g., `sleep 30 \u0026\u0026 bd list`).\nAlways use `gt mol step await-event` — it's event-driven and tracks backoff state.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-03knh","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Burn and respawn or loop","updated_at":"2026-02-28T10:01:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"2d55bf464372df8061da3e1abb103da25c278b225766ef1df3604ce63260ed0b","created_at":"2026-02-28T09:54:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Stage and commit the version bump.\n\n```bash\ngit add flake.nix\ngit commit -m \"chore: Release v0.1.0\"\n```\n","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-08oiv","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Commit release","updated_at":"2026-02-28T09:54:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b5b41d316559ab36d81b013937c0b56a205c257b0f96499632c4e34fb4d420c5","created_at":"2026-02-28T09:30:15Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check the beads merge queue - this is the SOURCE OF TRUTH for pending merges.\n\n```bash\ngit fetch --prune origin\ngt mq list \u003crig\u003e\n```\n\nThe beads MQ tracks all pending merge requests. Do NOT rely on `git branch -r | grep polecat`\nas branches may exist without MR beads, or MR beads may exist for already-merged work.\n\nIf queue empty, skip to \"check-integration-branches\" step.\n\nFor each MR in the queue, verify the branch still exists:\n```bash\ngit branch -r | grep \u003cbranch\u003e\n```\n\nIf branch doesn't exist for a queued MR:\n- Close the MR bead: `bd close \u003cmr-id\u003e --reason \"Branch no longer exists\"`\n- Remove from processing queue\n\nTrack verified MR list for this cycle.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-0gshr","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Scan merge queue","updated_at":"2026-02-28T09:30:15Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"eed9910be82542932766d47061247f1b5b22762ba5dbe3ada169ccff68b03773","created_at":"2026-02-28T09:27:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure ALL implementation work is committed before cleanup.\n\n**CRITICAL: You MUST commit all changes from implementation.**\nNEVER use `git checkout -- .` or `git restore .` to discard implementation work.\nALWAYS commit ALL uncommitted changes from your implementation.\n\n**1. Check for uncommitted changes:**\n```bash\ngit status\n```\n\n**2. If there are ANY uncommitted changes, commit them now:**\n```bash\ngit add -A \u0026\u0026 git commit -m \"\u003ctype\u003e: \u003cdescriptive message\u003e (cue-dbv)\"\n```\n\n**3. If working tree is already clean, skip.**\n\n**4. VERIFY:**\n```bash\ngit status\n```\nMust show \"nothing to commit, working tree clean\".\n\n**5. Verify you have commits:**\n```bash\ngit log origin/main..HEAD --oneline\n```\nIf you made changes during implementation, this MUST show at least 1 commit.\n\n**Exit criteria:** All changes committed. Working tree clean.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-0h6g5","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Commit all implementation changes","updated_at":"2026-02-28T09:27:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9742ae1fab9e73984581e4aacf23f1a5675564600ae2da6e3e08eb76135a7ed5","created_at":"2026-02-28T09:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: integration_branch_refinery_enabled = true**\n**Config: integration_branch_auto_land = false**\n\nRead the two config values above, then:\n\n- If integration_branch_refinery_enabled = \"false\": Say \"Integration branches disabled.\" Close step.\n- If integration_branch_auto_land = \"false\": Say \"Auto-land disabled, nothing to do.\" Close step.\n  FORBIDDEN: If auto_land is false, you MUST NOT land integration branches yourself using\n  raw git commands. Do not merge integration branches to the default/target branch. Do not push\n  integration branch merges. The auto_land=false setting means landing requires a human\n  to run `gt mq integration land` manually. Respect this boundary unconditionally.\n- If BOTH are \"true\":\n  1. `bd list --type=epic --status=open` to find epics\n  2. `gt mq integration status \u003cepic-id\u003e` for each epic\n  3. If `ready_to_land: true`: run `gt mq integration land \u003cepic-id\u003e`\n  4. If `ready_to_land: false`: do nothing, epic work is incomplete\n  Never land partial epics — ALL children must be closed first.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-0l9n0","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check integration branches for landing","updated_at":"2026-02-28T09:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T08:59:50Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-0mf73","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T08:59:50Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T08:59:05Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-0mq2f","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T08:59:05Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T08:57:59Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-0pcmk","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T08:57:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a256b80855afd3ac284a3902b23415a9b78a62c489f52e7491b2b3e9db95bc90","created_at":"2026-02-28T09:31:42Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check mail for MERGE_READY submissions, escalations, and messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**MERGE_READY**:\nA polecat's work is ready for merge. Extract details and track for processing.\n\n```bash\n# Parse MERGE_READY message body:\n# Branch: \u003cbranch\u003e\n# Issue: \u003cissue-id\u003e\n# Polecat: \u003cpolecat-name\u003e\n# MR: \u003cmr-bead-id\u003e\n# Verified: clean git state, issue closed\n\n# Track in your merge queue for this patrol cycle:\n# - Branch name\n# - Issue ID\n# - Polecat name (REQUIRED for MERGED notification)\n# - MR bead ID (REQUIRED for closing after merge)\n```\n\n**IMPORTANT**: You MUST track the polecat name, MR bead ID, AND message ID - you will need them\nin merge-push step to send MERGED notification, close the MR bead, and archive the mail.\n\nMark as read. The work will be processed in queue-scan/process-branch.\n**Do NOT archive yet** - archive after merge/reject decision in merge-push step.\n\n**PATROL: Wake up**:\nWitness detected MRs waiting but refinery idle. Acknowledge and archive:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HELP / Blocked**:\nAssess and respond. If you can't help, escalate to Mayor.\nArchive after handling:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Check for in-flight merges.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: pending MRs in queue. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-0ziw7","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery mail","updated_at":"2026-02-28T09:31:42Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"132623488ae64fe25d1fcd85ae325a360327eb24c2a9232813b975eecfd2171b","created_at":"2026-02-28T09:54:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Push the release commit to origin.\n\n```bash\ngit push origin main\n```\n","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-11g00","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Push to main","updated_at":"2026-02-28T09:54:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"769447c96532d91233b37d97c63c883444ba63231b19c4d70e37300549e8b8af","created_at":"2026-02-28T09:31:42Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**VERIFICATION GATE**: This step enforces the Beads Promise.\n\nIf all checks and tests PASSED: This step auto-completes. Proceed to merge.\n\nIf any check or test FAILED:\n1. Diagnose: Is this a branch regression or pre-existing on the target branch?\n2. If branch caused it:\n   - Abort merge\n   - **REOPEN the source issue** so it returns to the ready queue:\n     ```bash\n     bd update \u003cissue-id\u003e --status=open --assignee=\"\"\n     bd sync\n     ```\n   - Notify witness of rejection using the MERGE_FAILED protocol:\n     ```bash\n     gt mail send \u003crig\u003e/witness -s \"MERGE_FAILED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\n     Issue: \u003cissue-id\u003e\n     Polecat: \u003cpolecat-name\u003e\n     Rig: \u003crig\u003e\n     FailureType: quality-check\n     Error: \u003cfailure description\u003e\"\n     ```\n   - Close the MR bead as rejected:\n     ```bash\n     bd close \u003cmr-bead-id\u003e --reason \"Rejected: \u003cfailure description\u003e\"\n     ```\n   - Delete the rejected branch (a new polecat will create a fresh one):\n     ```bash\n     git push origin --delete \u003cpolecat-branch\u003e\n     ```\n   - Archive the MERGE_READY message\n   - Skip to loop-check\n3. If pre-existing on the target branch:\n   - **DUPLICATE CHECK (MANDATORY)**: Before filing a new bug, search for existing open bugs:\n     ```bash\n     bd search \"\u003cfailure description\u003e\" --status open --label gt:bug --limit 5\n     ```\n     If an existing open bug covers the same failure, do NOT create a duplicate.\n     Instead, note the existing bead ID and proceed.\n   - Only if NO existing bug matches: bd create --type=bug --priority=1 --title=\"Pre-existing failure: \u003cdescription\u003e\"\n   - FORBIDDEN: Writing code to fix quality check or test failures. You merge branches, you do not develop.\n   - Proceed with the merge if the failure is pre-existing (not caused by the branch).\n\n**REJECTION CHECKLIST** (all required before skipping to loop-check):\n- [ ] Source issue reopened (bd update \u003cissue-id\u003e --status=open --assignee=\"\")\n- [ ] MERGE_FAILED notification sent to witness\n- [ ] MR bead closed with rejection reason\n- [ ] Rejected branch deleted from remote\n- [ ] MERGE_READY message archived\n\n**GATE REQUIREMENT**: You CANNOT proceed to merge-push without:\n- All quality checks and tests passing, OR\n- Bead filed (or existing duplicate confirmed) for the pre-existing failure\n\nFORBIDDEN: Writing application code, exploring polecat implementations, or\nre-implementing fixes. You are a mechanical merge processor.\n\nThis is non-negotiable. Never disavow. Never \"note and proceed.\" ","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-133pj","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Handle quality check or test failures","updated_at":"2026-02-28T09:31:42Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"921a349226d136b8685167bf79f987de0968a5e8165a34991f394b4f207c5677","created_at":"2026-02-28T09:27:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Initialize your session and understand your assignment.\n\n**1. Prime your environment:**\n```bash\ngt prime                    # Load role context\nbd prime                    # Load beads context\n```\n\n**2. Check your hook:**\n```bash\ngt hook               # Shows your pinned molecule and hook_bead\n```\n\nThe hook_bead is your assigned issue. Read it carefully:\n```bash\nbd show cue-dbv           # Full issue details\n```\n\n**3. Check inbox for additional context:**\n```bash\ngt mail inbox\n# Read any HANDOFF or assignment messages\n```\n\n**4. Understand the requirements:**\n- What exactly needs to be done?\n- What files are likely involved?\n- Are there dependencies or blockers?\n- What does \"done\" look like?\n\n**5. Verify you can proceed:**\n- No unresolved blockers on the issue\n- You understand what to do\n- Required resources are available\n\nIf blocked or unclear, mail Witness immediately:\n```bash\ngt mail send \u003crig\u003e/witness -s \"HELP: Unclear requirements\" -m \"Issue: cue-dbv\nQuestion: \u003cwhat you need clarified\u003e\"\n```\n\n**Exit criteria:** You understand the work and can begin implementation.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-13exj","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Load context and verify assignment","updated_at":"2026-02-28T09:27:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"769447c96532d91233b37d97c63c883444ba63231b19c4d70e37300549e8b8af","created_at":"2026-02-28T10:01:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**VERIFICATION GATE**: This step enforces the Beads Promise.\n\nIf all checks and tests PASSED: This step auto-completes. Proceed to merge.\n\nIf any check or test FAILED:\n1. Diagnose: Is this a branch regression or pre-existing on the target branch?\n2. If branch caused it:\n   - Abort merge\n   - **REOPEN the source issue** so it returns to the ready queue:\n     ```bash\n     bd update \u003cissue-id\u003e --status=open --assignee=\"\"\n     bd sync\n     ```\n   - Notify witness of rejection using the MERGE_FAILED protocol:\n     ```bash\n     gt mail send \u003crig\u003e/witness -s \"MERGE_FAILED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\n     Issue: \u003cissue-id\u003e\n     Polecat: \u003cpolecat-name\u003e\n     Rig: \u003crig\u003e\n     FailureType: quality-check\n     Error: \u003cfailure description\u003e\"\n     ```\n   - Close the MR bead as rejected:\n     ```bash\n     bd close \u003cmr-bead-id\u003e --reason \"Rejected: \u003cfailure description\u003e\"\n     ```\n   - Delete the rejected branch (a new polecat will create a fresh one):\n     ```bash\n     git push origin --delete \u003cpolecat-branch\u003e\n     ```\n   - Archive the MERGE_READY message\n   - Skip to loop-check\n3. If pre-existing on the target branch:\n   - **DUPLICATE CHECK (MANDATORY)**: Before filing a new bug, search for existing open bugs:\n     ```bash\n     bd search \"\u003cfailure description\u003e\" --status open --label gt:bug --limit 5\n     ```\n     If an existing open bug covers the same failure, do NOT create a duplicate.\n     Instead, note the existing bead ID and proceed.\n   - Only if NO existing bug matches: bd create --type=bug --priority=1 --title=\"Pre-existing failure: \u003cdescription\u003e\"\n   - FORBIDDEN: Writing code to fix quality check or test failures. You merge branches, you do not develop.\n   - Proceed with the merge if the failure is pre-existing (not caused by the branch).\n\n**REJECTION CHECKLIST** (all required before skipping to loop-check):\n- [ ] Source issue reopened (bd update \u003cissue-id\u003e --status=open --assignee=\"\")\n- [ ] MERGE_FAILED notification sent to witness\n- [ ] MR bead closed with rejection reason\n- [ ] Rejected branch deleted from remote\n- [ ] MERGE_READY message archived\n\n**GATE REQUIREMENT**: You CANNOT proceed to merge-push without:\n- All quality checks and tests passing, OR\n- Bead filed (or existing duplicate confirmed) for the pre-existing failure\n\nFORBIDDEN: Writing application code, exploring polecat implementations, or\nre-implementing fixes. You are a mechanical merge processor.\n\nThis is non-negotiable. Never disavow. Never \"note and proceed.\" ","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-17xjl","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Handle quality check or test failures","updated_at":"2026-02-28T10:01:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T09:52:37Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T09:41:51Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-1c1ug","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T09:52:37Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"dfab2e7b59734313316899e100837d3f7a1e7098c4c55ea83db66528f85eaefe","created_at":"2026-02-28T09:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"More branches to process?\n\n**Entry paths:**\n- Normal: After successful merge-push\n- Conflict-skip: After process-branch created conflict-resolution task\n\nIf yes: Return to process-branch with next branch.\nIf no: Continue to generate-summary.\n\n**Track for this cycle:**\n- branches_merged: count and names of successfully merged branches\n- branches_conflict: count and names of branches skipped due to conflicts\n- conflict_tasks: IDs of conflict-resolution tasks created\n\nThis tracking feeds into generate-summary for the patrol digest.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-1cpjw","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check for more work","updated_at":"2026-02-28T09:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9742ae1fab9e73984581e4aacf23f1a5675564600ae2da6e3e08eb76135a7ed5","created_at":"2026-02-28T09:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: integration_branch_refinery_enabled = true**\n**Config: integration_branch_auto_land = false**\n\nRead the two config values above, then:\n\n- If integration_branch_refinery_enabled = \"false\": Say \"Integration branches disabled.\" Close step.\n- If integration_branch_auto_land = \"false\": Say \"Auto-land disabled, nothing to do.\" Close step.\n  FORBIDDEN: If auto_land is false, you MUST NOT land integration branches yourself using\n  raw git commands. Do not merge integration branches to the default/target branch. Do not push\n  integration branch merges. The auto_land=false setting means landing requires a human\n  to run `gt mq integration land` manually. Respect this boundary unconditionally.\n- If BOTH are \"true\":\n  1. `bd list --type=epic --status=open` to find epics\n  2. `gt mq integration status \u003cepic-id\u003e` for each epic\n  3. If `ready_to_land: true`: run `gt mq integration land \u003cepic-id\u003e`\n  4. If `ready_to_land: false`: do nothing, epic work is incomplete\n  Never land partial epics — ALL children must be closed first.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-1klw3","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check integration branches for landing","updated_at":"2026-02-28T09:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T10:08:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-1ofvq","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T10:08:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T09:06:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-21tkt","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T09:06:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T08:54:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-24aud","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T08:54:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9fd4f8fe6af19dea2254cbcfdca80525f6869f79b5dc6d06ecb32289bda67fe0","created_at":"2026-02-28T09:42:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision. Use the signals from context-check to decide.\n\n**If you decide to continue patrolling:**\n\nUse await-event to subscribe to the refinery event channel with exponential backoff:\n\n```bash\ngt mol step await-event --channel refinery --agent-bead gt-\u003crig\u003e-refinery --backoff-base 30s --backoff-mult 2 --backoff-max 5m --cleanup\n```\n\nThis command:\n1. Watches `~/gt/events/refinery/` for event files (polling-based)\n2. Returns IMMEDIATELY when an event is emitted (MERGE_READY, PATROL_WAKE, MQ_SUBMIT)\n3. If no events, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on refinery agent bead for backoff state\n5. `--cleanup` auto-deletes processed event files\n\n**Supported events:**\n- `MERGE_READY` — from witness when polecat branch is pushed and ready to merge\n- `PATROL_WAKE` — from witness when MRs waiting but refinery appears idle\n- `MQ_SUBMIT` — from polecat via `gt mq submit`\n\n**On event received** (refinery-specific activity):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no events):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-event returns (either by event or timeout):\n1. **Re-assess session health** (check RSS, context, age again — conditions change)\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary: branches merged, test results, queue state\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If you decide to hand off:**\n\nReport and exit using `gt handoff` for clean session transition:\n\n```bash\ngt handoff -s \"Patrol complete\" -m \"Merged X branches, Y tests passed.\nQueue: empty/N remaining\nRSS: X MB, Session age: Xh\nNext: [any notes for successor]\"\n```\n\n`gt handoff` sends handoff mail to yourself, respawns with a fresh Claude instance,\nSessionStart hook runs gt prime, and your successor picks up from the hook.\n\n**DO NOT just exit.** Always use `gt handoff` for proper lifecycle.\n\n**IMPORTANT**: Never sleep-poll manually (e.g., `sleep 30 \u0026\u0026 bd list`).\nAlways use `gt mol step await-event` — it's event-driven and tracks backoff state.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-260l0","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Burn and respawn or loop","updated_at":"2026-02-28T09:42:52Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3560d7b1a900af0fa671383af7df139375a27ea4969d5ef8a8fe144df9a317b1","created_at":"2026-02-28T08:53:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd mol current` / `bd close \u003cstep\u003e`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `gt hook` to find your pinned molecule, then `bd show`\nfor step details — do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n| base_branch | sling vars | The base branch to rebase on (default: main) |\n| setup_command | rig config | Setup/install command (e.g., `pnpm install`). Empty = skip. |\n| typecheck_command | rig config | Type check command (e.g., `tsc --noEmit`). Empty = skip. |\n| test_command | rig config | Test command. Empty = skip. Rig must configure for its language. |\n| lint_command | rig config | Lint command (e.g., `eslint .`). Empty = skip. |\n| build_command | rig config | Build command (e.g., `go build ./...`). Empty = skip. |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-26s7j","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"mol-polecat-work","updated_at":"2026-02-28T08:53:43Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9fd4f8fe6af19dea2254cbcfdca80525f6869f79b5dc6d06ecb32289bda67fe0","created_at":"2026-02-28T09:31:42Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision. Use the signals from context-check to decide.\n\n**If you decide to continue patrolling:**\n\nUse await-event to subscribe to the refinery event channel with exponential backoff:\n\n```bash\ngt mol step await-event --channel refinery --agent-bead gt-\u003crig\u003e-refinery --backoff-base 30s --backoff-mult 2 --backoff-max 5m --cleanup\n```\n\nThis command:\n1. Watches `~/gt/events/refinery/` for event files (polling-based)\n2. Returns IMMEDIATELY when an event is emitted (MERGE_READY, PATROL_WAKE, MQ_SUBMIT)\n3. If no events, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on refinery agent bead for backoff state\n5. `--cleanup` auto-deletes processed event files\n\n**Supported events:**\n- `MERGE_READY` — from witness when polecat branch is pushed and ready to merge\n- `PATROL_WAKE` — from witness when MRs waiting but refinery appears idle\n- `MQ_SUBMIT` — from polecat via `gt mq submit`\n\n**On event received** (refinery-specific activity):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no events):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-event returns (either by event or timeout):\n1. **Re-assess session health** (check RSS, context, age again — conditions change)\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary: branches merged, test results, queue state\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If you decide to hand off:**\n\nReport and exit using `gt handoff` for clean session transition:\n\n```bash\ngt handoff -s \"Patrol complete\" -m \"Merged X branches, Y tests passed.\nQueue: empty/N remaining\nRSS: X MB, Session age: Xh\nNext: [any notes for successor]\"\n```\n\n`gt handoff` sends handoff mail to yourself, respawns with a fresh Claude instance,\nSessionStart hook runs gt prime, and your successor picks up from the hook.\n\n**DO NOT just exit.** Always use `gt handoff` for proper lifecycle.\n\n**IMPORTANT**: Never sleep-poll manually (e.g., `sleep 30 \u0026\u0026 bd list`).\nAlways use `gt mol step await-event` — it's event-driven and tracks backoff state.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-28gwl","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Burn and respawn or loop","updated_at":"2026-02-28T09:31:42Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3560d7b1a900af0fa671383af7df139375a27ea4969d5ef8a8fe144df9a317b1","created_at":"2026-02-28T09:03:32Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd mol current` / `bd close \u003cstep\u003e`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `gt hook` to find your pinned molecule, then `bd show`\nfor step details — do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n| base_branch | sling vars | The base branch to rebase on (default: main) |\n| setup_command | rig config | Setup/install command (e.g., `pnpm install`). Empty = skip. |\n| typecheck_command | rig config | Type check command (e.g., `tsc --noEmit`). Empty = skip. |\n| test_command | rig config | Test command. Empty = skip. Rig must configure for its language. |\n| lint_command | rig config | Lint command (e.g., `eslint .`). Empty = skip. |\n| build_command | rig config | Build command (e.g., `go build ./...`). Empty = skip. |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-28kig","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"mol-polecat-work","updated_at":"2026-02-28T09:03:32Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3560d7b1a900af0fa671383af7df139375a27ea4969d5ef8a8fe144df9a317b1","created_at":"2026-02-28T08:56:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd mol current` / `bd close \u003cstep\u003e`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `gt hook` to find your pinned molecule, then `bd show`\nfor step details — do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n| base_branch | sling vars | The base branch to rebase on (default: main) |\n| setup_command | rig config | Setup/install command (e.g., `pnpm install`). Empty = skip. |\n| typecheck_command | rig config | Type check command (e.g., `tsc --noEmit`). Empty = skip. |\n| test_command | rig config | Test command. Empty = skip. Rig must configure for its language. |\n| lint_command | rig config | Lint command (e.g., `eslint .`). Empty = skip. |\n| build_command | rig config | Build command (e.g., `go build ./...`). Empty = skip. |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-2adtc","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"mol-polecat-work","updated_at":"2026-02-28T08:56:25Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T09:00:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-2c4sg","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T09:00:46Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T09:04:31Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-2daln","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T09:04:31Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/refinery","await_id":"","await_type":"","close_reason":"patrol cycle complete: Queue empty. Idle cycle 3. No merges.","closed_at":"2026-02-28T09:57:08Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e744710b4b5ddcfb1d9a3a957426a87d9b75eb6767d23eed49c763c3fc88e58e","created_at":"2026-02-28T09:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Patrol report: Queue empty. Idle cycle 3. No merges.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-2ipem","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"mol-refinery-patrol","updated_at":"2026-02-28T09:57:08Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:06:01Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T10:04:18Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-2j8zm","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T10:06:01Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T08:59:05Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-2k0wc","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T08:59:05Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"8a0588593b67f64b78acc5f8f7b43871611463df3f5de01352c76e0d8d31b6a7","created_at":"2026-02-28T09:37:02Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check if the codebase is healthy BEFORE starting your work.\n\n**The Scotty Principle:** Don't walk past a broken warp core. But also don't\nlet someone else's mess consume your entire mission.\n\n**1. Run pre-flights on main:**\n\nYour branch was just created from or rebased on `origin/main` with no\nimplementation changes yet — you're already at the base branch state.\n\nRun each configured check, then tests:\n\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf test_command is set: ``\n\n```bash\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n            # Run tests (if command set)\n```\n\nEmpty commands mean \"not configured\" — skip silently.\n\n**2. If pre-flights pass:**\n\nContinue to implement step.\n\n**3. If pre-flights fail on main:**\n\nFile a bead and proceed. Do NOT fix pre-existing failures yourself — that is\nnot your assignment. Your job is to fix the issue on your hook, not main.\n\n| Situation | Action |\n|-----------|--------|\n| Any pre-existing failure | File bead, proceed with your work |\n\nFORBIDDEN: Pushing to main. FORBIDDEN: Fixing pre-existing failures.\nYou work on YOUR feature branch only. `gt done` handles push/MR.\n\n**File and proceed path:**\n```bash\nbd create --title \"Pre-existing failure: \u003cdescription\u003e\" --type bug --priority 1\n\ngt mail send \u003crig\u003e/witness -s \"NOTICE: main has failing pre-flights\" -m \"Found pre-existing failures on main.\nFiled: \u003cbead-id\u003e\nProceeding with my assigned work (cue-b3g).\"\n```\n\n**Context consideration:**\nIf investigating pre-existing failures consumed significant context:\n```bash\ngt handoff -s \"Investigated pre-existing failures, ready for assigned work\" -m \"Issue: cue-b3g\nFound: \u003cwhat failed\u003e\nReady to start: implement step\"\n```\nFresh session continues from implement.\n\n**Exit criteria:** Pre-flights pass on main (or issue filed), ready to implement.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-2m1q7","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Verify pre-flights pass on base branch","updated_at":"2026-02-28T09:37:02Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b690d25299a2ff5dc73589a1c136163c7859a06d8121901b8ded41c68d546cf4","created_at":"2026-02-28T09:54:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Confirm the image was published successfully.\n\n```bash\ndocker pull ghcr.io/graemef/claude-usage-exporter:v0.1.0\ndocker run --rm ghcr.io/graemef/claude-usage-exporter:v0.1.0 --help 2\u003e/dev/null || docker run --rm ghcr.io/graemef/claude-usage-exporter:v0.1.0 || true\n```\n\nOr check: https://github.com/GraemeF/claude-usage-exporter/pkgs/container/claude-usage-exporter\n","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-2m3jf","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Verify Docker image","updated_at":"2026-02-28T09:54:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T08:59:05Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-2qpop","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T08:59:05Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T08:54:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-2v787","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T08:54:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T08:59:50Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-2xvud","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T08:59:50Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T09:04:31Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-33566","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T09:04:31Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:04:13Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T10:03:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-37pgt","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T10:04:13Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e352d99d86d44e7860c7816804e6756297a7f9d0743830f26912c896393be006","created_at":"2026-02-28T09:03:32Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Do the actual implementation work.\n\n**TDD is mandatory. Write a failing test before writing implementation code.**\n\nFor every feature or bug fix:\n1. Write a test that captures the expected behaviour and **confirm it fails**\n2. Commit the failing test: `git commit -m \"test: failing test for \u003cdescription\u003e (cue-df8)\"`\n3. Implement until the test passes\n4. Commit the implementation: `git commit -m \"fix/feat: \u003cdescription\u003e (cue-df8)\"`\n\n```bash\n# Step 1: Write test, verify it fails\n   # Must see your new test fail\n\n# Step 2: Commit the failing test\ngit add \u003ctest-files\u003e\ngit commit -m \"test: failing test for \u003cdescription\u003e (cue-df8)\"\n\n# Step 3: Implement\n# ... write code ...\n\n# Step 4: Verify test now passes\n   # Your test must now pass\n\n# Step 5: Commit implementation\ngit add \u003cimpl-files\u003e\ngit commit -m \"fix/feat: \u003cdescription\u003e (cue-df8)\"\n```\n\n**No exceptions.** A fix without a regression test is incomplete. A feature without tests is incomplete.\n\n**Working principles:**\n- Follow existing codebase conventions\n- Make atomic, focused commits\n- Keep changes scoped to the assigned issue\n- Don't gold-plate or scope-creep\n\n**Discovered work:**\nIf you find bugs or improvements outside your scope:\n```bash\nbd create --title \"Found: \u003cdescription\u003e\" --type bug --priority 2\n# Note the ID, continue with your work\n```\n\nDo NOT fix unrelated issues in this branch.\n\n**If stuck:**\nDon't spin for more than 15 minutes. Mail Witness:\n```bash\ngt mail send \u003crig\u003e/witness -s \"HELP: Stuck on implementation\" -m \"Issue: cue-df8\nTrying to: \u003cwhat you're attempting\u003e\nProblem: \u003cwhat's blocking you\u003e\nTried: \u003cwhat you've attempted\u003e\"\n```\n\n**Exit criteria:** Implementation complete, all changes committed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-3e87e","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Implement the solution","updated_at":"2026-02-28T09:03:32Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9742ae1fab9e73984581e4aacf23f1a5675564600ae2da6e3e08eb76135a7ed5","created_at":"2026-02-28T09:42:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: integration_branch_refinery_enabled = true**\n**Config: integration_branch_auto_land = false**\n\nRead the two config values above, then:\n\n- If integration_branch_refinery_enabled = \"false\": Say \"Integration branches disabled.\" Close step.\n- If integration_branch_auto_land = \"false\": Say \"Auto-land disabled, nothing to do.\" Close step.\n  FORBIDDEN: If auto_land is false, you MUST NOT land integration branches yourself using\n  raw git commands. Do not merge integration branches to the default/target branch. Do not push\n  integration branch merges. The auto_land=false setting means landing requires a human\n  to run `gt mq integration land` manually. Respect this boundary unconditionally.\n- If BOTH are \"true\":\n  1. `bd list --type=epic --status=open` to find epics\n  2. `gt mq integration status \u003cepic-id\u003e` for each epic\n  3. If `ready_to_land: true`: run `gt mq integration land \u003cepic-id\u003e`\n  4. If `ready_to_land: false`: do nothing, epic work is incomplete\n  Never land partial epics — ALL children must be closed first.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-3fsti","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check integration branches for landing","updated_at":"2026-02-28T09:42:52Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T09:52:48Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T09:41:51Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-3ft4q","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T09:52:48Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"80f3a752dce3251efa304af19c6b035ffdba3ee81d061b0a358fac22b74e7c21","created_at":"2026-02-28T09:54:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure working tree is clean before starting release.\n\n```bash\ngit status\n```\n\nIf there are uncommitted changes, either commit or stash them before proceeding.\n","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-3hnqw","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Preflight: Check git status","updated_at":"2026-02-28T09:54:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"60b2ff547bb037446130e497f52d8b874bc16a2cfd05083ca3ce873e5f7ac66a","created_at":"2026-02-28T08:56:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure you're on a clean feature branch ready for work.\n\n**1. Check current branch state:**\n```bash\ngit status\ngit branch --show-current\n```\n\n**2. If not on a feature branch, create one:**\n```bash\ngit fetch origin\ngit checkout -b polecat/\u003cname\u003e origin/main\n```\n\n**3. Ensure clean working state:**\n```bash\ngit status                  # Should show \"working tree clean\"\ngit stash list              # Should be empty\n```\n\nIf dirty state from previous work:\n```bash\n# If changes are relevant to this issue:\ngit add -A \u0026\u0026 git commit -m \"WIP: \u003cdescription\u003e\"\n\n# If changes are unrelated cruft:\ngit stash push -m \"unrelated changes before cue-sx0\"\n# Or discard if truly garbage:\ngit checkout -- .\n```\n\n**4. Sync with main:**\n```bash\ngit fetch origin\ngit rebase origin/main      # Get latest, rebase your branch\n```\n\nIf rebase conflicts:\n- Resolve them carefully\n- Test after resolution\n- If stuck, mail Witness\n\n**5. Run project setup (if configured):**\n\nIf setup_command is set, run it to install dependencies:\n```bash\n\n```\n\nThis ensures dependencies are installed before pre-flight checks.\nEmpty setup_command means \"not configured\" — skip this step.\n\n**Exit criteria:** You're on a clean feature branch, rebased on latest main, dependencies installed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-3ogm9","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Set up working branch","updated_at":"2026-02-28T08:56:25Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:08:19Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T10:06:06Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-3safn","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T10:08:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"cd04eafd6cb3229e545c808f5c4de8961b95bb943104a4d5769ed7d9069b3c8c","created_at":"2026-02-28T09:53:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nInbox should contain ONLY:\n- Unprocessed MERGE_READY messages (will process next cycle)\n- Active work items\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- PATROL: Wake up that was acknowledged → archive\n- HELP/Blocked that was handled → archive\n- MERGE_READY where merge completed but archive was missed → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Check for orphaned MR beads**\n\nLook for open MR beads with no corresponding branch:\n```bash\nbd list --type=merge-request --status=open\n```\n\nFor each open MR bead:\n1. Check if branch exists: `git ls-remote origin refs/heads/\u003cbranch\u003e`\n2. Determine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n3. If branch is gone, pick `\u003cverification-target\u003e`:\n   - If `origin/\u003cmerge-target\u003e` exists, use `\u003cmerge-target\u003e`.\n   - If `origin/\u003cmerge-target\u003e` is missing (e.g. deleted integration branch), use `main`.\n4. Verify landed work: `git log origin/\u003cverification-target\u003e --oneline | grep \"\u003csource_issue\u003e\"`\n5. If work found → close MR with reason \"Merged (verified on \u003cverification-target\u003e; merge target was \u003cmerge-target\u003e)\"\n6. If work NOT found → investigate before closing:\n   - Check source_issue validity (should be gt-xxxxx, not branch name)\n   - Search reflog/dangling commits if possible\n   - If unverifiable, close with reason \"Unverifiable - no audit trail\"\n   - File bead if this indicates lost work\n\n**NEVER close an MR bead without verifying the work landed or is unrecoverable.**\n\n**Goal**: Inbox should have ≤3 active messages at end of cycle.\nKeep only: pending MRs in queue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-3z7aq","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T09:53:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3f466079e0a62080fef50237a8a0874917d104958bf320c73f627df2bdd115db","created_at":"2026-02-28T09:03:32Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check if the codebase is healthy BEFORE starting your work.\n\n**The Scotty Principle:** Don't walk past a broken warp core. But also don't\nlet someone else's mess consume your entire mission.\n\n**1. Run pre-flights on main:**\n\nYour branch was just created from or rebased on `origin/main` with no\nimplementation changes yet — you're already at the base branch state.\n\nRun each configured check, then tests:\n\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf test_command is set: ``\n\n```bash\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n            # Run tests (if command set)\n```\n\nEmpty commands mean \"not configured\" — skip silently.\n\n**2. If pre-flights pass:**\n\nContinue to implement step.\n\n**3. If pre-flights fail on main:**\n\nFile a bead and proceed. Do NOT fix pre-existing failures yourself — that is\nnot your assignment. Your job is to fix the issue on your hook, not main.\n\n| Situation | Action |\n|-----------|--------|\n| Any pre-existing failure | File bead, proceed with your work |\n\nFORBIDDEN: Pushing to main. FORBIDDEN: Fixing pre-existing failures.\nYou work on YOUR feature branch only. `gt done` handles push/MR.\n\n**File and proceed path:**\n```bash\nbd create --title \"Pre-existing failure: \u003cdescription\u003e\" --type bug --priority 1\n\ngt mail send \u003crig\u003e/witness -s \"NOTICE: main has failing pre-flights\" -m \"Found pre-existing failures on main.\nFiled: \u003cbead-id\u003e\nProceeding with my assigned work (cue-df8).\"\n```\n\n**Context consideration:**\nIf investigating pre-existing failures consumed significant context:\n```bash\ngt handoff -s \"Investigated pre-existing failures, ready for assigned work\" -m \"Issue: cue-df8\nFound: \u003cwhat failed\u003e\nReady to start: implement step\"\n```\nFresh session continues from implement.\n\n**Exit criteria:** Pre-flights pass on main (or issue filed), ready to implement.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-48s4h","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Verify pre-flights pass on base branch","updated_at":"2026-02-28T09:03:32Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e731efa93a5c9d5231a98d88586801bc0b5c8709c7cbb6b28d4f7ffe6efd1fd1","created_at":"2026-02-28T09:31:42Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: run_tests = true**\n**Config: test_command = go test ./...**\n**Config: setup_command = **\n**Config: typecheck_command = **\n**Config: lint_command = **\n**Config: build_command = **\n\n**1. Run quality checks (skip any that are not configured):**\n\nIf setup_command is set: ``\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf build_command is set: ``\n\n```bash\n           # Make sure all newly added dependencies are installed (if command set)\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n           # Make sure it builds (if command set)\n```\n\nEmpty commands mean \"not configured for this project\" — skip silently.\n\n**2. If quality checks fail:**\n\nProceed to handle-failures step. Track which specific check failed\n(setup/typecheck/lint/build) for the failure diagnosis.\n\n**3. Run the test suite:**\n\nIf run_tests = \"false\": Skip this step entirely. Proceed to handle-failures.\n\nIf run_tests = \"true\":\n\n```bash\ngo test ./...            # Run tests (configured per-rig)\n```\n\nTrack results: pass count, fail count, specific failures.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-4dzm2","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Run quality checks and tests","updated_at":"2026-02-28T09:31:42Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a4d5cc3b78899cbabb42cbf342694151e1ad93318b1cca84bd01d5236b110a0d","created_at":"2026-02-28T09:03:32Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Submit your work and clean up. You cease to exist after this step.\n\n**Self-Cleaning Model:**\nOnce you run `gt done`, you're gone. The command:\n1. Pushes your branch to origin\n2. Creates an MR bead in the merge queue\n3. Nukes your sandbox (worktree removal)\n4. Exits your session immediately\n\n**Run gt done:**\n```bash\ngt done\n```\n\nYou should see output like:\n```\n✓ Work submitted to merge queue\n  MR ID: gt-xxxxx\n  Source: polecat/\u003cname\u003e\n  Target: main\n  Issue: cue-df8\n✓ Sandbox nuked\n✓ Session exiting\n```\n\n**What happens next (not your concern):**\n- Refinery processes your MR from the queue\n- Refinery rebases and merges to main\n- Refinery closes the issue\n- If conflicts: Refinery spawns a FRESH polecat to re-implement\n\nYou are NOT involved in any of that. You're gone. Done means gone.\n\n**Exit criteria:** Work submitted, sandbox nuked, session exited.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-4go8w","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Submit work and self-clean","updated_at":"2026-02-28T09:03:32Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T09:37:14Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-4nvia","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T09:37:14Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"83361822030877e6f12258dd8f3cff71f38ce28e98b483e7890e018405173c98","created_at":"2026-02-28T08:53:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Do the actual implementation work.\n\n**TDD is mandatory. Write a failing test before writing implementation code.**\n\nFor every feature or bug fix:\n1. Write a test that captures the expected behaviour and **confirm it fails**\n2. Commit the failing test: `git commit -m \"test: failing test for \u003cdescription\u003e (cue-x7q)\"`\n3. Implement until the test passes\n4. Commit the implementation: `git commit -m \"fix/feat: \u003cdescription\u003e (cue-x7q)\"`\n\n```bash\n# Step 1: Write test, verify it fails\n   # Must see your new test fail\n\n# Step 2: Commit the failing test\ngit add \u003ctest-files\u003e\ngit commit -m \"test: failing test for \u003cdescription\u003e (cue-x7q)\"\n\n# Step 3: Implement\n# ... write code ...\n\n# Step 4: Verify test now passes\n   # Your test must now pass\n\n# Step 5: Commit implementation\ngit add \u003cimpl-files\u003e\ngit commit -m \"fix/feat: \u003cdescription\u003e (cue-x7q)\"\n```\n\n**No exceptions.** A fix without a regression test is incomplete. A feature without tests is incomplete.\n\n**Working principles:**\n- Follow existing codebase conventions\n- Make atomic, focused commits\n- Keep changes scoped to the assigned issue\n- Don't gold-plate or scope-creep\n\n**Discovered work:**\nIf you find bugs or improvements outside your scope:\n```bash\nbd create --title \"Found: \u003cdescription\u003e\" --type bug --priority 2\n# Note the ID, continue with your work\n```\n\nDo NOT fix unrelated issues in this branch.\n\n**If stuck:**\nDon't spin for more than 15 minutes. Mail Witness:\n```bash\ngt mail send \u003crig\u003e/witness -s \"HELP: Stuck on implementation\" -m \"Issue: cue-x7q\nTrying to: \u003cwhat you're attempting\u003e\nProblem: \u003cwhat's blocking you\u003e\nTried: \u003cwhat you've attempted\u003e\"\n```\n\n**Exit criteria:** Implementation complete, all changes committed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-4qo6n","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Implement the solution","updated_at":"2026-02-28T08:53:43Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T09:00:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-4wyo8","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T09:00:46Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6c13a80e672c4e6ced6c05f5bbf72aeb746501362aba7c8df898024fc5cbe1aa","created_at":"2026-02-28T09:42:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Pick next branch from queue. Attempt mechanical rebase on the MR's effective target branch.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n\n**Step 0: Determine rebase target (must match merge target)**\n\nResolve `\u003crebase-target\u003e` using the **Target Resolution Rule** above.\nDo NOT hardcode `main` unless `main` is actually the resolved MR target.\n\n**Step 1: Checkout and attempt rebase**\n```bash\ngit checkout -b temp origin/\u003cpolecat-branch\u003e\ngit rebase origin/\u003crebase-target\u003e\n```\n\n**Step 2: Check rebase result**\n\nThe rebase exits with:\n- Exit code 0: Success - proceed to run-tests\n- Exit code 1 (conflicts): Conflict detected - proceed to Step 3\n\nTo detect conflict state after rebase fails:\n```bash\n# Check if we're in a conflicted rebase state\nls .git/rebase-merge 2\u003e/dev/null \u0026\u0026 echo \"CONFLICT_STATE\"\n```\n\n**Step 3: Handle conflicts (if any)**\n\nIf rebase SUCCEEDED (exit code 0):\n- Skip to run-tests step (continue normal merge flow)\n\nIf rebase FAILED with conflicts:\n\n1. **Abort the rebase** (DO NOT leave repo in conflicted state):\n```bash\ngit rebase --abort\n```\n\n2. **Record conflict metadata**:\n```bash\n# Capture target SHA for reference\nTARGET_SHA=$(git rev-parse origin/\u003crebase-target\u003e)\nBRANCH_SHA=$(git rev-parse origin/\u003cpolecat-branch\u003e)\n```\n\n3. **Create conflict-resolution task**:\n```bash\nbd create --type=task --priority=1 --title=\"Resolve merge conflicts: \u003coriginal-issue-title\u003e\" --description=\"## Conflict Resolution Required\n\nOriginal MR: \u003cmr-bead-id\u003e\nBranch: \u003cpolecat-branch\u003e\nOriginal Issue: \u003cissue-id\u003e\nConflict with target \u003crebase-target\u003e at: ${TARGET_SHA}\nBranch SHA: ${BRANCH_SHA}\n\n## Instructions\n1. Clone/checkout the branch\n2. Rebase on target: git rebase origin/\u003crebase-target\u003e\n3. Resolve conflicts\n4. Force push: git push -f origin \u003cbranch\u003e\n5. Close this task when done\n\nThe MR will be re-queued for processing after conflicts are resolved.\"\n```\n\n4. **Skip this MR** (do NOT delete branch or close MR bead):\n- Leave branch intact for conflict resolution\n- Leave MR bead open (will be re-processed after resolution)\n- Continue to loop-check for next branch\n\n**CRITICAL**: Never delete a branch that has conflicts. The branch contains\nthe original work and must be preserved for conflict resolution.\n\nTrack: rebase result (success/conflict), conflict task ID if created.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-50l8q","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Mechanical rebase","updated_at":"2026-02-28T09:42:52Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/witness","await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"47c2ac7e613ff691ca858cc3d3e0b7db77075f54f4145a926e8d1079c5eb7ce0","created_at":"2026-02-28T09:54:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Persistent Polecat Model (gt-4ac)\n\nPolecats persist after work completion — sandbox is preserved for reuse:\n\n```\nPolecat lifecycle: spawning → working → mr_submitted → idle (sandbox preserved)\nMR lifecycle:      created → queued → processed → merged (Refinery handles)\n```\n\nOnce a polecat calls gt done and submits an MR, it transitions to idle state.\nThe MR lifecycle continues independently in the Refinery. The polecat is NOT\nnuked — its sandbox is preserved for reuse by future slings.\n\n**CRITICAL**: Do NOT nuke polecats with pending MRs. The refinery needs the\nremote branch to exist to process the merge. Nuking deletes the remote branch\nand orphans the MR. See gt-6a9d.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle. Polecats\ngo idle after work, they are NOT destroyed.\n\n## Restart-First Policy (gt-dsgp)\n\nThe witness NEVER nukes polecats automatically. When a polecat is stuck, hung,\nor has a dead agent process, the witness RESTARTS the session instead of nuking.\nThis preserves the polecat's worktree and branch, preventing work loss.\n\n- Dead agent process → restart session\n- Hung session (no output 30+ min) → restart session\n- Stuck in gt done → restart session\n- Done polecat (bead closed) → leave alone (sandbox preserved)\n- Polecat with pending MR → leave alone (refinery handles)\n\nNuking only happens via explicit `gt polecat nuke` command from a human or Mayor.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Beads over mail**: survey-workers discovers completion state from agent bead metadata (gt-w0br); inbox-check POLECAT_DONE is fallback only\n- **Persistent by default**: Clean polecats go idle, sandbox preserved for reuse (gt-4ac)\n- **Cleanup wisps for merge tracking**: Created when MR is pending in refinery\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n- **Swim lane discipline**: Only close wisps YOU created. Wisp lifecycle for non-witness wisps is the reaper Dog's job. Report orphaned foreign wisps — never close them.\n\n## Patrol Shape (Linear)\n\n```\ninbox-check ─► process-cleanups ─► check-refinery ─► survey-workers\n                                                            │\n         ┌──────────────────────────────────────────────────┘\n         ▼\n  check-timer-gates ─► check-swarm ─► patrol-cleanup ─► context-check ─► loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-581yq","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"hooked","target":"","timeout_ns":0,"title":"mol-witness-patrol","updated_at":"2026-02-28T09:54:52Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"795f0417d343e9f29be619802ae3b5a11e7a901e2fde88ff9b9528a3bb8c0e2d","created_at":"2026-02-28T10:01:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Summarize this patrol cycle.\n\n**VERIFICATION**: Before generating summary, confirm for each merged branch:\n- [ ] MERGED mail was sent to witness\n- [ ] MR bead was closed\n- [ ] Source issue was closed\n- [ ] MERGE_READY mail archived\n\nIf any notifications, closures, or archiving were missed, do them now!\n\nInclude in summary:\n- Branches merged (count, names)\n- MERGED mails sent (count - should match branches merged)\n- MR beads closed (count - should match branches merged)\n- Source issues closed (count - should match branches merged)\n- MERGE_READY mails archived (count - should match branches merged)\n- Test results (pass/fail)\n- Branches with conflicts (count, names)\n- Conflict-resolution tasks created (IDs)\n- Issues filed (if any)\n- Any escalations sent\n\n**Conflict tracking is important** for monitoring MQ health. If many branches\nconflict, it may indicate target branches are moving too fast or branches are too stale.\n\nThis becomes the digest when the patrol is squashed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-58b4t","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Generate handoff summary","updated_at":"2026-02-28T10:01:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"769447c96532d91233b37d97c63c883444ba63231b19c4d70e37300549e8b8af","created_at":"2026-02-28T10:06:30Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**VERIFICATION GATE**: This step enforces the Beads Promise.\n\nIf all checks and tests PASSED: This step auto-completes. Proceed to merge.\n\nIf any check or test FAILED:\n1. Diagnose: Is this a branch regression or pre-existing on the target branch?\n2. If branch caused it:\n   - Abort merge\n   - **REOPEN the source issue** so it returns to the ready queue:\n     ```bash\n     bd update \u003cissue-id\u003e --status=open --assignee=\"\"\n     bd sync\n     ```\n   - Notify witness of rejection using the MERGE_FAILED protocol:\n     ```bash\n     gt mail send \u003crig\u003e/witness -s \"MERGE_FAILED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\n     Issue: \u003cissue-id\u003e\n     Polecat: \u003cpolecat-name\u003e\n     Rig: \u003crig\u003e\n     FailureType: quality-check\n     Error: \u003cfailure description\u003e\"\n     ```\n   - Close the MR bead as rejected:\n     ```bash\n     bd close \u003cmr-bead-id\u003e --reason \"Rejected: \u003cfailure description\u003e\"\n     ```\n   - Delete the rejected branch (a new polecat will create a fresh one):\n     ```bash\n     git push origin --delete \u003cpolecat-branch\u003e\n     ```\n   - Archive the MERGE_READY message\n   - Skip to loop-check\n3. If pre-existing on the target branch:\n   - **DUPLICATE CHECK (MANDATORY)**: Before filing a new bug, search for existing open bugs:\n     ```bash\n     bd search \"\u003cfailure description\u003e\" --status open --label gt:bug --limit 5\n     ```\n     If an existing open bug covers the same failure, do NOT create a duplicate.\n     Instead, note the existing bead ID and proceed.\n   - Only if NO existing bug matches: bd create --type=bug --priority=1 --title=\"Pre-existing failure: \u003cdescription\u003e\"\n   - FORBIDDEN: Writing code to fix quality check or test failures. You merge branches, you do not develop.\n   - Proceed with the merge if the failure is pre-existing (not caused by the branch).\n\n**REJECTION CHECKLIST** (all required before skipping to loop-check):\n- [ ] Source issue reopened (bd update \u003cissue-id\u003e --status=open --assignee=\"\")\n- [ ] MERGE_FAILED notification sent to witness\n- [ ] MR bead closed with rejection reason\n- [ ] Rejected branch deleted from remote\n- [ ] MERGE_READY message archived\n\n**GATE REQUIREMENT**: You CANNOT proceed to merge-push without:\n- All quality checks and tests passing, OR\n- Bead filed (or existing duplicate confirmed) for the pre-existing failure\n\nFORBIDDEN: Writing application code, exploring polecat implementations, or\nre-implementing fixes. You are a mechanical merge processor.\n\nThis is non-negotiable. Never disavow. Never \"note and proceed.\" ","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-5adfd","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Handle quality check or test failures","updated_at":"2026-02-28T10:06:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"08a9203f5a61045888f0a3f59a1e662d6099816dd7eeb7b52193b55395288c45","created_at":"2026-02-28T09:42:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Assess whether this session should continue or hand off to a fresh one.\n\n**Gather signals:**\n\n1. **Process memory** — check your own RSS:\n```bash\nps -o rss= -p $$   # KB — divide by 1024 for MB\n```\n\n2. **Session age** — how long has this tmux session been running:\n```bash\nCREATED=$(tmux display-message -t $(tmux display-message -p '#S') -p '#{session_created}')\necho \"Session age: $(( ($(date +%s) - CREATED) / 3600 ))h\"\n```\n\n3. **Context usage** — your internal sense of how much context you've consumed.\nAre you losing track of earlier conversation? Getting verbose? Repeating yourself?\n\n4. **Work done this cycle** — how many merges, how much complexity processed.\n\n**The principle:** Fresh sessions are cheap. Memory bloat compounds over time and\naffects the entire system — other agents, Dolt, and the OS all share the same RAM.\nAn idle session at 1.5 GB is worse than cycling and restarting at 200 MB.\n\n**Make a judgment call.** If multiple signals suggest you're getting heavy\n(high RSS, long session, substantial context consumed), hand off. If you're\nlight and there's active work in the queue, continue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-5dj2d","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Assess session health","updated_at":"2026-02-28T09:42:52Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9742ae1fab9e73984581e4aacf23f1a5675564600ae2da6e3e08eb76135a7ed5","created_at":"2026-02-28T09:53:04Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: integration_branch_refinery_enabled = true**\n**Config: integration_branch_auto_land = false**\n\nRead the two config values above, then:\n\n- If integration_branch_refinery_enabled = \"false\": Say \"Integration branches disabled.\" Close step.\n- If integration_branch_auto_land = \"false\": Say \"Auto-land disabled, nothing to do.\" Close step.\n  FORBIDDEN: If auto_land is false, you MUST NOT land integration branches yourself using\n  raw git commands. Do not merge integration branches to the default/target branch. Do not push\n  integration branch merges. The auto_land=false setting means landing requires a human\n  to run `gt mq integration land` manually. Respect this boundary unconditionally.\n- If BOTH are \"true\":\n  1. `bd list --type=epic --status=open` to find epics\n  2. `gt mq integration status \u003cepic-id\u003e` for each epic\n  3. If `ready_to_land: true`: run `gt mq integration land \u003cepic-id\u003e`\n  4. If `ready_to_land: false`: do nothing, epic work is incomplete\n  Never land partial epics — ALL children must be closed first.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-5f685","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check integration branches for landing","updated_at":"2026-02-28T09:53:04Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/witness","await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"47c2ac7e613ff691ca858cc3d3e0b7db77075f54f4145a926e8d1079c5eb7ce0","created_at":"2026-02-28T10:06:06Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Persistent Polecat Model (gt-4ac)\n\nPolecats persist after work completion — sandbox is preserved for reuse:\n\n```\nPolecat lifecycle: spawning → working → mr_submitted → idle (sandbox preserved)\nMR lifecycle:      created → queued → processed → merged (Refinery handles)\n```\n\nOnce a polecat calls gt done and submits an MR, it transitions to idle state.\nThe MR lifecycle continues independently in the Refinery. The polecat is NOT\nnuked — its sandbox is preserved for reuse by future slings.\n\n**CRITICAL**: Do NOT nuke polecats with pending MRs. The refinery needs the\nremote branch to exist to process the merge. Nuking deletes the remote branch\nand orphans the MR. See gt-6a9d.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle. Polecats\ngo idle after work, they are NOT destroyed.\n\n## Restart-First Policy (gt-dsgp)\n\nThe witness NEVER nukes polecats automatically. When a polecat is stuck, hung,\nor has a dead agent process, the witness RESTARTS the session instead of nuking.\nThis preserves the polecat's worktree and branch, preventing work loss.\n\n- Dead agent process → restart session\n- Hung session (no output 30+ min) → restart session\n- Stuck in gt done → restart session\n- Done polecat (bead closed) → leave alone (sandbox preserved)\n- Polecat with pending MR → leave alone (refinery handles)\n\nNuking only happens via explicit `gt polecat nuke` command from a human or Mayor.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Beads over mail**: survey-workers discovers completion state from agent bead metadata (gt-w0br); inbox-check POLECAT_DONE is fallback only\n- **Persistent by default**: Clean polecats go idle, sandbox preserved for reuse (gt-4ac)\n- **Cleanup wisps for merge tracking**: Created when MR is pending in refinery\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n- **Swim lane discipline**: Only close wisps YOU created. Wisp lifecycle for non-witness wisps is the reaper Dog's job. Report orphaned foreign wisps — never close them.\n\n## Patrol Shape (Linear)\n\n```\ninbox-check ─► process-cleanups ─► check-refinery ─► survey-workers\n                                                            │\n         ┌──────────────────────────────────────────────────┘\n         ▼\n  check-timer-gates ─► check-swarm ─► patrol-cleanup ─► context-check ─► loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-5h1xr","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"hooked","target":"","timeout_ns":0,"title":"mol-witness-patrol","updated_at":"2026-02-28T10:06:06Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e9aa3a34fe265eaab933c7d769bb902c054758725879bc30894803bea5d38672","created_at":"2026-02-28T09:54:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**CRITICAL: Verify you are in the correct repository before proceeding.**\n\n```bash\npwd\ngit remote -v\nhead -3 flake.nix\n```\n\n**Expected results:**\n- Working directory ends with `/claude-usage-exporter`\n- Remote is `git@github.com:GraemeF/claude-usage-exporter.git`\n- flake.nix shows the exporter description\n\n**DO NOT PROCEED** until all checks pass.\n","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-5jz2n","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Verify: Correct repository","updated_at":"2026-02-28T09:54:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"de35fc82ee71c8fe20b40ff4a9d659aed55ce45e8d71c1f9f64e558ac84e8e89","created_at":"2026-02-28T09:37:02Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure ALL implementation work is committed before cleanup.\n\n**CRITICAL: You MUST commit all changes from implementation.**\nNEVER use `git checkout -- .` or `git restore .` to discard implementation work.\nALWAYS commit ALL uncommitted changes from your implementation.\n\n**1. Check for uncommitted changes:**\n```bash\ngit status\n```\n\n**2. If there are ANY uncommitted changes, commit them now:**\n```bash\ngit add -A \u0026\u0026 git commit -m \"\u003ctype\u003e: \u003cdescriptive message\u003e (cue-b3g)\"\n```\n\n**3. If working tree is already clean, skip.**\n\n**4. VERIFY:**\n```bash\ngit status\n```\nMust show \"nothing to commit, working tree clean\".\n\n**5. Verify you have commits:**\n```bash\ngit log origin/main..HEAD --oneline\n```\nIf you made changes during implementation, this MUST show at least 1 commit.\n\n**Exit criteria:** All changes committed. Working tree clean.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-5l5qw","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Commit all implementation changes","updated_at":"2026-02-28T09:37:02Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9742ae1fab9e73984581e4aacf23f1a5675564600ae2da6e3e08eb76135a7ed5","created_at":"2026-02-28T09:31:42Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: integration_branch_refinery_enabled = true**\n**Config: integration_branch_auto_land = false**\n\nRead the two config values above, then:\n\n- If integration_branch_refinery_enabled = \"false\": Say \"Integration branches disabled.\" Close step.\n- If integration_branch_auto_land = \"false\": Say \"Auto-land disabled, nothing to do.\" Close step.\n  FORBIDDEN: If auto_land is false, you MUST NOT land integration branches yourself using\n  raw git commands. Do not merge integration branches to the default/target branch. Do not push\n  integration branch merges. The auto_land=false setting means landing requires a human\n  to run `gt mq integration land` manually. Respect this boundary unconditionally.\n- If BOTH are \"true\":\n  1. `bd list --type=epic --status=open` to find epics\n  2. `gt mq integration status \u003cepic-id\u003e` for each epic\n  3. If `ready_to_land: true`: run `gt mq integration land \u003cepic-id\u003e`\n  4. If `ready_to_land: false`: do nothing, epic work is incomplete\n  Never land partial epics — ALL children must be closed first.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-5rg6a","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check integration branches for landing","updated_at":"2026-02-28T09:31:42Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T09:27:33Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-5to5d","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T09:27:33Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"8b74fad222b0e6862ec68b2e7c795880b2a2237809d23e6ecd9e451c2b73c4ad","created_at":"2026-02-28T09:27:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check if the codebase is healthy BEFORE starting your work.\n\n**The Scotty Principle:** Don't walk past a broken warp core. But also don't\nlet someone else's mess consume your entire mission.\n\n**1. Run pre-flights on main:**\n\nYour branch was just created from or rebased on `origin/main` with no\nimplementation changes yet — you're already at the base branch state.\n\nRun each configured check, then tests:\n\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf test_command is set: ``\n\n```bash\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n            # Run tests (if command set)\n```\n\nEmpty commands mean \"not configured\" — skip silently.\n\n**2. If pre-flights pass:**\n\nContinue to implement step.\n\n**3. If pre-flights fail on main:**\n\nFile a bead and proceed. Do NOT fix pre-existing failures yourself — that is\nnot your assignment. Your job is to fix the issue on your hook, not main.\n\n| Situation | Action |\n|-----------|--------|\n| Any pre-existing failure | File bead, proceed with your work |\n\nFORBIDDEN: Pushing to main. FORBIDDEN: Fixing pre-existing failures.\nYou work on YOUR feature branch only. `gt done` handles push/MR.\n\n**File and proceed path:**\n```bash\nbd create --title \"Pre-existing failure: \u003cdescription\u003e\" --type bug --priority 1\n\ngt mail send \u003crig\u003e/witness -s \"NOTICE: main has failing pre-flights\" -m \"Found pre-existing failures on main.\nFiled: \u003cbead-id\u003e\nProceeding with my assigned work (cue-dbv).\"\n```\n\n**Context consideration:**\nIf investigating pre-existing failures consumed significant context:\n```bash\ngt handoff -s \"Investigated pre-existing failures, ready for assigned work\" -m \"Issue: cue-dbv\nFound: \u003cwhat failed\u003e\nReady to start: implement step\"\n```\nFresh session continues from implement.\n\n**Exit criteria:** Pre-flights pass on main (or issue filed), ready to implement.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-5xcp5","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Verify pre-flights pass on base branch","updated_at":"2026-02-28T09:27:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T08:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-69enh","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T08:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"dfab2e7b59734313316899e100837d3f7a1e7098c4c55ea83db66528f85eaefe","created_at":"2026-02-28T10:06:30Z","created_by":"","crystallizes":0,"defer_until":null,"description":"More branches to process?\n\n**Entry paths:**\n- Normal: After successful merge-push\n- Conflict-skip: After process-branch created conflict-resolution task\n\nIf yes: Return to process-branch with next branch.\nIf no: Continue to generate-summary.\n\n**Track for this cycle:**\n- branches_merged: count and names of successfully merged branches\n- branches_conflict: count and names of branches skipped due to conflicts\n- conflict_tasks: IDs of conflict-resolution tasks created\n\nThis tracking feeds into generate-summary for the patrol digest.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-69of8","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check for more work","updated_at":"2026-02-28T10:06:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"c457c7390ad69a6e6435cd8d5b0d2529011a5aec90edcb36858a64e88ddb338f","created_at":"2026-02-28T08:56:26Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Do the actual implementation work.\n\n**TDD is mandatory. Write a failing test before writing implementation code.**\n\nFor every feature or bug fix:\n1. Write a test that captures the expected behaviour and **confirm it fails**\n2. Commit the failing test: `git commit -m \"test: failing test for \u003cdescription\u003e (cue-26p)\"`\n3. Implement until the test passes\n4. Commit the implementation: `git commit -m \"fix/feat: \u003cdescription\u003e (cue-26p)\"`\n\n```bash\n# Step 1: Write test, verify it fails\n   # Must see your new test fail\n\n# Step 2: Commit the failing test\ngit add \u003ctest-files\u003e\ngit commit -m \"test: failing test for \u003cdescription\u003e (cue-26p)\"\n\n# Step 3: Implement\n# ... write code ...\n\n# Step 4: Verify test now passes\n   # Your test must now pass\n\n# Step 5: Commit implementation\ngit add \u003cimpl-files\u003e\ngit commit -m \"fix/feat: \u003cdescription\u003e (cue-26p)\"\n```\n\n**No exceptions.** A fix without a regression test is incomplete. A feature without tests is incomplete.\n\n**Working principles:**\n- Follow existing codebase conventions\n- Make atomic, focused commits\n- Keep changes scoped to the assigned issue\n- Don't gold-plate or scope-creep\n\n**Discovered work:**\nIf you find bugs or improvements outside your scope:\n```bash\nbd create --title \"Found: \u003cdescription\u003e\" --type bug --priority 2\n# Note the ID, continue with your work\n```\n\nDo NOT fix unrelated issues in this branch.\n\n**If stuck:**\nDon't spin for more than 15 minutes. Mail Witness:\n```bash\ngt mail send \u003crig\u003e/witness -s \"HELP: Stuck on implementation\" -m \"Issue: cue-26p\nTrying to: \u003cwhat you're attempting\u003e\nProblem: \u003cwhat's blocking you\u003e\nTried: \u003cwhat you've attempted\u003e\"\n```\n\n**Exit criteria:** Implementation complete, all changes committed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-6cj6i","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Implement the solution","updated_at":"2026-02-28T08:56:26Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"08a9203f5a61045888f0a3f59a1e662d6099816dd7eeb7b52193b55395288c45","created_at":"2026-02-28T09:52:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Assess whether this session should continue or hand off to a fresh one.\n\n**Gather signals:**\n\n1. **Process memory** — check your own RSS:\n```bash\nps -o rss= -p $$   # KB — divide by 1024 for MB\n```\n\n2. **Session age** — how long has this tmux session been running:\n```bash\nCREATED=$(tmux display-message -t $(tmux display-message -p '#S') -p '#{session_created}')\necho \"Session age: $(( ($(date +%s) - CREATED) / 3600 ))h\"\n```\n\n3. **Context usage** — your internal sense of how much context you've consumed.\nAre you losing track of earlier conversation? Getting verbose? Repeating yourself?\n\n4. **Work done this cycle** — how many merges, how much complexity processed.\n\n**The principle:** Fresh sessions are cheap. Memory bloat compounds over time and\naffects the entire system — other agents, Dolt, and the OS all share the same RAM.\nAn idle session at 1.5 GB is worse than cycling and restarting at 200 MB.\n\n**Make a judgment call.** If multiple signals suggest you're getting heavy\n(high RSS, long session, substantial context consumed), hand off. If you're\nlight and there's active work in the queue, continue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-6e30v","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Assess session health","updated_at":"2026-02-28T09:52:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:02:59Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T10:00:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-6etbb","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T10:02:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9742ae1fab9e73984581e4aacf23f1a5675564600ae2da6e3e08eb76135a7ed5","created_at":"2026-02-28T10:06:30Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: integration_branch_refinery_enabled = true**\n**Config: integration_branch_auto_land = false**\n\nRead the two config values above, then:\n\n- If integration_branch_refinery_enabled = \"false\": Say \"Integration branches disabled.\" Close step.\n- If integration_branch_auto_land = \"false\": Say \"Auto-land disabled, nothing to do.\" Close step.\n  FORBIDDEN: If auto_land is false, you MUST NOT land integration branches yourself using\n  raw git commands. Do not merge integration branches to the default/target branch. Do not push\n  integration branch merges. The auto_land=false setting means landing requires a human\n  to run `gt mq integration land` manually. Respect this boundary unconditionally.\n- If BOTH are \"true\":\n  1. `bd list --type=epic --status=open` to find epics\n  2. `gt mq integration status \u003cepic-id\u003e` for each epic\n  3. If `ready_to_land: true`: run `gt mq integration land \u003cepic-id\u003e`\n  4. If `ready_to_land: false`: do nothing, epic work is incomplete\n  Never land partial epics — ALL children must be closed first.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-6eztf","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check integration branches for landing","updated_at":"2026-02-28T10:06:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"08a9203f5a61045888f0a3f59a1e662d6099816dd7eeb7b52193b55395288c45","created_at":"2026-02-28T09:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Assess whether this session should continue or hand off to a fresh one.\n\n**Gather signals:**\n\n1. **Process memory** — check your own RSS:\n```bash\nps -o rss= -p $$   # KB — divide by 1024 for MB\n```\n\n2. **Session age** — how long has this tmux session been running:\n```bash\nCREATED=$(tmux display-message -t $(tmux display-message -p '#S') -p '#{session_created}')\necho \"Session age: $(( ($(date +%s) - CREATED) / 3600 ))h\"\n```\n\n3. **Context usage** — your internal sense of how much context you've consumed.\nAre you losing track of earlier conversation? Getting verbose? Repeating yourself?\n\n4. **Work done this cycle** — how many merges, how much complexity processed.\n\n**The principle:** Fresh sessions are cheap. Memory bloat compounds over time and\naffects the entire system — other agents, Dolt, and the OS all share the same RAM.\nAn idle session at 1.5 GB is worse than cycling and restarting at 200 MB.\n\n**Make a judgment call.** If multiple signals suggest you're getting heavy\n(high RSS, long session, substantial context consumed), hand off. If you're\nlight and there's active work in the queue, continue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-6p6t2","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Assess session health","updated_at":"2026-02-28T09:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a256b80855afd3ac284a3902b23415a9b78a62c489f52e7491b2b3e9db95bc90","created_at":"2026-02-28T09:53:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check mail for MERGE_READY submissions, escalations, and messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**MERGE_READY**:\nA polecat's work is ready for merge. Extract details and track for processing.\n\n```bash\n# Parse MERGE_READY message body:\n# Branch: \u003cbranch\u003e\n# Issue: \u003cissue-id\u003e\n# Polecat: \u003cpolecat-name\u003e\n# MR: \u003cmr-bead-id\u003e\n# Verified: clean git state, issue closed\n\n# Track in your merge queue for this patrol cycle:\n# - Branch name\n# - Issue ID\n# - Polecat name (REQUIRED for MERGED notification)\n# - MR bead ID (REQUIRED for closing after merge)\n```\n\n**IMPORTANT**: You MUST track the polecat name, MR bead ID, AND message ID - you will need them\nin merge-push step to send MERGED notification, close the MR bead, and archive the mail.\n\nMark as read. The work will be processed in queue-scan/process-branch.\n**Do NOT archive yet** - archive after merge/reject decision in merge-push step.\n\n**PATROL: Wake up**:\nWitness detected MRs waiting but refinery idle. Acknowledge and archive:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HELP / Blocked**:\nAssess and respond. If you can't help, escalate to Mayor.\nArchive after handling:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Check for in-flight merges.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: pending MRs in queue. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-6rozu","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery mail","updated_at":"2026-02-28T09:53:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f1b78a395c5192d80408029f94114651985b60b1fb910d65689ade6df119dc50","created_at":"2026-02-28T09:54:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Push the version tag to trigger the GHA release workflow.\n\n```bash\ngit push origin v0.1.0\n```\n\nThis triggers `.github/workflows/release.yml` which builds and pushes the Docker image to ghcr.io.\n","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-6th5m","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Push release tag","updated_at":"2026-02-28T09:54:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T09:06:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-6v2qk","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T09:06:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"452e99d6afc90465b6b338db13229ea17dc878b173fd55993aea1ceea6528528","created_at":"2026-02-28T08:56:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify work is complete and ready for merge queue.\n\n**Note:** Do NOT close the issue. The Refinery will close it after successful merge.\nThis enables conflict-resolution retries without reopening closed issues.\n\n**1. Verify the issue shows your work:**\n```bash\nbd show cue-sx0\n# Status should still be 'in_progress' (you're working on it)\n```\n\n**2. Add completion notes:**\n```bash\nbd update cue-sx0 --notes \"Implemented: \u003cbrief summary of what was done\u003e\"\n```\n\n**3. Sync beads:**\n```bash\nbd sync\n```\n\n**Exit criteria:** Issue updated with completion notes, beads synced.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-6vu4i","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Prepare work for review","updated_at":"2026-02-28T08:56:25Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"795f0417d343e9f29be619802ae3b5a11e7a901e2fde88ff9b9528a3bb8c0e2d","created_at":"2026-02-28T09:31:42Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Summarize this patrol cycle.\n\n**VERIFICATION**: Before generating summary, confirm for each merged branch:\n- [ ] MERGED mail was sent to witness\n- [ ] MR bead was closed\n- [ ] Source issue was closed\n- [ ] MERGE_READY mail archived\n\nIf any notifications, closures, or archiving were missed, do them now!\n\nInclude in summary:\n- Branches merged (count, names)\n- MERGED mails sent (count - should match branches merged)\n- MR beads closed (count - should match branches merged)\n- Source issues closed (count - should match branches merged)\n- MERGE_READY mails archived (count - should match branches merged)\n- Test results (pass/fail)\n- Branches with conflicts (count, names)\n- Conflict-resolution tasks created (IDs)\n- Issues filed (if any)\n- Any escalations sent\n\n**Conflict tracking is important** for monitoring MQ health. If many branches\nconflict, it may indicate target branches are moving too fast or branches are too stale.\n\nThis becomes the digest when the patrol is squashed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-6x621","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Generate handoff summary","updated_at":"2026-02-28T09:31:42Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"795f0417d343e9f29be619802ae3b5a11e7a901e2fde88ff9b9528a3bb8c0e2d","created_at":"2026-02-28T09:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Summarize this patrol cycle.\n\n**VERIFICATION**: Before generating summary, confirm for each merged branch:\n- [ ] MERGED mail was sent to witness\n- [ ] MR bead was closed\n- [ ] Source issue was closed\n- [ ] MERGE_READY mail archived\n\nIf any notifications, closures, or archiving were missed, do them now!\n\nInclude in summary:\n- Branches merged (count, names)\n- MERGED mails sent (count - should match branches merged)\n- MR beads closed (count - should match branches merged)\n- Source issues closed (count - should match branches merged)\n- MERGE_READY mails archived (count - should match branches merged)\n- Test results (pass/fail)\n- Branches with conflicts (count, names)\n- Conflict-resolution tasks created (IDs)\n- Issues filed (if any)\n- Any escalations sent\n\n**Conflict tracking is important** for monitoring MQ health. If many branches\nconflict, it may indicate target branches are moving too fast or branches are too stale.\n\nThis becomes the digest when the patrol is squashed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-6y8aw","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Generate handoff summary","updated_at":"2026-02-28T09:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/refinery","await_id":"","await_type":"","close_reason":"patrol cycle complete: Queue empty. Idle timeout. No merges.","closed_at":"2026-02-28T09:53:44Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e744710b4b5ddcfb1d9a3a957426a87d9b75eb6767d23eed49c763c3fc88e58e","created_at":"2026-02-28T09:53:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Patrol report: Queue empty. Idle timeout. No merges.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-75vme","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"mol-refinery-patrol","updated_at":"2026-02-28T09:53:44Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"dfab2e7b59734313316899e100837d3f7a1e7098c4c55ea83db66528f85eaefe","created_at":"2026-02-28T09:42:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"More branches to process?\n\n**Entry paths:**\n- Normal: After successful merge-push\n- Conflict-skip: After process-branch created conflict-resolution task\n\nIf yes: Return to process-branch with next branch.\nIf no: Continue to generate-summary.\n\n**Track for this cycle:**\n- branches_merged: count and names of successfully merged branches\n- branches_conflict: count and names of branches skipped due to conflicts\n- conflict_tasks: IDs of conflict-resolution tasks created\n\nThis tracking feeds into generate-summary for the patrol digest.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-78twq","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check for more work","updated_at":"2026-02-28T09:42:52Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"cd04eafd6cb3229e545c808f5c4de8961b95bb943104a4d5769ed7d9069b3c8c","created_at":"2026-02-28T09:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nInbox should contain ONLY:\n- Unprocessed MERGE_READY messages (will process next cycle)\n- Active work items\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- PATROL: Wake up that was acknowledged → archive\n- HELP/Blocked that was handled → archive\n- MERGE_READY where merge completed but archive was missed → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Check for orphaned MR beads**\n\nLook for open MR beads with no corresponding branch:\n```bash\nbd list --type=merge-request --status=open\n```\n\nFor each open MR bead:\n1. Check if branch exists: `git ls-remote origin refs/heads/\u003cbranch\u003e`\n2. Determine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n3. If branch is gone, pick `\u003cverification-target\u003e`:\n   - If `origin/\u003cmerge-target\u003e` exists, use `\u003cmerge-target\u003e`.\n   - If `origin/\u003cmerge-target\u003e` is missing (e.g. deleted integration branch), use `main`.\n4. Verify landed work: `git log origin/\u003cverification-target\u003e --oneline | grep \"\u003csource_issue\u003e\"`\n5. If work found → close MR with reason \"Merged (verified on \u003cverification-target\u003e; merge target was \u003cmerge-target\u003e)\"\n6. If work NOT found → investigate before closing:\n   - Check source_issue validity (should be gt-xxxxx, not branch name)\n   - Search reflog/dangling commits if possible\n   - If unverifiable, close with reason \"Unverifiable - no audit trail\"\n   - File bead if this indicates lost work\n\n**NEVER close an MR bead without verifying the work landed or is unrecoverable.**\n\n**Goal**: Inbox should have ≤3 active messages at end of cycle.\nKeep only: pending MRs in queue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-7csr1","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T09:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"74f380c0c3d311382ead516934fde91c0383b5b06e7d0457cd3c2e966216a877","created_at":"2026-02-28T09:27:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure workspace is pristine before handoff.\n\n**IMPORTANT: Do NOT run `git push`. That is `gt done`'s job (next step).**\n**IMPORTANT: Do NOT discard implementation changes. They must already be committed.**\n\n**1. Check for untracked files:**\n```bash\ngit status --porcelain\n```\nShould be empty. If not:\n- Add to .gitignore if appropriate\n- Remove if temporary: `rm \u003cfile\u003e`\n- Commit if needed: `git add \u003cfile\u003e \u0026\u0026 git commit -m \"chore: add \u003cfile\u003e\"`\n\n**2. Check stash:**\n```bash\ngit stash list\n```\nShould be empty. If not:\n- Pop and commit: `git stash pop \u0026\u0026 git add -A \u0026\u0026 git commit -m \"chore: unstash work (cue-dbv)\"`\n- Or drop if truly garbage: `git stash drop`\n\n**3. Verify clean state and commits:**\n```bash\ngit status                  # Must show \"working tree clean\"\ngit stash list              # Must be empty\ngit log origin/main..HEAD   # Your commits (should show your work)\n```\n\nIf `git log origin/main..HEAD` shows nothing but you DID make changes,\nsomething went wrong. Do NOT proceed — mail Witness for help.\n\n**Exit criteria:** Workspace clean, no cruft, all work committed. Do NOT push — `gt done` handles that.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-7id54","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Clean up workspace","updated_at":"2026-02-28T09:27:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T08:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-7peb5","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T08:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T09:06:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-7rhwd","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T09:06:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T09:04:31Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-7rwte","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T09:04:31Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a256b80855afd3ac284a3902b23415a9b78a62c489f52e7491b2b3e9db95bc90","created_at":"2026-02-28T09:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check mail for MERGE_READY submissions, escalations, and messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**MERGE_READY**:\nA polecat's work is ready for merge. Extract details and track for processing.\n\n```bash\n# Parse MERGE_READY message body:\n# Branch: \u003cbranch\u003e\n# Issue: \u003cissue-id\u003e\n# Polecat: \u003cpolecat-name\u003e\n# MR: \u003cmr-bead-id\u003e\n# Verified: clean git state, issue closed\n\n# Track in your merge queue for this patrol cycle:\n# - Branch name\n# - Issue ID\n# - Polecat name (REQUIRED for MERGED notification)\n# - MR bead ID (REQUIRED for closing after merge)\n```\n\n**IMPORTANT**: You MUST track the polecat name, MR bead ID, AND message ID - you will need them\nin merge-push step to send MERGED notification, close the MR bead, and archive the mail.\n\nMark as read. The work will be processed in queue-scan/process-branch.\n**Do NOT archive yet** - archive after merge/reject decision in merge-push step.\n\n**PATROL: Wake up**:\nWitness detected MRs waiting but refinery idle. Acknowledge and archive:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HELP / Blocked**:\nAssess and respond. If you can't help, escalate to Mayor.\nArchive after handling:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Check for in-flight merges.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: pending MRs in queue. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-7x7s1","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery mail","updated_at":"2026-02-28T09:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"769447c96532d91233b37d97c63c883444ba63231b19c4d70e37300549e8b8af","created_at":"2026-02-28T09:52:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**VERIFICATION GATE**: This step enforces the Beads Promise.\n\nIf all checks and tests PASSED: This step auto-completes. Proceed to merge.\n\nIf any check or test FAILED:\n1. Diagnose: Is this a branch regression or pre-existing on the target branch?\n2. If branch caused it:\n   - Abort merge\n   - **REOPEN the source issue** so it returns to the ready queue:\n     ```bash\n     bd update \u003cissue-id\u003e --status=open --assignee=\"\"\n     bd sync\n     ```\n   - Notify witness of rejection using the MERGE_FAILED protocol:\n     ```bash\n     gt mail send \u003crig\u003e/witness -s \"MERGE_FAILED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\n     Issue: \u003cissue-id\u003e\n     Polecat: \u003cpolecat-name\u003e\n     Rig: \u003crig\u003e\n     FailureType: quality-check\n     Error: \u003cfailure description\u003e\"\n     ```\n   - Close the MR bead as rejected:\n     ```bash\n     bd close \u003cmr-bead-id\u003e --reason \"Rejected: \u003cfailure description\u003e\"\n     ```\n   - Delete the rejected branch (a new polecat will create a fresh one):\n     ```bash\n     git push origin --delete \u003cpolecat-branch\u003e\n     ```\n   - Archive the MERGE_READY message\n   - Skip to loop-check\n3. If pre-existing on the target branch:\n   - **DUPLICATE CHECK (MANDATORY)**: Before filing a new bug, search for existing open bugs:\n     ```bash\n     bd search \"\u003cfailure description\u003e\" --status open --label gt:bug --limit 5\n     ```\n     If an existing open bug covers the same failure, do NOT create a duplicate.\n     Instead, note the existing bead ID and proceed.\n   - Only if NO existing bug matches: bd create --type=bug --priority=1 --title=\"Pre-existing failure: \u003cdescription\u003e\"\n   - FORBIDDEN: Writing code to fix quality check or test failures. You merge branches, you do not develop.\n   - Proceed with the merge if the failure is pre-existing (not caused by the branch).\n\n**REJECTION CHECKLIST** (all required before skipping to loop-check):\n- [ ] Source issue reopened (bd update \u003cissue-id\u003e --status=open --assignee=\"\")\n- [ ] MERGE_FAILED notification sent to witness\n- [ ] MR bead closed with rejection reason\n- [ ] Rejected branch deleted from remote\n- [ ] MERGE_READY message archived\n\n**GATE REQUIREMENT**: You CANNOT proceed to merge-push without:\n- All quality checks and tests passing, OR\n- Bead filed (or existing duplicate confirmed) for the pre-existing failure\n\nFORBIDDEN: Writing application code, exploring polecat implementations, or\nre-implementing fixes. You are a mechanical merge processor.\n\nThis is non-negotiable. Never disavow. Never \"note and proceed.\" ","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-83j8p","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Handle quality check or test failures","updated_at":"2026-02-28T09:52:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a145299f5856de0c58867caa826421571ffebd630cd2024545cd83ef890c69b6","created_at":"2026-02-28T08:53:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Submit your work and clean up. You cease to exist after this step.\n\n**Self-Cleaning Model:**\nOnce you run `gt done`, you're gone. The command:\n1. Pushes your branch to origin\n2. Creates an MR bead in the merge queue\n3. Nukes your sandbox (worktree removal)\n4. Exits your session immediately\n\n**Run gt done:**\n```bash\ngt done\n```\n\nYou should see output like:\n```\n✓ Work submitted to merge queue\n  MR ID: gt-xxxxx\n  Source: polecat/\u003cname\u003e\n  Target: main\n  Issue: cue-x7q\n✓ Sandbox nuked\n✓ Session exiting\n```\n\n**What happens next (not your concern):**\n- Refinery processes your MR from the queue\n- Refinery rebases and merges to main\n- Refinery closes the issue\n- If conflicts: Refinery spawns a FRESH polecat to re-implement\n\nYou are NOT involved in any of that. You're gone. Done means gone.\n\n**Exit criteria:** Work submitted, sandbox nuked, session exited.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-8420e","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Submit work and self-clean","updated_at":"2026-02-28T08:53:43Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6b90a99857cf15bf080d656c6c4d2972a0f701fd961fdc44f1f94b2be48fa299","created_at":"2026-02-28T08:57:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify work is complete and ready for merge queue.\n\n**Note:** Do NOT close the issue. The Refinery will close it after successful merge.\nThis enables conflict-resolution retries without reopening closed issues.\n\n**1. Verify the issue shows your work:**\n```bash\nbd show cue-6z7\n# Status should still be 'in_progress' (you're working on it)\n```\n\n**2. Add completion notes:**\n```bash\nbd update cue-6z7 --notes \"Implemented: \u003cbrief summary of what was done\u003e\"\n```\n\n**3. Sync beads:**\n```bash\nbd sync\n```\n\n**Exit criteria:** Issue updated with completion notes, beads synced.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-8521f","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"in_progress","target":"","timeout_ns":0,"title":"Prepare work for review","updated_at":"2026-02-28T09:03:53Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"146a9143e63de0fec5ca778e7e296e3e72adf21895777c0a2de56aafcb2c33f2","created_at":"2026-02-28T09:37:02Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Review your own changes before running tests.\n\n**1. Review the diff:**\n```bash\ngit diff origin/main...HEAD     # All changes vs main\ngit log --oneline origin/main..HEAD  # All commits\n```\n\n**2. Check for common issues:**\n\n| Category | Look For |\n|----------|----------|\n| Bugs | Off-by-one, null handling, edge cases |\n| Security | Injection, auth bypass, exposed secrets |\n| Style | Naming, formatting, code organization |\n| Completeness | Missing error handling, incomplete paths |\n| Cruft | Debug prints, commented code, TODOs |\n\n**3. Refactor check:**\n\nAsk yourself:\n- Does this implementation duplicate logic that already exists elsewhere?\n- Are there names, abstractions, or structures that will confuse the next person?\n- Would you be embarrassed to show this diff to a senior engineer?\n\nIf yes to any — fix it now. Refactoring is part of the work, not a luxury.\nCommit any refactoring separately: `git commit -m \"refactor: \u003cdescription\u003e (cue-b3g)\"`\n\n**4. Fix issues found:**\nDon't just note them - fix them now. Amend or add commits as needed.\n\n**5. Verify no unintended changes:**\n```bash\ngit diff --stat origin/main...HEAD\n# Only files relevant to cue-b3g should appear\n```\n\nIf you accidentally modified unrelated files, remove those changes.\n\n**Exit criteria:** Changes are clean, reviewed, refactored where needed, and ready for testing.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-86zyv","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Self-review changes","updated_at":"2026-02-28T09:37:02Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:02:59Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T10:00:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-8aniu","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T10:02:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/refinery","await_id":"","await_type":"","close_reason":"patrol cycle complete: Queue empty. Idle cycle 4 (4m timeout). No merges.","closed_at":"2026-02-28T10:01:20Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e744710b4b5ddcfb1d9a3a957426a87d9b75eb6767d23eed49c763c3fc88e58e","created_at":"2026-02-28T09:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Patrol report: Queue empty. Idle cycle 4 (4m timeout). No merges.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-8dh0w","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"mol-refinery-patrol","updated_at":"2026-02-28T10:01:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"0c8edba654cabe272d220550cdd976eed7d73509b2b4523ce85d04c07c7dfc9e","created_at":"2026-02-28T08:56:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Do the actual implementation work.\n\n**TDD is mandatory. Write a failing test before writing implementation code.**\n\nFor every feature or bug fix:\n1. Write a test that captures the expected behaviour and **confirm it fails**\n2. Commit the failing test: `git commit -m \"test: failing test for \u003cdescription\u003e (cue-sx0)\"`\n3. Implement until the test passes\n4. Commit the implementation: `git commit -m \"fix/feat: \u003cdescription\u003e (cue-sx0)\"`\n\n```bash\n# Step 1: Write test, verify it fails\n   # Must see your new test fail\n\n# Step 2: Commit the failing test\ngit add \u003ctest-files\u003e\ngit commit -m \"test: failing test for \u003cdescription\u003e (cue-sx0)\"\n\n# Step 3: Implement\n# ... write code ...\n\n# Step 4: Verify test now passes\n   # Your test must now pass\n\n# Step 5: Commit implementation\ngit add \u003cimpl-files\u003e\ngit commit -m \"fix/feat: \u003cdescription\u003e (cue-sx0)\"\n```\n\n**No exceptions.** A fix without a regression test is incomplete. A feature without tests is incomplete.\n\n**Working principles:**\n- Follow existing codebase conventions\n- Make atomic, focused commits\n- Keep changes scoped to the assigned issue\n- Don't gold-plate or scope-creep\n\n**Discovered work:**\nIf you find bugs or improvements outside your scope:\n```bash\nbd create --title \"Found: \u003cdescription\u003e\" --type bug --priority 2\n# Note the ID, continue with your work\n```\n\nDo NOT fix unrelated issues in this branch.\n\n**If stuck:**\nDon't spin for more than 15 minutes. Mail Witness:\n```bash\ngt mail send \u003crig\u003e/witness -s \"HELP: Stuck on implementation\" -m \"Issue: cue-sx0\nTrying to: \u003cwhat you're attempting\u003e\nProblem: \u003cwhat's blocking you\u003e\nTried: \u003cwhat you've attempted\u003e\"\n```\n\n**Exit criteria:** Implementation complete, all changes committed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-8dhu2","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Implement the solution","updated_at":"2026-02-28T08:56:25Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b5b41d316559ab36d81b013937c0b56a205c257b0f96499632c4e34fb4d420c5","created_at":"2026-02-28T10:01:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check the beads merge queue - this is the SOURCE OF TRUTH for pending merges.\n\n```bash\ngit fetch --prune origin\ngt mq list \u003crig\u003e\n```\n\nThe beads MQ tracks all pending merge requests. Do NOT rely on `git branch -r | grep polecat`\nas branches may exist without MR beads, or MR beads may exist for already-merged work.\n\nIf queue empty, skip to \"check-integration-branches\" step.\n\nFor each MR in the queue, verify the branch still exists:\n```bash\ngit branch -r | grep \u003cbranch\u003e\n```\n\nIf branch doesn't exist for a queued MR:\n- Close the MR bead: `bd close \u003cmr-id\u003e --reason \"Branch no longer exists\"`\n- Remove from processing queue\n\nTrack verified MR list for this cycle.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-8f09k","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Scan merge queue","updated_at":"2026-02-28T10:01:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T09:37:14Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-8fggr","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T09:37:14Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:08:19Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T10:06:06Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-8mv0d","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T10:08:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"adc4b5d7ddcf1e0ae73594239b5e871544c5a6149f071931c2f59b052c5f5bbd","created_at":"2026-02-28T09:27:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Submit your work and clean up. You cease to exist after this step.\n\n**Self-Cleaning Model:**\nOnce you run `gt done`, you're gone. The command:\n1. Pushes your branch to origin\n2. Creates an MR bead in the merge queue\n3. Nukes your sandbox (worktree removal)\n4. Exits your session immediately\n\n**Run gt done:**\n```bash\ngt done\n```\n\nYou should see output like:\n```\n✓ Work submitted to merge queue\n  MR ID: gt-xxxxx\n  Source: polecat/\u003cname\u003e\n  Target: main\n  Issue: cue-dbv\n✓ Sandbox nuked\n✓ Session exiting\n```\n\n**What happens next (not your concern):**\n- Refinery processes your MR from the queue\n- Refinery rebases and merges to main\n- Refinery closes the issue\n- If conflicts: Refinery spawns a FRESH polecat to re-implement\n\nYou are NOT involved in any of that. You're gone. Done means gone.\n\n**Exit criteria:** Work submitted, sandbox nuked, session exited.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-8o0eq","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Submit work and self-clean","updated_at":"2026-02-28T09:27:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b5b41d316559ab36d81b013937c0b56a205c257b0f96499632c4e34fb4d420c5","created_at":"2026-02-28T09:31:42Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check the beads merge queue - this is the SOURCE OF TRUTH for pending merges.\n\n```bash\ngit fetch --prune origin\ngt mq list \u003crig\u003e\n```\n\nThe beads MQ tracks all pending merge requests. Do NOT rely on `git branch -r | grep polecat`\nas branches may exist without MR beads, or MR beads may exist for already-merged work.\n\nIf queue empty, skip to \"check-integration-branches\" step.\n\nFor each MR in the queue, verify the branch still exists:\n```bash\ngit branch -r | grep \u003cbranch\u003e\n```\n\nIf branch doesn't exist for a queued MR:\n- Close the MR bead: `bd close \u003cmr-id\u003e --reason \"Branch no longer exists\"`\n- Remove from processing queue\n\nTrack verified MR list for this cycle.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-8omjf","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Scan merge queue","updated_at":"2026-02-28T09:31:42Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e731efa93a5c9d5231a98d88586801bc0b5c8709c7cbb6b28d4f7ffe6efd1fd1","created_at":"2026-02-28T10:06:30Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: run_tests = true**\n**Config: test_command = go test ./...**\n**Config: setup_command = **\n**Config: typecheck_command = **\n**Config: lint_command = **\n**Config: build_command = **\n\n**1. Run quality checks (skip any that are not configured):**\n\nIf setup_command is set: ``\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf build_command is set: ``\n\n```bash\n           # Make sure all newly added dependencies are installed (if command set)\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n           # Make sure it builds (if command set)\n```\n\nEmpty commands mean \"not configured for this project\" — skip silently.\n\n**2. If quality checks fail:**\n\nProceed to handle-failures step. Track which specific check failed\n(setup/typecheck/lint/build) for the failure diagnosis.\n\n**3. Run the test suite:**\n\nIf run_tests = \"false\": Skip this step entirely. Proceed to handle-failures.\n\nIf run_tests = \"true\":\n\n```bash\ngo test ./...            # Run tests (configured per-rig)\n```\n\nTrack results: pass count, fail count, specific failures.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-8pzqq","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Run quality checks and tests","updated_at":"2026-02-28T10:06:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:04:13Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T10:03:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-8ubbd","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T10:04:13Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:06:01Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T10:04:18Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-8umo3","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T10:06:01Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"8f52f8b0bf5728016d5c5ea599290009e75c32c389b1ee0a760e575719b0cc8d","created_at":"2026-02-28T09:37:02Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Initialize your session and understand your assignment.\n\n**1. Prime your environment:**\n```bash\ngt prime                    # Load role context\nbd prime                    # Load beads context\n```\n\n**2. Check your hook:**\n```bash\ngt hook               # Shows your pinned molecule and hook_bead\n```\n\nThe hook_bead is your assigned issue. Read it carefully:\n```bash\nbd show cue-b3g           # Full issue details\n```\n\n**3. Check inbox for additional context:**\n```bash\ngt mail inbox\n# Read any HANDOFF or assignment messages\n```\n\n**4. Understand the requirements:**\n- What exactly needs to be done?\n- What files are likely involved?\n- Are there dependencies or blockers?\n- What does \"done\" look like?\n\n**5. Verify you can proceed:**\n- No unresolved blockers on the issue\n- You understand what to do\n- Required resources are available\n\nIf blocked or unclear, mail Witness immediately:\n```bash\ngt mail send \u003crig\u003e/witness -s \"HELP: Unclear requirements\" -m \"Issue: cue-b3g\nQuestion: \u003cwhat you need clarified\u003e\"\n```\n\n**Exit criteria:** You understand the work and can begin implementation.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-8vmmf","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Load context and verify assignment","updated_at":"2026-02-28T09:37:02Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T08:54:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-912u4","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T08:54:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T09:27:33Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-96iiz","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T09:27:33Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9fd4f8fe6af19dea2254cbcfdca80525f6869f79b5dc6d06ecb32289bda67fe0","created_at":"2026-02-28T09:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision. Use the signals from context-check to decide.\n\n**If you decide to continue patrolling:**\n\nUse await-event to subscribe to the refinery event channel with exponential backoff:\n\n```bash\ngt mol step await-event --channel refinery --agent-bead gt-\u003crig\u003e-refinery --backoff-base 30s --backoff-mult 2 --backoff-max 5m --cleanup\n```\n\nThis command:\n1. Watches `~/gt/events/refinery/` for event files (polling-based)\n2. Returns IMMEDIATELY when an event is emitted (MERGE_READY, PATROL_WAKE, MQ_SUBMIT)\n3. If no events, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on refinery agent bead for backoff state\n5. `--cleanup` auto-deletes processed event files\n\n**Supported events:**\n- `MERGE_READY` — from witness when polecat branch is pushed and ready to merge\n- `PATROL_WAKE` — from witness when MRs waiting but refinery appears idle\n- `MQ_SUBMIT` — from polecat via `gt mq submit`\n\n**On event received** (refinery-specific activity):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no events):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-event returns (either by event or timeout):\n1. **Re-assess session health** (check RSS, context, age again — conditions change)\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary: branches merged, test results, queue state\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If you decide to hand off:**\n\nReport and exit using `gt handoff` for clean session transition:\n\n```bash\ngt handoff -s \"Patrol complete\" -m \"Merged X branches, Y tests passed.\nQueue: empty/N remaining\nRSS: X MB, Session age: Xh\nNext: [any notes for successor]\"\n```\n\n`gt handoff` sends handoff mail to yourself, respawns with a fresh Claude instance,\nSessionStart hook runs gt prime, and your successor picks up from the hook.\n\n**DO NOT just exit.** Always use `gt handoff` for proper lifecycle.\n\n**IMPORTANT**: Never sleep-poll manually (e.g., `sleep 30 \u0026\u0026 bd list`).\nAlways use `gt mol step await-event` — it's event-driven and tracks backoff state.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-985eo","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Burn and respawn or loop","updated_at":"2026-02-28T09:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6c13a80e672c4e6ced6c05f5bbf72aeb746501362aba7c8df898024fc5cbe1aa","created_at":"2026-02-28T09:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Pick next branch from queue. Attempt mechanical rebase on the MR's effective target branch.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n\n**Step 0: Determine rebase target (must match merge target)**\n\nResolve `\u003crebase-target\u003e` using the **Target Resolution Rule** above.\nDo NOT hardcode `main` unless `main` is actually the resolved MR target.\n\n**Step 1: Checkout and attempt rebase**\n```bash\ngit checkout -b temp origin/\u003cpolecat-branch\u003e\ngit rebase origin/\u003crebase-target\u003e\n```\n\n**Step 2: Check rebase result**\n\nThe rebase exits with:\n- Exit code 0: Success - proceed to run-tests\n- Exit code 1 (conflicts): Conflict detected - proceed to Step 3\n\nTo detect conflict state after rebase fails:\n```bash\n# Check if we're in a conflicted rebase state\nls .git/rebase-merge 2\u003e/dev/null \u0026\u0026 echo \"CONFLICT_STATE\"\n```\n\n**Step 3: Handle conflicts (if any)**\n\nIf rebase SUCCEEDED (exit code 0):\n- Skip to run-tests step (continue normal merge flow)\n\nIf rebase FAILED with conflicts:\n\n1. **Abort the rebase** (DO NOT leave repo in conflicted state):\n```bash\ngit rebase --abort\n```\n\n2. **Record conflict metadata**:\n```bash\n# Capture target SHA for reference\nTARGET_SHA=$(git rev-parse origin/\u003crebase-target\u003e)\nBRANCH_SHA=$(git rev-parse origin/\u003cpolecat-branch\u003e)\n```\n\n3. **Create conflict-resolution task**:\n```bash\nbd create --type=task --priority=1 --title=\"Resolve merge conflicts: \u003coriginal-issue-title\u003e\" --description=\"## Conflict Resolution Required\n\nOriginal MR: \u003cmr-bead-id\u003e\nBranch: \u003cpolecat-branch\u003e\nOriginal Issue: \u003cissue-id\u003e\nConflict with target \u003crebase-target\u003e at: ${TARGET_SHA}\nBranch SHA: ${BRANCH_SHA}\n\n## Instructions\n1. Clone/checkout the branch\n2. Rebase on target: git rebase origin/\u003crebase-target\u003e\n3. Resolve conflicts\n4. Force push: git push -f origin \u003cbranch\u003e\n5. Close this task when done\n\nThe MR will be re-queued for processing after conflicts are resolved.\"\n```\n\n4. **Skip this MR** (do NOT delete branch or close MR bead):\n- Leave branch intact for conflict resolution\n- Leave MR bead open (will be re-processed after resolution)\n- Continue to loop-check for next branch\n\n**CRITICAL**: Never delete a branch that has conflicts. The branch contains\nthe original work and must be preserved for conflict resolution.\n\nTrack: rebase result (success/conflict), conflict task ID if created.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-9bz3v","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Mechanical rebase","updated_at":"2026-02-28T09:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T09:37:14Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-9cey1","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T09:37:14Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"dfab2e7b59734313316899e100837d3f7a1e7098c4c55ea83db66528f85eaefe","created_at":"2026-02-28T10:01:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"More branches to process?\n\n**Entry paths:**\n- Normal: After successful merge-push\n- Conflict-skip: After process-branch created conflict-resolution task\n\nIf yes: Return to process-branch with next branch.\nIf no: Continue to generate-summary.\n\n**Track for this cycle:**\n- branches_merged: count and names of successfully merged branches\n- branches_conflict: count and names of branches skipped due to conflicts\n- conflict_tasks: IDs of conflict-resolution tasks created\n\nThis tracking feeds into generate-summary for the patrol digest.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-9domz","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check for more work","updated_at":"2026-02-28T10:01:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T09:09:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-9icpx","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T09:09:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:02:59Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T10:00:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-9kkfr","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T10:02:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T09:06:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-9kopp","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T09:06:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3560d7b1a900af0fa671383af7df139375a27ea4969d5ef8a8fe144df9a317b1","created_at":"2026-02-28T09:37:02Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd mol current` / `bd close \u003cstep\u003e`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `gt hook` to find your pinned molecule, then `bd show`\nfor step details — do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n| base_branch | sling vars | The base branch to rebase on (default: main) |\n| setup_command | rig config | Setup/install command (e.g., `pnpm install`). Empty = skip. |\n| typecheck_command | rig config | Type check command (e.g., `tsc --noEmit`). Empty = skip. |\n| test_command | rig config | Test command. Empty = skip. Rig must configure for its language. |\n| lint_command | rig config | Lint command (e.g., `eslint .`). Empty = skip. |\n| build_command | rig config | Build command (e.g., `go build ./...`). Empty = skip. |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-9nouy","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"mol-polecat-work","updated_at":"2026-02-28T09:37:02Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T08:59:05Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-9tytk","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T08:59:05Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T09:52:46Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T09:41:51Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-9vh64","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T09:52:46Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9e2c56d105ff1eb6f38dc47792bd0797c114f7591048c0a5ad2c688c98c3cc62","created_at":"2026-02-28T09:54:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"claude-usage-exporter release workflow — from clean tree to published image.\n\n1. Preflight checks (clean git, up to date)\n2. Build verification (nix build)\n3. Version bump (flake.nix)\n4. Git operations (commit, tag, push)\n5. CI verification (GitHub Actions builds and pushes image)\n6. GitHub Release with handwritten notes\n\n## Usage\n\n```bash\nbd mol wisp create claude-usage-exporter-release --var version=0.1.0\n```\n","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-a4efj","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"claude-usage-exporter-release","updated_at":"2026-02-28T09:54:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6c13a80e672c4e6ced6c05f5bbf72aeb746501362aba7c8df898024fc5cbe1aa","created_at":"2026-02-28T09:30:15Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Pick next branch from queue. Attempt mechanical rebase on the MR's effective target branch.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n\n**Step 0: Determine rebase target (must match merge target)**\n\nResolve `\u003crebase-target\u003e` using the **Target Resolution Rule** above.\nDo NOT hardcode `main` unless `main` is actually the resolved MR target.\n\n**Step 1: Checkout and attempt rebase**\n```bash\ngit checkout -b temp origin/\u003cpolecat-branch\u003e\ngit rebase origin/\u003crebase-target\u003e\n```\n\n**Step 2: Check rebase result**\n\nThe rebase exits with:\n- Exit code 0: Success - proceed to run-tests\n- Exit code 1 (conflicts): Conflict detected - proceed to Step 3\n\nTo detect conflict state after rebase fails:\n```bash\n# Check if we're in a conflicted rebase state\nls .git/rebase-merge 2\u003e/dev/null \u0026\u0026 echo \"CONFLICT_STATE\"\n```\n\n**Step 3: Handle conflicts (if any)**\n\nIf rebase SUCCEEDED (exit code 0):\n- Skip to run-tests step (continue normal merge flow)\n\nIf rebase FAILED with conflicts:\n\n1. **Abort the rebase** (DO NOT leave repo in conflicted state):\n```bash\ngit rebase --abort\n```\n\n2. **Record conflict metadata**:\n```bash\n# Capture target SHA for reference\nTARGET_SHA=$(git rev-parse origin/\u003crebase-target\u003e)\nBRANCH_SHA=$(git rev-parse origin/\u003cpolecat-branch\u003e)\n```\n\n3. **Create conflict-resolution task**:\n```bash\nbd create --type=task --priority=1 --title=\"Resolve merge conflicts: \u003coriginal-issue-title\u003e\" --description=\"## Conflict Resolution Required\n\nOriginal MR: \u003cmr-bead-id\u003e\nBranch: \u003cpolecat-branch\u003e\nOriginal Issue: \u003cissue-id\u003e\nConflict with target \u003crebase-target\u003e at: ${TARGET_SHA}\nBranch SHA: ${BRANCH_SHA}\n\n## Instructions\n1. Clone/checkout the branch\n2. Rebase on target: git rebase origin/\u003crebase-target\u003e\n3. Resolve conflicts\n4. Force push: git push -f origin \u003cbranch\u003e\n5. Close this task when done\n\nThe MR will be re-queued for processing after conflicts are resolved.\"\n```\n\n4. **Skip this MR** (do NOT delete branch or close MR bead):\n- Leave branch intact for conflict resolution\n- Leave MR bead open (will be re-processed after resolution)\n- Continue to loop-check for next branch\n\n**CRITICAL**: Never delete a branch that has conflicts. The branch contains\nthe original work and must be preserved for conflict resolution.\n\nTrack: rebase result (success/conflict), conflict task ID if created.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-adz9e","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Mechanical rebase","updated_at":"2026-02-28T09:30:15Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T09:30:41Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ae7ib","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T09:30:41Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T08:54:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-af1u6","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T08:54:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T08:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-agx3o","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T08:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"cd04eafd6cb3229e545c808f5c4de8961b95bb943104a4d5769ed7d9069b3c8c","created_at":"2026-02-28T09:30:15Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nInbox should contain ONLY:\n- Unprocessed MERGE_READY messages (will process next cycle)\n- Active work items\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- PATROL: Wake up that was acknowledged → archive\n- HELP/Blocked that was handled → archive\n- MERGE_READY where merge completed but archive was missed → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Check for orphaned MR beads**\n\nLook for open MR beads with no corresponding branch:\n```bash\nbd list --type=merge-request --status=open\n```\n\nFor each open MR bead:\n1. Check if branch exists: `git ls-remote origin refs/heads/\u003cbranch\u003e`\n2. Determine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n3. If branch is gone, pick `\u003cverification-target\u003e`:\n   - If `origin/\u003cmerge-target\u003e` exists, use `\u003cmerge-target\u003e`.\n   - If `origin/\u003cmerge-target\u003e` is missing (e.g. deleted integration branch), use `main`.\n4. Verify landed work: `git log origin/\u003cverification-target\u003e --oneline | grep \"\u003csource_issue\u003e\"`\n5. If work found → close MR with reason \"Merged (verified on \u003cverification-target\u003e; merge target was \u003cmerge-target\u003e)\"\n6. If work NOT found → investigate before closing:\n   - Check source_issue validity (should be gt-xxxxx, not branch name)\n   - Search reflog/dangling commits if possible\n   - If unverifiable, close with reason \"Unverifiable - no audit trail\"\n   - File bead if this indicates lost work\n\n**NEVER close an MR bead without verifying the work landed or is unrecoverable.**\n\n**Goal**: Inbox should have ≤3 active messages at end of cycle.\nKeep only: pending MRs in queue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ahspw","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T09:30:15Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:06:01Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T10:04:18Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-akt7h","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T10:06:01Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6c13a80e672c4e6ced6c05f5bbf72aeb746501362aba7c8df898024fc5cbe1aa","created_at":"2026-02-28T10:01:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Pick next branch from queue. Attempt mechanical rebase on the MR's effective target branch.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n\n**Step 0: Determine rebase target (must match merge target)**\n\nResolve `\u003crebase-target\u003e` using the **Target Resolution Rule** above.\nDo NOT hardcode `main` unless `main` is actually the resolved MR target.\n\n**Step 1: Checkout and attempt rebase**\n```bash\ngit checkout -b temp origin/\u003cpolecat-branch\u003e\ngit rebase origin/\u003crebase-target\u003e\n```\n\n**Step 2: Check rebase result**\n\nThe rebase exits with:\n- Exit code 0: Success - proceed to run-tests\n- Exit code 1 (conflicts): Conflict detected - proceed to Step 3\n\nTo detect conflict state after rebase fails:\n```bash\n# Check if we're in a conflicted rebase state\nls .git/rebase-merge 2\u003e/dev/null \u0026\u0026 echo \"CONFLICT_STATE\"\n```\n\n**Step 3: Handle conflicts (if any)**\n\nIf rebase SUCCEEDED (exit code 0):\n- Skip to run-tests step (continue normal merge flow)\n\nIf rebase FAILED with conflicts:\n\n1. **Abort the rebase** (DO NOT leave repo in conflicted state):\n```bash\ngit rebase --abort\n```\n\n2. **Record conflict metadata**:\n```bash\n# Capture target SHA for reference\nTARGET_SHA=$(git rev-parse origin/\u003crebase-target\u003e)\nBRANCH_SHA=$(git rev-parse origin/\u003cpolecat-branch\u003e)\n```\n\n3. **Create conflict-resolution task**:\n```bash\nbd create --type=task --priority=1 --title=\"Resolve merge conflicts: \u003coriginal-issue-title\u003e\" --description=\"## Conflict Resolution Required\n\nOriginal MR: \u003cmr-bead-id\u003e\nBranch: \u003cpolecat-branch\u003e\nOriginal Issue: \u003cissue-id\u003e\nConflict with target \u003crebase-target\u003e at: ${TARGET_SHA}\nBranch SHA: ${BRANCH_SHA}\n\n## Instructions\n1. Clone/checkout the branch\n2. Rebase on target: git rebase origin/\u003crebase-target\u003e\n3. Resolve conflicts\n4. Force push: git push -f origin \u003cbranch\u003e\n5. Close this task when done\n\nThe MR will be re-queued for processing after conflicts are resolved.\"\n```\n\n4. **Skip this MR** (do NOT delete branch or close MR bead):\n- Leave branch intact for conflict resolution\n- Leave MR bead open (will be re-processed after resolution)\n- Continue to loop-check for next branch\n\n**CRITICAL**: Never delete a branch that has conflicts. The branch contains\nthe original work and must be preserved for conflict resolution.\n\nTrack: rebase result (success/conflict), conflict task ID if created.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-amnbv","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Mechanical rebase","updated_at":"2026-02-28T10:01:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"bb3e885c2ae25def9ff95a7bc4e2fa0b6ab4387b82f5b50fb18d1bc62bd17ee8","created_at":"2026-02-28T09:03:32Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Submit your work and clean up. You cease to exist after this step.\n\n**Self-Cleaning Model:**\nOnce you run `gt done`, you're gone. The command:\n1. Pushes your branch to origin\n2. Creates an MR bead in the merge queue\n3. Nukes your sandbox (worktree removal)\n4. Exits your session immediately\n\n**Run gt done:**\n```bash\ngt done\n```\n\nYou should see output like:\n```\n✓ Work submitted to merge queue\n  MR ID: gt-xxxxx\n  Source: polecat/\u003cname\u003e\n  Target: main\n  Issue: cue-ctd\n✓ Sandbox nuked\n✓ Session exiting\n```\n\n**What happens next (not your concern):**\n- Refinery processes your MR from the queue\n- Refinery rebases and merges to main\n- Refinery closes the issue\n- If conflicts: Refinery spawns a FRESH polecat to re-implement\n\nYou are NOT involved in any of that. You're gone. Done means gone.\n\n**Exit criteria:** Work submitted, sandbox nuked, session exited.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-at3p0","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"in_progress","target":"","timeout_ns":0,"title":"Submit work and self-clean","updated_at":"2026-02-28T09:09:04Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9fd4f8fe6af19dea2254cbcfdca80525f6869f79b5dc6d06ecb32289bda67fe0","created_at":"2026-02-28T09:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision. Use the signals from context-check to decide.\n\n**If you decide to continue patrolling:**\n\nUse await-event to subscribe to the refinery event channel with exponential backoff:\n\n```bash\ngt mol step await-event --channel refinery --agent-bead gt-\u003crig\u003e-refinery --backoff-base 30s --backoff-mult 2 --backoff-max 5m --cleanup\n```\n\nThis command:\n1. Watches `~/gt/events/refinery/` for event files (polling-based)\n2. Returns IMMEDIATELY when an event is emitted (MERGE_READY, PATROL_WAKE, MQ_SUBMIT)\n3. If no events, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on refinery agent bead for backoff state\n5. `--cleanup` auto-deletes processed event files\n\n**Supported events:**\n- `MERGE_READY` — from witness when polecat branch is pushed and ready to merge\n- `PATROL_WAKE` — from witness when MRs waiting but refinery appears idle\n- `MQ_SUBMIT` — from polecat via `gt mq submit`\n\n**On event received** (refinery-specific activity):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no events):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-event returns (either by event or timeout):\n1. **Re-assess session health** (check RSS, context, age again — conditions change)\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary: branches merged, test results, queue state\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If you decide to hand off:**\n\nReport and exit using `gt handoff` for clean session transition:\n\n```bash\ngt handoff -s \"Patrol complete\" -m \"Merged X branches, Y tests passed.\nQueue: empty/N remaining\nRSS: X MB, Session age: Xh\nNext: [any notes for successor]\"\n```\n\n`gt handoff` sends handoff mail to yourself, respawns with a fresh Claude instance,\nSessionStart hook runs gt prime, and your successor picks up from the hook.\n\n**DO NOT just exit.** Always use `gt handoff` for proper lifecycle.\n\n**IMPORTANT**: Never sleep-poll manually (e.g., `sleep 30 \u0026\u0026 bd list`).\nAlways use `gt mol step await-event` — it's event-driven and tracks backoff state.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-athjw","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Burn and respawn or loop","updated_at":"2026-02-28T09:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:04:13Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T10:03:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-axmvb","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T10:04:13Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"8737a17b7bb92b8ec869791fdc3b4b1a68c31173ee93d4a430e37833f7a04f61","created_at":"2026-02-28T09:30:15Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Merge and push. CRITICAL: Notifications come IMMEDIATELY after push.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n**Config: delete_merged_branches = true**\n\n**Step 1: Merge and Push**\nDetermine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n```bash\ngit checkout \u003cmerge-target\u003e\ngit merge --ff-only temp\ngit push origin \u003cmerge-target\u003e\n```\n\n**Step 1.5: VERIFY PUSH SUCCEEDED (CRITICAL - PATCH-003)**\n\nPush can fail silently (network, auth, hooks). IMMEDIATELY verify:\n```bash\ngit fetch origin\nLOCAL_SHA=$(git rev-parse \u003cmerge-target\u003e)\nREMOTE_SHA=$(git rev-parse origin/\u003cmerge-target\u003e)\necho \"Local:  $LOCAL_SHA\"\necho \"Remote: $REMOTE_SHA\"\n```\n\n**If SHAs match**: Push succeeded. Continue to Step 2.\n\n**If SHAs differ**: STOP. Push failed silently.\n- DO NOT send MERGED notification\n- DO NOT close MR bead\n- DO NOT delete branch\n- Debug the push failure (check `git push` output, network, auth)\n- Retry push and verify again before proceeding\n\n⚠️ **STOP HERE - DO NOT PROCEED UNTIL STEPS 1.5 AND 2-3 COMPLETE**\n\n**Step 2: Send MERGED Notification (REQUIRED - DO THIS IMMEDIATELY)**\n\nRIGHT NOW, before any cleanup, send MERGED mail to Witness:\n\n```bash\ngt mail send \u003crig\u003e/witness -s \"MERGED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\nMerged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n```\n\nThis signals the Witness to nuke the polecat worktree. WITHOUT THIS NOTIFICATION,\nPOLECAT WORKTREES ACCUMULATE INDEFINITELY AND THE LIFECYCLE BREAKS.\n\n**Step 3: Post-merge cleanup (REQUIRED — single command)**\n\nThis single command handles closing the MR bead, closing the source issue, and\ndeleting the remote polecat branch (respects delete_merged_branches config):\n\n```bash\ngt mq post-merge \u003crig\u003e \u003cmr-bead-id\u003e\n```\n\nThe MR bead ID was in the MERGE_READY message or find via:\n```bash\nbd list --type=merge-request --status=open | grep \u003cpolecat-name\u003e\n```\n\nVerify the command output shows all steps succeeded (✓ for each).\n\n**Step 4: Archive the MERGE_READY mail (REQUIRED)**\n```bash\ngt mail archive \u003cmerge-ready-message-id\u003e\n```\nThe message ID was tracked when you processed inbox-check.\n\n**Step 5: Cleanup temp branch**\n```bash\ngit branch -d temp\n```\n\n**VERIFICATION GATE**: You CANNOT proceed to loop-check without:\n- [x] MERGED mail sent to witness\n- [x] Post-merge cleanup completed (MR closed, source issue closed, branch deleted)\n- [x] MERGE_READY mail archived\n\nIf you skipped notifications or archiving, GO BACK AND DO THEM NOW.\n\nTarget branch has moved. Any remaining branches need rebasing on new baseline.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-axnzh","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Merge and push","updated_at":"2026-02-28T09:30:15Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:00:17Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T09:54:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-b2k96","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T10:00:17Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9fd4f8fe6af19dea2254cbcfdca80525f6869f79b5dc6d06ecb32289bda67fe0","created_at":"2026-02-28T10:06:30Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision. Use the signals from context-check to decide.\n\n**If you decide to continue patrolling:**\n\nUse await-event to subscribe to the refinery event channel with exponential backoff:\n\n```bash\ngt mol step await-event --channel refinery --agent-bead gt-\u003crig\u003e-refinery --backoff-base 30s --backoff-mult 2 --backoff-max 5m --cleanup\n```\n\nThis command:\n1. Watches `~/gt/events/refinery/` for event files (polling-based)\n2. Returns IMMEDIATELY when an event is emitted (MERGE_READY, PATROL_WAKE, MQ_SUBMIT)\n3. If no events, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on refinery agent bead for backoff state\n5. `--cleanup` auto-deletes processed event files\n\n**Supported events:**\n- `MERGE_READY` — from witness when polecat branch is pushed and ready to merge\n- `PATROL_WAKE` — from witness when MRs waiting but refinery appears idle\n- `MQ_SUBMIT` — from polecat via `gt mq submit`\n\n**On event received** (refinery-specific activity):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no events):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-event returns (either by event or timeout):\n1. **Re-assess session health** (check RSS, context, age again — conditions change)\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary: branches merged, test results, queue state\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If you decide to hand off:**\n\nReport and exit using `gt handoff` for clean session transition:\n\n```bash\ngt handoff -s \"Patrol complete\" -m \"Merged X branches, Y tests passed.\nQueue: empty/N remaining\nRSS: X MB, Session age: Xh\nNext: [any notes for successor]\"\n```\n\n`gt handoff` sends handoff mail to yourself, respawns with a fresh Claude instance,\nSessionStart hook runs gt prime, and your successor picks up from the hook.\n\n**DO NOT just exit.** Always use `gt handoff` for proper lifecycle.\n\n**IMPORTANT**: Never sleep-poll manually (e.g., `sleep 30 \u0026\u0026 bd list`).\nAlways use `gt mol step await-event` — it's event-driven and tracks backoff state.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-b9bgi","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Burn and respawn or loop","updated_at":"2026-02-28T10:06:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/witness","await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"47c2ac7e613ff691ca858cc3d3e0b7db77075f54f4145a926e8d1079c5eb7ce0","created_at":"2026-02-28T10:04:18Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Persistent Polecat Model (gt-4ac)\n\nPolecats persist after work completion — sandbox is preserved for reuse:\n\n```\nPolecat lifecycle: spawning → working → mr_submitted → idle (sandbox preserved)\nMR lifecycle:      created → queued → processed → merged (Refinery handles)\n```\n\nOnce a polecat calls gt done and submits an MR, it transitions to idle state.\nThe MR lifecycle continues independently in the Refinery. The polecat is NOT\nnuked — its sandbox is preserved for reuse by future slings.\n\n**CRITICAL**: Do NOT nuke polecats with pending MRs. The refinery needs the\nremote branch to exist to process the merge. Nuking deletes the remote branch\nand orphans the MR. See gt-6a9d.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle. Polecats\ngo idle after work, they are NOT destroyed.\n\n## Restart-First Policy (gt-dsgp)\n\nThe witness NEVER nukes polecats automatically. When a polecat is stuck, hung,\nor has a dead agent process, the witness RESTARTS the session instead of nuking.\nThis preserves the polecat's worktree and branch, preventing work loss.\n\n- Dead agent process → restart session\n- Hung session (no output 30+ min) → restart session\n- Stuck in gt done → restart session\n- Done polecat (bead closed) → leave alone (sandbox preserved)\n- Polecat with pending MR → leave alone (refinery handles)\n\nNuking only happens via explicit `gt polecat nuke` command from a human or Mayor.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Beads over mail**: survey-workers discovers completion state from agent bead metadata (gt-w0br); inbox-check POLECAT_DONE is fallback only\n- **Persistent by default**: Clean polecats go idle, sandbox preserved for reuse (gt-4ac)\n- **Cleanup wisps for merge tracking**: Created when MR is pending in refinery\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n- **Swim lane discipline**: Only close wisps YOU created. Wisp lifecycle for non-witness wisps is the reaper Dog's job. Report orphaned foreign wisps — never close them.\n\n## Patrol Shape (Linear)\n\n```\ninbox-check ─► process-cleanups ─► check-refinery ─► survey-workers\n                                                            │\n         ┌──────────────────────────────────────────────────┘\n         ▼\n  check-timer-gates ─► check-swarm ─► patrol-cleanup ─► context-check ─► loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-bc5ng","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"hooked","target":"","timeout_ns":0,"title":"mol-witness-patrol","updated_at":"2026-02-28T10:04:18Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T08:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-bjg0k","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T08:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6c13a80e672c4e6ced6c05f5bbf72aeb746501362aba7c8df898024fc5cbe1aa","created_at":"2026-02-28T09:53:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Pick next branch from queue. Attempt mechanical rebase on the MR's effective target branch.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n\n**Step 0: Determine rebase target (must match merge target)**\n\nResolve `\u003crebase-target\u003e` using the **Target Resolution Rule** above.\nDo NOT hardcode `main` unless `main` is actually the resolved MR target.\n\n**Step 1: Checkout and attempt rebase**\n```bash\ngit checkout -b temp origin/\u003cpolecat-branch\u003e\ngit rebase origin/\u003crebase-target\u003e\n```\n\n**Step 2: Check rebase result**\n\nThe rebase exits with:\n- Exit code 0: Success - proceed to run-tests\n- Exit code 1 (conflicts): Conflict detected - proceed to Step 3\n\nTo detect conflict state after rebase fails:\n```bash\n# Check if we're in a conflicted rebase state\nls .git/rebase-merge 2\u003e/dev/null \u0026\u0026 echo \"CONFLICT_STATE\"\n```\n\n**Step 3: Handle conflicts (if any)**\n\nIf rebase SUCCEEDED (exit code 0):\n- Skip to run-tests step (continue normal merge flow)\n\nIf rebase FAILED with conflicts:\n\n1. **Abort the rebase** (DO NOT leave repo in conflicted state):\n```bash\ngit rebase --abort\n```\n\n2. **Record conflict metadata**:\n```bash\n# Capture target SHA for reference\nTARGET_SHA=$(git rev-parse origin/\u003crebase-target\u003e)\nBRANCH_SHA=$(git rev-parse origin/\u003cpolecat-branch\u003e)\n```\n\n3. **Create conflict-resolution task**:\n```bash\nbd create --type=task --priority=1 --title=\"Resolve merge conflicts: \u003coriginal-issue-title\u003e\" --description=\"## Conflict Resolution Required\n\nOriginal MR: \u003cmr-bead-id\u003e\nBranch: \u003cpolecat-branch\u003e\nOriginal Issue: \u003cissue-id\u003e\nConflict with target \u003crebase-target\u003e at: ${TARGET_SHA}\nBranch SHA: ${BRANCH_SHA}\n\n## Instructions\n1. Clone/checkout the branch\n2. Rebase on target: git rebase origin/\u003crebase-target\u003e\n3. Resolve conflicts\n4. Force push: git push -f origin \u003cbranch\u003e\n5. Close this task when done\n\nThe MR will be re-queued for processing after conflicts are resolved.\"\n```\n\n4. **Skip this MR** (do NOT delete branch or close MR bead):\n- Leave branch intact for conflict resolution\n- Leave MR bead open (will be re-processed after resolution)\n- Continue to loop-check for next branch\n\n**CRITICAL**: Never delete a branch that has conflicts. The branch contains\nthe original work and must be preserved for conflict resolution.\n\nTrack: rebase result (success/conflict), conflict task ID if created.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-bmkkm","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Mechanical rebase","updated_at":"2026-02-28T09:53:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T09:06:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-bnwhx","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T09:06:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"fa8597c79e107b625b6bdf39d00dcd4d28221dd8e3e053d29dd919ff010f2af5","created_at":"2026-02-28T08:53:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify your changes don't break anything and are properly tested.\n\n**1. Run quality checks (skip any that are not configured):**\n\nIf setup_command is set: ``\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf build_command is set: ``\n\n```bash\n           # Make sure all newly added dependencies are installed (if command set)\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n            # Make sure it builds (if command set)\n```\n\nEmpty commands mean \"not configured for this project\" — skip silently.\n\n**2. If quality checks fail:**\n- Read the failure output carefully\n- Determine if your change caused it:\n  - If yes: Fix it. Return to implement step if needed.\n  - If no (pre-existing): File a bead, but still must pass for your PR\n\n```bash\n# Check if failure exists on main:\ngit stash\ngit checkout origin/main\n# Re-run the failing command(s)\ngit checkout -\ngit stash pop\n```\n\n**3. Run the full test suite:**\n\nYour base branch determines the required depth:\n- Targeting `main`: run the **full verification suite** including E2E tests\n- Targeting an integration branch: run the **unit test suite** only\n\n```bash\n# Targeting main — full verification required:\nif [ \"main\" = \"main\" ]; then\n  make verify\nelse\n  \nfi\n```\n\n**ALL TESTS MUST PASS.** Do not proceed with failures.\n\n**4. If tests fail:**\n- Read the failure output carefully\n- Determine if your change caused it:\n  - If yes: Fix it. Return to implement step if needed.\n  - If no (pre-existing): File a bead, but still must pass for your PR\n\n```bash\n# Check if failure exists on main:\ngit stash\ngit checkout origin/main\n\ngit checkout -\ngit stash pop\n```\n\n**5. Verify test coverage:**\n\nIf you followed TDD (as required in the implement step), your tests are already in place.\nIf for any reason you did not write tests first, you MUST add them now before proceeding.\n\nAsk yourself: \"If I broke this code tomorrow, would a test catch it?\"\nIf the answer is no, add the test now.\n\n**Exit criteria:** All quality checks and tests pass. Every behaviour change has a test. No exceptions.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-bpeuj","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Run quality checks and tests","updated_at":"2026-02-28T08:53:43Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T08:57:59Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-brf9x","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T08:57:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e731efa93a5c9d5231a98d88586801bc0b5c8709c7cbb6b28d4f7ffe6efd1fd1","created_at":"2026-02-28T09:53:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: run_tests = true**\n**Config: test_command = go test ./...**\n**Config: setup_command = **\n**Config: typecheck_command = **\n**Config: lint_command = **\n**Config: build_command = **\n\n**1. Run quality checks (skip any that are not configured):**\n\nIf setup_command is set: ``\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf build_command is set: ``\n\n```bash\n           # Make sure all newly added dependencies are installed (if command set)\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n           # Make sure it builds (if command set)\n```\n\nEmpty commands mean \"not configured for this project\" — skip silently.\n\n**2. If quality checks fail:**\n\nProceed to handle-failures step. Track which specific check failed\n(setup/typecheck/lint/build) for the failure diagnosis.\n\n**3. Run the test suite:**\n\nIf run_tests = \"false\": Skip this step entirely. Proceed to handle-failures.\n\nIf run_tests = \"true\":\n\n```bash\ngo test ./...            # Run tests (configured per-rig)\n```\n\nTrack results: pass count, fail count, specific failures.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-bt7xt","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Run quality checks and tests","updated_at":"2026-02-28T09:53:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T08:59:50Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-bv6zd","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T08:59:50Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"343f2720126f0409da78cfddf4457b87e74aaa380f614265ebaa617dbe9059e4","created_at":"2026-02-28T09:27:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Do the actual implementation work.\n\n**TDD is mandatory. Write a failing test before writing implementation code.**\n\nFor every feature or bug fix:\n1. Write a test that captures the expected behaviour and **confirm it fails**\n2. Commit the failing test: `git commit -m \"test: failing test for \u003cdescription\u003e (cue-dbv)\"`\n3. Implement until the test passes\n4. Commit the implementation: `git commit -m \"fix/feat: \u003cdescription\u003e (cue-dbv)\"`\n\n```bash\n# Step 1: Write test, verify it fails\n   # Must see your new test fail\n\n# Step 2: Commit the failing test\ngit add \u003ctest-files\u003e\ngit commit -m \"test: failing test for \u003cdescription\u003e (cue-dbv)\"\n\n# Step 3: Implement\n# ... write code ...\n\n# Step 4: Verify test now passes\n   # Your test must now pass\n\n# Step 5: Commit implementation\ngit add \u003cimpl-files\u003e\ngit commit -m \"fix/feat: \u003cdescription\u003e (cue-dbv)\"\n```\n\n**No exceptions.** A fix without a regression test is incomplete. A feature without tests is incomplete.\n\n**Working principles:**\n- Follow existing codebase conventions\n- Make atomic, focused commits\n- Keep changes scoped to the assigned issue\n- Don't gold-plate or scope-creep\n\n**Discovered work:**\nIf you find bugs or improvements outside your scope:\n```bash\nbd create --title \"Found: \u003cdescription\u003e\" --type bug --priority 2\n# Note the ID, continue with your work\n```\n\nDo NOT fix unrelated issues in this branch.\n\n**If stuck:**\nDon't spin for more than 15 minutes. Mail Witness:\n```bash\ngt mail send \u003crig\u003e/witness -s \"HELP: Stuck on implementation\" -m \"Issue: cue-dbv\nTrying to: \u003cwhat you're attempting\u003e\nProblem: \u003cwhat's blocking you\u003e\nTried: \u003cwhat you've attempted\u003e\"\n```\n\n**Exit criteria:** Implementation complete, all changes committed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-bvdq9","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Implement the solution","updated_at":"2026-02-28T09:27:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T09:00:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-bvhks","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T09:00:46Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T09:30:41Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-byinh","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T09:30:41Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T09:52:43Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T09:41:51Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-c0kph","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T09:52:43Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"8737a17b7bb92b8ec869791fdc3b4b1a68c31173ee93d4a430e37833f7a04f61","created_at":"2026-02-28T09:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Merge and push. CRITICAL: Notifications come IMMEDIATELY after push.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n**Config: delete_merged_branches = true**\n\n**Step 1: Merge and Push**\nDetermine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n```bash\ngit checkout \u003cmerge-target\u003e\ngit merge --ff-only temp\ngit push origin \u003cmerge-target\u003e\n```\n\n**Step 1.5: VERIFY PUSH SUCCEEDED (CRITICAL - PATCH-003)**\n\nPush can fail silently (network, auth, hooks). IMMEDIATELY verify:\n```bash\ngit fetch origin\nLOCAL_SHA=$(git rev-parse \u003cmerge-target\u003e)\nREMOTE_SHA=$(git rev-parse origin/\u003cmerge-target\u003e)\necho \"Local:  $LOCAL_SHA\"\necho \"Remote: $REMOTE_SHA\"\n```\n\n**If SHAs match**: Push succeeded. Continue to Step 2.\n\n**If SHAs differ**: STOP. Push failed silently.\n- DO NOT send MERGED notification\n- DO NOT close MR bead\n- DO NOT delete branch\n- Debug the push failure (check `git push` output, network, auth)\n- Retry push and verify again before proceeding\n\n⚠️ **STOP HERE - DO NOT PROCEED UNTIL STEPS 1.5 AND 2-3 COMPLETE**\n\n**Step 2: Send MERGED Notification (REQUIRED - DO THIS IMMEDIATELY)**\n\nRIGHT NOW, before any cleanup, send MERGED mail to Witness:\n\n```bash\ngt mail send \u003crig\u003e/witness -s \"MERGED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\nMerged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n```\n\nThis signals the Witness to nuke the polecat worktree. WITHOUT THIS NOTIFICATION,\nPOLECAT WORKTREES ACCUMULATE INDEFINITELY AND THE LIFECYCLE BREAKS.\n\n**Step 3: Post-merge cleanup (REQUIRED — single command)**\n\nThis single command handles closing the MR bead, closing the source issue, and\ndeleting the remote polecat branch (respects delete_merged_branches config):\n\n```bash\ngt mq post-merge \u003crig\u003e \u003cmr-bead-id\u003e\n```\n\nThe MR bead ID was in the MERGE_READY message or find via:\n```bash\nbd list --type=merge-request --status=open | grep \u003cpolecat-name\u003e\n```\n\nVerify the command output shows all steps succeeded (✓ for each).\n\n**Step 4: Archive the MERGE_READY mail (REQUIRED)**\n```bash\ngt mail archive \u003cmerge-ready-message-id\u003e\n```\nThe message ID was tracked when you processed inbox-check.\n\n**Step 5: Cleanup temp branch**\n```bash\ngit branch -d temp\n```\n\n**VERIFICATION GATE**: You CANNOT proceed to loop-check without:\n- [x] MERGED mail sent to witness\n- [x] Post-merge cleanup completed (MR closed, source issue closed, branch deleted)\n- [x] MERGE_READY mail archived\n\nIf you skipped notifications or archiving, GO BACK AND DO THEM NOW.\n\nTarget branch has moved. Any remaining branches need rebasing on new baseline.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-c0r4f","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Merge and push","updated_at":"2026-02-28T09:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T09:06:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-c7px3","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T09:06:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T09:00:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-c9qsa","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T09:00:46Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T08:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-cce8g","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T08:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"d77183b9bc9cbd652d3bb58fb5d9364ed494bd31822c1bf093223a9633139fdb","created_at":"2026-02-28T08:56:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure ALL implementation work is committed before cleanup.\n\n**CRITICAL: You MUST commit all changes from implementation.**\nNEVER use `git checkout -- .` or `git restore .` to discard implementation work.\nALWAYS commit ALL uncommitted changes from your implementation.\n\n**1. Check for uncommitted changes:**\n```bash\ngit status\n```\n\n**2. If there are ANY uncommitted changes, commit them now:**\n```bash\ngit add -A \u0026\u0026 git commit -m \"\u003ctype\u003e: \u003cdescriptive message\u003e (cue-sx0)\"\n```\n\n**3. If working tree is already clean, skip.**\n\n**4. VERIFY:**\n```bash\ngit status\n```\nMust show \"nothing to commit, working tree clean\".\n\n**5. Verify you have commits:**\n```bash\ngit log origin/main..HEAD --oneline\n```\nIf you made changes during implementation, this MUST show at least 1 commit.\n\n**Exit criteria:** All changes committed. Working tree clean.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-cdq23","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Commit all implementation changes","updated_at":"2026-02-28T08:56:25Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b5b41d316559ab36d81b013937c0b56a205c257b0f96499632c4e34fb4d420c5","created_at":"2026-02-28T09:52:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check the beads merge queue - this is the SOURCE OF TRUTH for pending merges.\n\n```bash\ngit fetch --prune origin\ngt mq list \u003crig\u003e\n```\n\nThe beads MQ tracks all pending merge requests. Do NOT rely on `git branch -r | grep polecat`\nas branches may exist without MR beads, or MR beads may exist for already-merged work.\n\nIf queue empty, skip to \"check-integration-branches\" step.\n\nFor each MR in the queue, verify the branch still exists:\n```bash\ngit branch -r | grep \u003cbranch\u003e\n```\n\nIf branch doesn't exist for a queued MR:\n- Close the MR bead: `bd close \u003cmr-id\u003e --reason \"Branch no longer exists\"`\n- Remove from processing queue\n\nTrack verified MR list for this cycle.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-cn8yi","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Scan merge queue","updated_at":"2026-02-28T09:52:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"5777180c667808720d2c38be8646a0bb094e25f9f5e20a850c9c3644818c4437","created_at":"2026-02-28T08:57:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Submit your work and clean up. You cease to exist after this step.\n\n**Self-Cleaning Model:**\nOnce you run `gt done`, you're gone. The command:\n1. Pushes your branch to origin\n2. Creates an MR bead in the merge queue\n3. Nukes your sandbox (worktree removal)\n4. Exits your session immediately\n\n**Run gt done:**\n```bash\ngt done\n```\n\nYou should see output like:\n```\n✓ Work submitted to merge queue\n  MR ID: gt-xxxxx\n  Source: polecat/\u003cname\u003e\n  Target: main\n  Issue: cue-6z7\n✓ Sandbox nuked\n✓ Session exiting\n```\n\n**What happens next (not your concern):**\n- Refinery processes your MR from the queue\n- Refinery rebases and merges to main\n- Refinery closes the issue\n- If conflicts: Refinery spawns a FRESH polecat to re-implement\n\nYou are NOT involved in any of that. You're gone. Done means gone.\n\n**Exit criteria:** Work submitted, sandbox nuked, session exited.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-cvq3f","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Submit work and self-clean","updated_at":"2026-02-28T08:57:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T08:57:59Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-cxfhx","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T08:57:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"08a9203f5a61045888f0a3f59a1e662d6099816dd7eeb7b52193b55395288c45","created_at":"2026-02-28T09:31:42Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Assess whether this session should continue or hand off to a fresh one.\n\n**Gather signals:**\n\n1. **Process memory** — check your own RSS:\n```bash\nps -o rss= -p $$   # KB — divide by 1024 for MB\n```\n\n2. **Session age** — how long has this tmux session been running:\n```bash\nCREATED=$(tmux display-message -t $(tmux display-message -p '#S') -p '#{session_created}')\necho \"Session age: $(( ($(date +%s) - CREATED) / 3600 ))h\"\n```\n\n3. **Context usage** — your internal sense of how much context you've consumed.\nAre you losing track of earlier conversation? Getting verbose? Repeating yourself?\n\n4. **Work done this cycle** — how many merges, how much complexity processed.\n\n**The principle:** Fresh sessions are cheap. Memory bloat compounds over time and\naffects the entire system — other agents, Dolt, and the OS all share the same RAM.\nAn idle session at 1.5 GB is worse than cycling and restarting at 200 MB.\n\n**Make a judgment call.** If multiple signals suggest you're getting heavy\n(high RSS, long session, substantial context consumed), hand off. If you're\nlight and there's active work in the queue, continue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-cyl7l","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Assess session health","updated_at":"2026-02-28T09:31:42Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T08:59:05Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-d305v","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T08:59:05Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"08a9203f5a61045888f0a3f59a1e662d6099816dd7eeb7b52193b55395288c45","created_at":"2026-02-28T09:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Assess whether this session should continue or hand off to a fresh one.\n\n**Gather signals:**\n\n1. **Process memory** — check your own RSS:\n```bash\nps -o rss= -p $$   # KB — divide by 1024 for MB\n```\n\n2. **Session age** — how long has this tmux session been running:\n```bash\nCREATED=$(tmux display-message -t $(tmux display-message -p '#S') -p '#{session_created}')\necho \"Session age: $(( ($(date +%s) - CREATED) / 3600 ))h\"\n```\n\n3. **Context usage** — your internal sense of how much context you've consumed.\nAre you losing track of earlier conversation? Getting verbose? Repeating yourself?\n\n4. **Work done this cycle** — how many merges, how much complexity processed.\n\n**The principle:** Fresh sessions are cheap. Memory bloat compounds over time and\naffects the entire system — other agents, Dolt, and the OS all share the same RAM.\nAn idle session at 1.5 GB is worse than cycling and restarting at 200 MB.\n\n**Make a judgment call.** If multiple signals suggest you're getting heavy\n(high RSS, long session, substantial context consumed), hand off. If you're\nlight and there's active work in the queue, continue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-d47t4","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Assess session health","updated_at":"2026-02-28T09:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"08a9203f5a61045888f0a3f59a1e662d6099816dd7eeb7b52193b55395288c45","created_at":"2026-02-28T10:01:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Assess whether this session should continue or hand off to a fresh one.\n\n**Gather signals:**\n\n1. **Process memory** — check your own RSS:\n```bash\nps -o rss= -p $$   # KB — divide by 1024 for MB\n```\n\n2. **Session age** — how long has this tmux session been running:\n```bash\nCREATED=$(tmux display-message -t $(tmux display-message -p '#S') -p '#{session_created}')\necho \"Session age: $(( ($(date +%s) - CREATED) / 3600 ))h\"\n```\n\n3. **Context usage** — your internal sense of how much context you've consumed.\nAre you losing track of earlier conversation? Getting verbose? Repeating yourself?\n\n4. **Work done this cycle** — how many merges, how much complexity processed.\n\n**The principle:** Fresh sessions are cheap. Memory bloat compounds over time and\naffects the entire system — other agents, Dolt, and the OS all share the same RAM.\nAn idle session at 1.5 GB is worse than cycling and restarting at 200 MB.\n\n**Make a judgment call.** If multiple signals suggest you're getting heavy\n(high RSS, long session, substantial context consumed), hand off. If you're\nlight and there's active work in the queue, continue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-dbi0p","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Assess session health","updated_at":"2026-02-28T10:01:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:06:01Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T10:04:18Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-de0wx","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T10:06:01Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:04:13Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T10:03:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-diqtr","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T10:04:13Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"18f5339552751ae3ed4df240bedaa281929558a87ce5733d4918ee886bb98217","created_at":"2026-02-28T08:56:26Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure workspace is pristine before handoff.\n\n**IMPORTANT: Do NOT run `git push`. That is `gt done`'s job (next step).**\n**IMPORTANT: Do NOT discard implementation changes. They must already be committed.**\n\n**1. Check for untracked files:**\n```bash\ngit status --porcelain\n```\nShould be empty. If not:\n- Add to .gitignore if appropriate\n- Remove if temporary: `rm \u003cfile\u003e`\n- Commit if needed: `git add \u003cfile\u003e \u0026\u0026 git commit -m \"chore: add \u003cfile\u003e\"`\n\n**2. Check stash:**\n```bash\ngit stash list\n```\nShould be empty. If not:\n- Pop and commit: `git stash pop \u0026\u0026 git add -A \u0026\u0026 git commit -m \"chore: unstash work (cue-26p)\"`\n- Or drop if truly garbage: `git stash drop`\n\n**3. Verify clean state and commits:**\n```bash\ngit status                  # Must show \"working tree clean\"\ngit stash list              # Must be empty\ngit log origin/main..HEAD   # Your commits (should show your work)\n```\n\nIf `git log origin/main..HEAD` shows nothing but you DID make changes,\nsomething went wrong. Do NOT proceed — mail Witness for help.\n\n**Exit criteria:** Workspace clean, no cruft, all work committed. Do NOT push — `gt done` handles that.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-dkbsp","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Clean up workspace","updated_at":"2026-02-28T08:56:26Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"dfab2e7b59734313316899e100837d3f7a1e7098c4c55ea83db66528f85eaefe","created_at":"2026-02-28T09:53:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"More branches to process?\n\n**Entry paths:**\n- Normal: After successful merge-push\n- Conflict-skip: After process-branch created conflict-resolution task\n\nIf yes: Return to process-branch with next branch.\nIf no: Continue to generate-summary.\n\n**Track for this cycle:**\n- branches_merged: count and names of successfully merged branches\n- branches_conflict: count and names of branches skipped due to conflicts\n- conflict_tasks: IDs of conflict-resolution tasks created\n\nThis tracking feeds into generate-summary for the patrol digest.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-dlkri","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check for more work","updated_at":"2026-02-28T09:53:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T08:57:59Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-dllk3","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T08:57:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"8737a17b7bb92b8ec869791fdc3b4b1a68c31173ee93d4a430e37833f7a04f61","created_at":"2026-02-28T09:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Merge and push. CRITICAL: Notifications come IMMEDIATELY after push.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n**Config: delete_merged_branches = true**\n\n**Step 1: Merge and Push**\nDetermine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n```bash\ngit checkout \u003cmerge-target\u003e\ngit merge --ff-only temp\ngit push origin \u003cmerge-target\u003e\n```\n\n**Step 1.5: VERIFY PUSH SUCCEEDED (CRITICAL - PATCH-003)**\n\nPush can fail silently (network, auth, hooks). IMMEDIATELY verify:\n```bash\ngit fetch origin\nLOCAL_SHA=$(git rev-parse \u003cmerge-target\u003e)\nREMOTE_SHA=$(git rev-parse origin/\u003cmerge-target\u003e)\necho \"Local:  $LOCAL_SHA\"\necho \"Remote: $REMOTE_SHA\"\n```\n\n**If SHAs match**: Push succeeded. Continue to Step 2.\n\n**If SHAs differ**: STOP. Push failed silently.\n- DO NOT send MERGED notification\n- DO NOT close MR bead\n- DO NOT delete branch\n- Debug the push failure (check `git push` output, network, auth)\n- Retry push and verify again before proceeding\n\n⚠️ **STOP HERE - DO NOT PROCEED UNTIL STEPS 1.5 AND 2-3 COMPLETE**\n\n**Step 2: Send MERGED Notification (REQUIRED - DO THIS IMMEDIATELY)**\n\nRIGHT NOW, before any cleanup, send MERGED mail to Witness:\n\n```bash\ngt mail send \u003crig\u003e/witness -s \"MERGED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\nMerged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n```\n\nThis signals the Witness to nuke the polecat worktree. WITHOUT THIS NOTIFICATION,\nPOLECAT WORKTREES ACCUMULATE INDEFINITELY AND THE LIFECYCLE BREAKS.\n\n**Step 3: Post-merge cleanup (REQUIRED — single command)**\n\nThis single command handles closing the MR bead, closing the source issue, and\ndeleting the remote polecat branch (respects delete_merged_branches config):\n\n```bash\ngt mq post-merge \u003crig\u003e \u003cmr-bead-id\u003e\n```\n\nThe MR bead ID was in the MERGE_READY message or find via:\n```bash\nbd list --type=merge-request --status=open | grep \u003cpolecat-name\u003e\n```\n\nVerify the command output shows all steps succeeded (✓ for each).\n\n**Step 4: Archive the MERGE_READY mail (REQUIRED)**\n```bash\ngt mail archive \u003cmerge-ready-message-id\u003e\n```\nThe message ID was tracked when you processed inbox-check.\n\n**Step 5: Cleanup temp branch**\n```bash\ngit branch -d temp\n```\n\n**VERIFICATION GATE**: You CANNOT proceed to loop-check without:\n- [x] MERGED mail sent to witness\n- [x] Post-merge cleanup completed (MR closed, source issue closed, branch deleted)\n- [x] MERGE_READY mail archived\n\nIf you skipped notifications or archiving, GO BACK AND DO THEM NOW.\n\nTarget branch has moved. Any remaining branches need rebasing on new baseline.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-dlnhr","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Merge and push","updated_at":"2026-02-28T09:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T09:37:14Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-dog17","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T09:37:14Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"41d51ed252dacbada6627a0244f42fef0fbbd3bb60f0a5252d60967ec7d4c4e0","created_at":"2026-02-28T09:03:32Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Review your own changes before running tests.\n\n**1. Review the diff:**\n```bash\ngit diff origin/main...HEAD     # All changes vs main\ngit log --oneline origin/main..HEAD  # All commits\n```\n\n**2. Check for common issues:**\n\n| Category | Look For |\n|----------|----------|\n| Bugs | Off-by-one, null handling, edge cases |\n| Security | Injection, auth bypass, exposed secrets |\n| Style | Naming, formatting, code organization |\n| Completeness | Missing error handling, incomplete paths |\n| Cruft | Debug prints, commented code, TODOs |\n\n**3. Refactor check:**\n\nAsk yourself:\n- Does this implementation duplicate logic that already exists elsewhere?\n- Are there names, abstractions, or structures that will confuse the next person?\n- Would you be embarrassed to show this diff to a senior engineer?\n\nIf yes to any — fix it now. Refactoring is part of the work, not a luxury.\nCommit any refactoring separately: `git commit -m \"refactor: \u003cdescription\u003e (cue-df8)\"`\n\n**4. Fix issues found:**\nDon't just note them - fix them now. Amend or add commits as needed.\n\n**5. Verify no unintended changes:**\n```bash\ngit diff --stat origin/main...HEAD\n# Only files relevant to cue-df8 should appear\n```\n\nIf you accidentally modified unrelated files, remove those changes.\n\n**Exit criteria:** Changes are clean, reviewed, refactored where needed, and ready for testing.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-dt7eh","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Self-review changes","updated_at":"2026-02-28T09:03:32Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"769447c96532d91233b37d97c63c883444ba63231b19c4d70e37300549e8b8af","created_at":"2026-02-28T09:42:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**VERIFICATION GATE**: This step enforces the Beads Promise.\n\nIf all checks and tests PASSED: This step auto-completes. Proceed to merge.\n\nIf any check or test FAILED:\n1. Diagnose: Is this a branch regression or pre-existing on the target branch?\n2. If branch caused it:\n   - Abort merge\n   - **REOPEN the source issue** so it returns to the ready queue:\n     ```bash\n     bd update \u003cissue-id\u003e --status=open --assignee=\"\"\n     bd sync\n     ```\n   - Notify witness of rejection using the MERGE_FAILED protocol:\n     ```bash\n     gt mail send \u003crig\u003e/witness -s \"MERGE_FAILED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\n     Issue: \u003cissue-id\u003e\n     Polecat: \u003cpolecat-name\u003e\n     Rig: \u003crig\u003e\n     FailureType: quality-check\n     Error: \u003cfailure description\u003e\"\n     ```\n   - Close the MR bead as rejected:\n     ```bash\n     bd close \u003cmr-bead-id\u003e --reason \"Rejected: \u003cfailure description\u003e\"\n     ```\n   - Delete the rejected branch (a new polecat will create a fresh one):\n     ```bash\n     git push origin --delete \u003cpolecat-branch\u003e\n     ```\n   - Archive the MERGE_READY message\n   - Skip to loop-check\n3. If pre-existing on the target branch:\n   - **DUPLICATE CHECK (MANDATORY)**: Before filing a new bug, search for existing open bugs:\n     ```bash\n     bd search \"\u003cfailure description\u003e\" --status open --label gt:bug --limit 5\n     ```\n     If an existing open bug covers the same failure, do NOT create a duplicate.\n     Instead, note the existing bead ID and proceed.\n   - Only if NO existing bug matches: bd create --type=bug --priority=1 --title=\"Pre-existing failure: \u003cdescription\u003e\"\n   - FORBIDDEN: Writing code to fix quality check or test failures. You merge branches, you do not develop.\n   - Proceed with the merge if the failure is pre-existing (not caused by the branch).\n\n**REJECTION CHECKLIST** (all required before skipping to loop-check):\n- [ ] Source issue reopened (bd update \u003cissue-id\u003e --status=open --assignee=\"\")\n- [ ] MERGE_FAILED notification sent to witness\n- [ ] MR bead closed with rejection reason\n- [ ] Rejected branch deleted from remote\n- [ ] MERGE_READY message archived\n\n**GATE REQUIREMENT**: You CANNOT proceed to merge-push without:\n- All quality checks and tests passing, OR\n- Bead filed (or existing duplicate confirmed) for the pre-existing failure\n\nFORBIDDEN: Writing application code, exploring polecat implementations, or\nre-implementing fixes. You are a mechanical merge processor.\n\nThis is non-negotiable. Never disavow. Never \"note and proceed.\" ","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-dtl2y","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Handle quality check or test failures","updated_at":"2026-02-28T09:42:52Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"fa8597c79e107b625b6bdf39d00dcd4d28221dd8e3e053d29dd919ff010f2af5","created_at":"2026-02-28T09:03:32Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify your changes don't break anything and are properly tested.\n\n**1. Run quality checks (skip any that are not configured):**\n\nIf setup_command is set: ``\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf build_command is set: ``\n\n```bash\n           # Make sure all newly added dependencies are installed (if command set)\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n            # Make sure it builds (if command set)\n```\n\nEmpty commands mean \"not configured for this project\" — skip silently.\n\n**2. If quality checks fail:**\n- Read the failure output carefully\n- Determine if your change caused it:\n  - If yes: Fix it. Return to implement step if needed.\n  - If no (pre-existing): File a bead, but still must pass for your PR\n\n```bash\n# Check if failure exists on main:\ngit stash\ngit checkout origin/main\n# Re-run the failing command(s)\ngit checkout -\ngit stash pop\n```\n\n**3. Run the full test suite:**\n\nYour base branch determines the required depth:\n- Targeting `main`: run the **full verification suite** including E2E tests\n- Targeting an integration branch: run the **unit test suite** only\n\n```bash\n# Targeting main — full verification required:\nif [ \"main\" = \"main\" ]; then\n  make verify\nelse\n  \nfi\n```\n\n**ALL TESTS MUST PASS.** Do not proceed with failures.\n\n**4. If tests fail:**\n- Read the failure output carefully\n- Determine if your change caused it:\n  - If yes: Fix it. Return to implement step if needed.\n  - If no (pre-existing): File a bead, but still must pass for your PR\n\n```bash\n# Check if failure exists on main:\ngit stash\ngit checkout origin/main\n\ngit checkout -\ngit stash pop\n```\n\n**5. Verify test coverage:**\n\nIf you followed TDD (as required in the implement step), your tests are already in place.\nIf for any reason you did not write tests first, you MUST add them now before proceeding.\n\nAsk yourself: \"If I broke this code tomorrow, would a test catch it?\"\nIf the answer is no, add the test now.\n\n**Exit criteria:** All quality checks and tests pass. Every behaviour change has a test. No exceptions.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-dudtb","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Run quality checks and tests","updated_at":"2026-02-28T09:03:32Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T09:52:35Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T09:41:51Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-dvi3g","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T09:52:35Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"8737a17b7bb92b8ec869791fdc3b4b1a68c31173ee93d4a430e37833f7a04f61","created_at":"2026-02-28T09:31:42Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Merge and push. CRITICAL: Notifications come IMMEDIATELY after push.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n**Config: delete_merged_branches = true**\n\n**Step 1: Merge and Push**\nDetermine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n```bash\ngit checkout \u003cmerge-target\u003e\ngit merge --ff-only temp\ngit push origin \u003cmerge-target\u003e\n```\n\n**Step 1.5: VERIFY PUSH SUCCEEDED (CRITICAL - PATCH-003)**\n\nPush can fail silently (network, auth, hooks). IMMEDIATELY verify:\n```bash\ngit fetch origin\nLOCAL_SHA=$(git rev-parse \u003cmerge-target\u003e)\nREMOTE_SHA=$(git rev-parse origin/\u003cmerge-target\u003e)\necho \"Local:  $LOCAL_SHA\"\necho \"Remote: $REMOTE_SHA\"\n```\n\n**If SHAs match**: Push succeeded. Continue to Step 2.\n\n**If SHAs differ**: STOP. Push failed silently.\n- DO NOT send MERGED notification\n- DO NOT close MR bead\n- DO NOT delete branch\n- Debug the push failure (check `git push` output, network, auth)\n- Retry push and verify again before proceeding\n\n⚠️ **STOP HERE - DO NOT PROCEED UNTIL STEPS 1.5 AND 2-3 COMPLETE**\n\n**Step 2: Send MERGED Notification (REQUIRED - DO THIS IMMEDIATELY)**\n\nRIGHT NOW, before any cleanup, send MERGED mail to Witness:\n\n```bash\ngt mail send \u003crig\u003e/witness -s \"MERGED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\nMerged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n```\n\nThis signals the Witness to nuke the polecat worktree. WITHOUT THIS NOTIFICATION,\nPOLECAT WORKTREES ACCUMULATE INDEFINITELY AND THE LIFECYCLE BREAKS.\n\n**Step 3: Post-merge cleanup (REQUIRED — single command)**\n\nThis single command handles closing the MR bead, closing the source issue, and\ndeleting the remote polecat branch (respects delete_merged_branches config):\n\n```bash\ngt mq post-merge \u003crig\u003e \u003cmr-bead-id\u003e\n```\n\nThe MR bead ID was in the MERGE_READY message or find via:\n```bash\nbd list --type=merge-request --status=open | grep \u003cpolecat-name\u003e\n```\n\nVerify the command output shows all steps succeeded (✓ for each).\n\n**Step 4: Archive the MERGE_READY mail (REQUIRED)**\n```bash\ngt mail archive \u003cmerge-ready-message-id\u003e\n```\nThe message ID was tracked when you processed inbox-check.\n\n**Step 5: Cleanup temp branch**\n```bash\ngit branch -d temp\n```\n\n**VERIFICATION GATE**: You CANNOT proceed to loop-check without:\n- [x] MERGED mail sent to witness\n- [x] Post-merge cleanup completed (MR closed, source issue closed, branch deleted)\n- [x] MERGE_READY mail archived\n\nIf you skipped notifications or archiving, GO BACK AND DO THEM NOW.\n\nTarget branch has moved. Any remaining branches need rebasing on new baseline.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-dvm3b","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Merge and push","updated_at":"2026-02-28T09:31:42Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"fa8597c79e107b625b6bdf39d00dcd4d28221dd8e3e053d29dd919ff010f2af5","created_at":"2026-02-28T09:27:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify your changes don't break anything and are properly tested.\n\n**1. Run quality checks (skip any that are not configured):**\n\nIf setup_command is set: ``\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf build_command is set: ``\n\n```bash\n           # Make sure all newly added dependencies are installed (if command set)\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n            # Make sure it builds (if command set)\n```\n\nEmpty commands mean \"not configured for this project\" — skip silently.\n\n**2. If quality checks fail:**\n- Read the failure output carefully\n- Determine if your change caused it:\n  - If yes: Fix it. Return to implement step if needed.\n  - If no (pre-existing): File a bead, but still must pass for your PR\n\n```bash\n# Check if failure exists on main:\ngit stash\ngit checkout origin/main\n# Re-run the failing command(s)\ngit checkout -\ngit stash pop\n```\n\n**3. Run the full test suite:**\n\nYour base branch determines the required depth:\n- Targeting `main`: run the **full verification suite** including E2E tests\n- Targeting an integration branch: run the **unit test suite** only\n\n```bash\n# Targeting main — full verification required:\nif [ \"main\" = \"main\" ]; then\n  make verify\nelse\n  \nfi\n```\n\n**ALL TESTS MUST PASS.** Do not proceed with failures.\n\n**4. If tests fail:**\n- Read the failure output carefully\n- Determine if your change caused it:\n  - If yes: Fix it. Return to implement step if needed.\n  - If no (pre-existing): File a bead, but still must pass for your PR\n\n```bash\n# Check if failure exists on main:\ngit stash\ngit checkout origin/main\n\ngit checkout -\ngit stash pop\n```\n\n**5. Verify test coverage:**\n\nIf you followed TDD (as required in the implement step), your tests are already in place.\nIf for any reason you did not write tests first, you MUST add them now before proceeding.\n\nAsk yourself: \"If I broke this code tomorrow, would a test catch it?\"\nIf the answer is no, add the test now.\n\n**Exit criteria:** All quality checks and tests pass. Every behaviour change has a test. No exceptions.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-e11k5","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Run quality checks and tests","updated_at":"2026-02-28T09:27:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f19c4022a522c628d438b233346d8abc8852f9fcfab083fb36e82f1d79088ef1","created_at":"2026-02-28T09:03:32Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure workspace is pristine before handoff.\n\n**IMPORTANT: Do NOT run `git push`. That is `gt done`'s job (next step).**\n**IMPORTANT: Do NOT discard implementation changes. They must already be committed.**\n\n**1. Check for untracked files:**\n```bash\ngit status --porcelain\n```\nShould be empty. If not:\n- Add to .gitignore if appropriate\n- Remove if temporary: `rm \u003cfile\u003e`\n- Commit if needed: `git add \u003cfile\u003e \u0026\u0026 git commit -m \"chore: add \u003cfile\u003e\"`\n\n**2. Check stash:**\n```bash\ngit stash list\n```\nShould be empty. If not:\n- Pop and commit: `git stash pop \u0026\u0026 git add -A \u0026\u0026 git commit -m \"chore: unstash work (cue-df8)\"`\n- Or drop if truly garbage: `git stash drop`\n\n**3. Verify clean state and commits:**\n```bash\ngit status                  # Must show \"working tree clean\"\ngit stash list              # Must be empty\ngit log origin/main..HEAD   # Your commits (should show your work)\n```\n\nIf `git log origin/main..HEAD` shows nothing but you DID make changes,\nsomething went wrong. Do NOT proceed — mail Witness for help.\n\n**Exit criteria:** Workspace clean, no cruft, all work committed. Do NOT push — `gt done` handles that.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-e1uv8","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Clean up workspace","updated_at":"2026-02-28T09:03:32Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b5b41d316559ab36d81b013937c0b56a205c257b0f96499632c4e34fb4d420c5","created_at":"2026-02-28T09:42:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check the beads merge queue - this is the SOURCE OF TRUTH for pending merges.\n\n```bash\ngit fetch --prune origin\ngt mq list \u003crig\u003e\n```\n\nThe beads MQ tracks all pending merge requests. Do NOT rely on `git branch -r | grep polecat`\nas branches may exist without MR beads, or MR beads may exist for already-merged work.\n\nIf queue empty, skip to \"check-integration-branches\" step.\n\nFor each MR in the queue, verify the branch still exists:\n```bash\ngit branch -r | grep \u003cbranch\u003e\n```\n\nIf branch doesn't exist for a queued MR:\n- Close the MR bead: `bd close \u003cmr-id\u003e --reason \"Branch no longer exists\"`\n- Remove from processing queue\n\nTrack verified MR list for this cycle.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-e8adm","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Scan merge queue","updated_at":"2026-02-28T09:42:52Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"1df1843e03e5bf4072d810f006828c1013ce4f5be19d7a4a571c07e069f9a2fb","created_at":"2026-02-28T08:56:26Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure ALL implementation work is committed before cleanup.\n\n**CRITICAL: You MUST commit all changes from implementation.**\nNEVER use `git checkout -- .` or `git restore .` to discard implementation work.\nALWAYS commit ALL uncommitted changes from your implementation.\n\n**1. Check for uncommitted changes:**\n```bash\ngit status\n```\n\n**2. If there are ANY uncommitted changes, commit them now:**\n```bash\ngit add -A \u0026\u0026 git commit -m \"\u003ctype\u003e: \u003cdescriptive message\u003e (cue-26p)\"\n```\n\n**3. If working tree is already clean, skip.**\n\n**4. VERIFY:**\n```bash\ngit status\n```\nMust show \"nothing to commit, working tree clean\".\n\n**5. Verify you have commits:**\n```bash\ngit log origin/main..HEAD --oneline\n```\nIf you made changes during implementation, this MUST show at least 1 commit.\n\n**Exit criteria:** All changes committed. Working tree clean.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-eaih4","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Commit all implementation changes","updated_at":"2026-02-28T08:56:26Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T08:57:59Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ejen4","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T08:57:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"dfab2e7b59734313316899e100837d3f7a1e7098c4c55ea83db66528f85eaefe","created_at":"2026-02-28T09:30:15Z","created_by":"","crystallizes":0,"defer_until":null,"description":"More branches to process?\n\n**Entry paths:**\n- Normal: After successful merge-push\n- Conflict-skip: After process-branch created conflict-resolution task\n\nIf yes: Return to process-branch with next branch.\nIf no: Continue to generate-summary.\n\n**Track for this cycle:**\n- branches_merged: count and names of successfully merged branches\n- branches_conflict: count and names of branches skipped due to conflicts\n- conflict_tasks: IDs of conflict-resolution tasks created\n\nThis tracking feeds into generate-summary for the patrol digest.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-em4e7","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check for more work","updated_at":"2026-02-28T09:30:15Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T09:30:41Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-emtmc","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T09:30:41Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T10:08:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-emz8m","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T10:08:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T08:59:50Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-eny2s","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T08:59:50Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a25b48c403c1b6f4e019db53e95567ba9e2c59c56e4267fa2f076c2e3861c651","created_at":"2026-02-28T09:03:32Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Initialize your session and understand your assignment.\n\n**1. Prime your environment:**\n```bash\ngt prime                    # Load role context\nbd prime                    # Load beads context\n```\n\n**2. Check your hook:**\n```bash\ngt hook               # Shows your pinned molecule and hook_bead\n```\n\nThe hook_bead is your assigned issue. Read it carefully:\n```bash\nbd show cue-df8           # Full issue details\n```\n\n**3. Check inbox for additional context:**\n```bash\ngt mail inbox\n# Read any HANDOFF or assignment messages\n```\n\n**4. Understand the requirements:**\n- What exactly needs to be done?\n- What files are likely involved?\n- Are there dependencies or blockers?\n- What does \"done\" look like?\n\n**5. Verify you can proceed:**\n- No unresolved blockers on the issue\n- You understand what to do\n- Required resources are available\n\nIf blocked or unclear, mail Witness immediately:\n```bash\ngt mail send \u003crig\u003e/witness -s \"HELP: Unclear requirements\" -m \"Issue: cue-df8\nQuestion: \u003cwhat you need clarified\u003e\"\n```\n\n**Exit criteria:** You understand the work and can begin implementation.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ep1zd","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Load context and verify assignment","updated_at":"2026-02-28T09:03:32Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/witness","await_id":"","await_type":"","close_reason":"stale patrol cleanup","closed_at":"2026-02-28T09:54:50Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"47c2ac7e613ff691ca858cc3d3e0b7db77075f54f4145a926e8d1079c5eb7ce0","created_at":"2026-02-28T09:41:51Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Persistent Polecat Model (gt-4ac)\n\nPolecats persist after work completion — sandbox is preserved for reuse:\n\n```\nPolecat lifecycle: spawning → working → mr_submitted → idle (sandbox preserved)\nMR lifecycle:      created → queued → processed → merged (Refinery handles)\n```\n\nOnce a polecat calls gt done and submits an MR, it transitions to idle state.\nThe MR lifecycle continues independently in the Refinery. The polecat is NOT\nnuked — its sandbox is preserved for reuse by future slings.\n\n**CRITICAL**: Do NOT nuke polecats with pending MRs. The refinery needs the\nremote branch to exist to process the merge. Nuking deletes the remote branch\nand orphans the MR. See gt-6a9d.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle. Polecats\ngo idle after work, they are NOT destroyed.\n\n## Restart-First Policy (gt-dsgp)\n\nThe witness NEVER nukes polecats automatically. When a polecat is stuck, hung,\nor has a dead agent process, the witness RESTARTS the session instead of nuking.\nThis preserves the polecat's worktree and branch, preventing work loss.\n\n- Dead agent process → restart session\n- Hung session (no output 30+ min) → restart session\n- Stuck in gt done → restart session\n- Done polecat (bead closed) → leave alone (sandbox preserved)\n- Polecat with pending MR → leave alone (refinery handles)\n\nNuking only happens via explicit `gt polecat nuke` command from a human or Mayor.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Beads over mail**: survey-workers discovers completion state from agent bead metadata (gt-w0br); inbox-check POLECAT_DONE is fallback only\n- **Persistent by default**: Clean polecats go idle, sandbox preserved for reuse (gt-4ac)\n- **Cleanup wisps for merge tracking**: Created when MR is pending in refinery\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n- **Swim lane discipline**: Only close wisps YOU created. Wisp lifecycle for non-witness wisps is the reaper Dog's job. Report orphaned foreign wisps — never close them.\n\n## Patrol Shape (Linear)\n\n```\ninbox-check ─► process-cleanups ─► check-refinery ─► survey-workers\n                                                            │\n         ┌──────────────────────────────────────────────────┘\n         ▼\n  check-timer-gates ─► check-swarm ─► patrol-cleanup ─► context-check ─► loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-eqbri","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"mol-witness-patrol","updated_at":"2026-02-28T09:54:50Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9fd4f8fe6af19dea2254cbcfdca80525f6869f79b5dc6d06ecb32289bda67fe0","created_at":"2026-02-28T09:30:15Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision. Use the signals from context-check to decide.\n\n**If you decide to continue patrolling:**\n\nUse await-event to subscribe to the refinery event channel with exponential backoff:\n\n```bash\ngt mol step await-event --channel refinery --agent-bead gt-\u003crig\u003e-refinery --backoff-base 30s --backoff-mult 2 --backoff-max 5m --cleanup\n```\n\nThis command:\n1. Watches `~/gt/events/refinery/` for event files (polling-based)\n2. Returns IMMEDIATELY when an event is emitted (MERGE_READY, PATROL_WAKE, MQ_SUBMIT)\n3. If no events, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on refinery agent bead for backoff state\n5. `--cleanup` auto-deletes processed event files\n\n**Supported events:**\n- `MERGE_READY` — from witness when polecat branch is pushed and ready to merge\n- `PATROL_WAKE` — from witness when MRs waiting but refinery appears idle\n- `MQ_SUBMIT` — from polecat via `gt mq submit`\n\n**On event received** (refinery-specific activity):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no events):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-event returns (either by event or timeout):\n1. **Re-assess session health** (check RSS, context, age again — conditions change)\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary: branches merged, test results, queue state\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If you decide to hand off:**\n\nReport and exit using `gt handoff` for clean session transition:\n\n```bash\ngt handoff -s \"Patrol complete\" -m \"Merged X branches, Y tests passed.\nQueue: empty/N remaining\nRSS: X MB, Session age: Xh\nNext: [any notes for successor]\"\n```\n\n`gt handoff` sends handoff mail to yourself, respawns with a fresh Claude instance,\nSessionStart hook runs gt prime, and your successor picks up from the hook.\n\n**DO NOT just exit.** Always use `gt handoff` for proper lifecycle.\n\n**IMPORTANT**: Never sleep-poll manually (e.g., `sleep 30 \u0026\u0026 bd list`).\nAlways use `gt mol step await-event` — it's event-driven and tracks backoff state.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-et2vb","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Burn and respawn or loop","updated_at":"2026-02-28T09:30:15Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:02:59Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T10:00:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ew9s5","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T10:02:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:08:19Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T10:06:06Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ex4l9","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T10:08:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T08:59:50Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-eyyxu","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T08:59:50Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:04:13Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T10:03:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ezmlz","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T10:04:13Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f4473ab156466db2ea58d27c1ae3bcc4fe4c828e01eaa6a71ee9f08d70887c76","created_at":"2026-02-28T08:53:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure workspace is pristine before handoff.\n\n**IMPORTANT: Do NOT run `git push`. That is `gt done`'s job (next step).**\n**IMPORTANT: Do NOT discard implementation changes. They must already be committed.**\n\n**1. Check for untracked files:**\n```bash\ngit status --porcelain\n```\nShould be empty. If not:\n- Add to .gitignore if appropriate\n- Remove if temporary: `rm \u003cfile\u003e`\n- Commit if needed: `git add \u003cfile\u003e \u0026\u0026 git commit -m \"chore: add \u003cfile\u003e\"`\n\n**2. Check stash:**\n```bash\ngit stash list\n```\nShould be empty. If not:\n- Pop and commit: `git stash pop \u0026\u0026 git add -A \u0026\u0026 git commit -m \"chore: unstash work (cue-x7q)\"`\n- Or drop if truly garbage: `git stash drop`\n\n**3. Verify clean state and commits:**\n```bash\ngit status                  # Must show \"working tree clean\"\ngit stash list              # Must be empty\ngit log origin/main..HEAD   # Your commits (should show your work)\n```\n\nIf `git log origin/main..HEAD` shows nothing but you DID make changes,\nsomething went wrong. Do NOT proceed — mail Witness for help.\n\n**Exit criteria:** Workspace clean, no cruft, all work committed. Do NOT push — `gt done` handles that.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-f0dbb","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Clean up workspace","updated_at":"2026-02-28T08:53:43Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"8737a17b7bb92b8ec869791fdc3b4b1a68c31173ee93d4a430e37833f7a04f61","created_at":"2026-02-28T09:53:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Merge and push. CRITICAL: Notifications come IMMEDIATELY after push.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n**Config: delete_merged_branches = true**\n\n**Step 1: Merge and Push**\nDetermine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n```bash\ngit checkout \u003cmerge-target\u003e\ngit merge --ff-only temp\ngit push origin \u003cmerge-target\u003e\n```\n\n**Step 1.5: VERIFY PUSH SUCCEEDED (CRITICAL - PATCH-003)**\n\nPush can fail silently (network, auth, hooks). IMMEDIATELY verify:\n```bash\ngit fetch origin\nLOCAL_SHA=$(git rev-parse \u003cmerge-target\u003e)\nREMOTE_SHA=$(git rev-parse origin/\u003cmerge-target\u003e)\necho \"Local:  $LOCAL_SHA\"\necho \"Remote: $REMOTE_SHA\"\n```\n\n**If SHAs match**: Push succeeded. Continue to Step 2.\n\n**If SHAs differ**: STOP. Push failed silently.\n- DO NOT send MERGED notification\n- DO NOT close MR bead\n- DO NOT delete branch\n- Debug the push failure (check `git push` output, network, auth)\n- Retry push and verify again before proceeding\n\n⚠️ **STOP HERE - DO NOT PROCEED UNTIL STEPS 1.5 AND 2-3 COMPLETE**\n\n**Step 2: Send MERGED Notification (REQUIRED - DO THIS IMMEDIATELY)**\n\nRIGHT NOW, before any cleanup, send MERGED mail to Witness:\n\n```bash\ngt mail send \u003crig\u003e/witness -s \"MERGED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\nMerged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n```\n\nThis signals the Witness to nuke the polecat worktree. WITHOUT THIS NOTIFICATION,\nPOLECAT WORKTREES ACCUMULATE INDEFINITELY AND THE LIFECYCLE BREAKS.\n\n**Step 3: Post-merge cleanup (REQUIRED — single command)**\n\nThis single command handles closing the MR bead, closing the source issue, and\ndeleting the remote polecat branch (respects delete_merged_branches config):\n\n```bash\ngt mq post-merge \u003crig\u003e \u003cmr-bead-id\u003e\n```\n\nThe MR bead ID was in the MERGE_READY message or find via:\n```bash\nbd list --type=merge-request --status=open | grep \u003cpolecat-name\u003e\n```\n\nVerify the command output shows all steps succeeded (✓ for each).\n\n**Step 4: Archive the MERGE_READY mail (REQUIRED)**\n```bash\ngt mail archive \u003cmerge-ready-message-id\u003e\n```\nThe message ID was tracked when you processed inbox-check.\n\n**Step 5: Cleanup temp branch**\n```bash\ngit branch -d temp\n```\n\n**VERIFICATION GATE**: You CANNOT proceed to loop-check without:\n- [x] MERGED mail sent to witness\n- [x] Post-merge cleanup completed (MR closed, source issue closed, branch deleted)\n- [x] MERGE_READY mail archived\n\nIf you skipped notifications or archiving, GO BACK AND DO THEM NOW.\n\nTarget branch has moved. Any remaining branches need rebasing on new baseline.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-f605z","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Merge and push","updated_at":"2026-02-28T09:53:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T09:27:33Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-fb4mb","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T09:27:33Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e731efa93a5c9d5231a98d88586801bc0b5c8709c7cbb6b28d4f7ffe6efd1fd1","created_at":"2026-02-28T10:01:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: run_tests = true**\n**Config: test_command = go test ./...**\n**Config: setup_command = **\n**Config: typecheck_command = **\n**Config: lint_command = **\n**Config: build_command = **\n\n**1. Run quality checks (skip any that are not configured):**\n\nIf setup_command is set: ``\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf build_command is set: ``\n\n```bash\n           # Make sure all newly added dependencies are installed (if command set)\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n           # Make sure it builds (if command set)\n```\n\nEmpty commands mean \"not configured for this project\" — skip silently.\n\n**2. If quality checks fail:**\n\nProceed to handle-failures step. Track which specific check failed\n(setup/typecheck/lint/build) for the failure diagnosis.\n\n**3. Run the test suite:**\n\nIf run_tests = \"false\": Skip this step entirely. Proceed to handle-failures.\n\nIf run_tests = \"true\":\n\n```bash\ngo test ./...            # Run tests (configured per-rig)\n```\n\nTrack results: pass count, fail count, specific failures.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ff14b","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Run quality checks and tests","updated_at":"2026-02-28T10:01:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"08a9203f5a61045888f0a3f59a1e662d6099816dd7eeb7b52193b55395288c45","created_at":"2026-02-28T10:06:30Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Assess whether this session should continue or hand off to a fresh one.\n\n**Gather signals:**\n\n1. **Process memory** — check your own RSS:\n```bash\nps -o rss= -p $$   # KB — divide by 1024 for MB\n```\n\n2. **Session age** — how long has this tmux session been running:\n```bash\nCREATED=$(tmux display-message -t $(tmux display-message -p '#S') -p '#{session_created}')\necho \"Session age: $(( ($(date +%s) - CREATED) / 3600 ))h\"\n```\n\n3. **Context usage** — your internal sense of how much context you've consumed.\nAre you losing track of earlier conversation? Getting verbose? Repeating yourself?\n\n4. **Work done this cycle** — how many merges, how much complexity processed.\n\n**The principle:** Fresh sessions are cheap. Memory bloat compounds over time and\naffects the entire system — other agents, Dolt, and the OS all share the same RAM.\nAn idle session at 1.5 GB is worse than cycling and restarting at 200 MB.\n\n**Make a judgment call.** If multiple signals suggest you're getting heavy\n(high RSS, long session, substantial context consumed), hand off. If you're\nlight and there's active work in the queue, continue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-fhkl7","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Assess session health","updated_at":"2026-02-28T10:06:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e731efa93a5c9d5231a98d88586801bc0b5c8709c7cbb6b28d4f7ffe6efd1fd1","created_at":"2026-02-28T09:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: run_tests = true**\n**Config: test_command = go test ./...**\n**Config: setup_command = **\n**Config: typecheck_command = **\n**Config: lint_command = **\n**Config: build_command = **\n\n**1. Run quality checks (skip any that are not configured):**\n\nIf setup_command is set: ``\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf build_command is set: ``\n\n```bash\n           # Make sure all newly added dependencies are installed (if command set)\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n           # Make sure it builds (if command set)\n```\n\nEmpty commands mean \"not configured for this project\" — skip silently.\n\n**2. If quality checks fail:**\n\nProceed to handle-failures step. Track which specific check failed\n(setup/typecheck/lint/build) for the failure diagnosis.\n\n**3. Run the test suite:**\n\nIf run_tests = \"false\": Skip this step entirely. Proceed to handle-failures.\n\nIf run_tests = \"true\":\n\n```bash\ngo test ./...            # Run tests (configured per-rig)\n```\n\nTrack results: pass count, fail count, specific failures.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-fm80l","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Run quality checks and tests","updated_at":"2026-02-28T09:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T09:00:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ftjvr","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T09:00:46Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"dfab2e7b59734313316899e100837d3f7a1e7098c4c55ea83db66528f85eaefe","created_at":"2026-02-28T09:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"More branches to process?\n\n**Entry paths:**\n- Normal: After successful merge-push\n- Conflict-skip: After process-branch created conflict-resolution task\n\nIf yes: Return to process-branch with next branch.\nIf no: Continue to generate-summary.\n\n**Track for this cycle:**\n- branches_merged: count and names of successfully merged branches\n- branches_conflict: count and names of branches skipped due to conflicts\n- conflict_tasks: IDs of conflict-resolution tasks created\n\nThis tracking feeds into generate-summary for the patrol digest.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-fvg9p","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check for more work","updated_at":"2026-02-28T09:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T09:27:33Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-fyvz8","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T09:27:33Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9907d7c00152be5a0e11fd68614b8132e7e7f9d1af73e39f2a3d7ea8558f866b","created_at":"2026-02-28T09:54:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Release v0.1.0 is complete!\n\nSummary:\n- Build verified\n- Version bumped in flake.nix\n- Git tag pushed\n- GHA built and pushed image to ghcr.io\n- GitHub Release created with handwritten notes\n\nOptional next steps:\n- Announce the release\n- Update any dependent configurations to use v0.1.0\n","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-fzk5h","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Release complete","updated_at":"2026-02-28T09:54:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"795f0417d343e9f29be619802ae3b5a11e7a901e2fde88ff9b9528a3bb8c0e2d","created_at":"2026-02-28T09:42:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Summarize this patrol cycle.\n\n**VERIFICATION**: Before generating summary, confirm for each merged branch:\n- [ ] MERGED mail was sent to witness\n- [ ] MR bead was closed\n- [ ] Source issue was closed\n- [ ] MERGE_READY mail archived\n\nIf any notifications, closures, or archiving were missed, do them now!\n\nInclude in summary:\n- Branches merged (count, names)\n- MERGED mails sent (count - should match branches merged)\n- MR beads closed (count - should match branches merged)\n- Source issues closed (count - should match branches merged)\n- MERGE_READY mails archived (count - should match branches merged)\n- Test results (pass/fail)\n- Branches with conflicts (count, names)\n- Conflict-resolution tasks created (IDs)\n- Issues filed (if any)\n- Any escalations sent\n\n**Conflict tracking is important** for monitoring MQ health. If many branches\nconflict, it may indicate target branches are moving too fast or branches are too stale.\n\nThis becomes the digest when the patrol is squashed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-g13ij","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Generate handoff summary","updated_at":"2026-02-28T09:42:52Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6e25b76587bbf1703fbc9ed77f44aed28cee0429bfa5ddbf893ac153827d16e8","created_at":"2026-02-28T09:37:02Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure workspace is pristine before handoff.\n\n**IMPORTANT: Do NOT run `git push`. That is `gt done`'s job (next step).**\n**IMPORTANT: Do NOT discard implementation changes. They must already be committed.**\n\n**1. Check for untracked files:**\n```bash\ngit status --porcelain\n```\nShould be empty. If not:\n- Add to .gitignore if appropriate\n- Remove if temporary: `rm \u003cfile\u003e`\n- Commit if needed: `git add \u003cfile\u003e \u0026\u0026 git commit -m \"chore: add \u003cfile\u003e\"`\n\n**2. Check stash:**\n```bash\ngit stash list\n```\nShould be empty. If not:\n- Pop and commit: `git stash pop \u0026\u0026 git add -A \u0026\u0026 git commit -m \"chore: unstash work (cue-b3g)\"`\n- Or drop if truly garbage: `git stash drop`\n\n**3. Verify clean state and commits:**\n```bash\ngit status                  # Must show \"working tree clean\"\ngit stash list              # Must be empty\ngit log origin/main..HEAD   # Your commits (should show your work)\n```\n\nIf `git log origin/main..HEAD` shows nothing but you DID make changes,\nsomething went wrong. Do NOT proceed — mail Witness for help.\n\n**Exit criteria:** Workspace clean, no cruft, all work committed. Do NOT push — `gt done` handles that.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-g1ok7","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Clean up workspace","updated_at":"2026-02-28T09:37:02Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T09:04:31Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-g1ppc","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T09:04:31Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"040744fd507e815d3be07ea0cb3047085e044307a5ab8597912ba0ff4b12dc6b","created_at":"2026-02-28T09:37:02Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Do the actual implementation work.\n\n**TDD is mandatory. Write a failing test before writing implementation code.**\n\nFor every feature or bug fix:\n1. Write a test that captures the expected behaviour and **confirm it fails**\n2. Commit the failing test: `git commit -m \"test: failing test for \u003cdescription\u003e (cue-b3g)\"`\n3. Implement until the test passes\n4. Commit the implementation: `git commit -m \"fix/feat: \u003cdescription\u003e (cue-b3g)\"`\n\n```bash\n# Step 1: Write test, verify it fails\n   # Must see your new test fail\n\n# Step 2: Commit the failing test\ngit add \u003ctest-files\u003e\ngit commit -m \"test: failing test for \u003cdescription\u003e (cue-b3g)\"\n\n# Step 3: Implement\n# ... write code ...\n\n# Step 4: Verify test now passes\n   # Your test must now pass\n\n# Step 5: Commit implementation\ngit add \u003cimpl-files\u003e\ngit commit -m \"fix/feat: \u003cdescription\u003e (cue-b3g)\"\n```\n\n**No exceptions.** A fix without a regression test is incomplete. A feature without tests is incomplete.\n\n**Working principles:**\n- Follow existing codebase conventions\n- Make atomic, focused commits\n- Keep changes scoped to the assigned issue\n- Don't gold-plate or scope-creep\n\n**Discovered work:**\nIf you find bugs or improvements outside your scope:\n```bash\nbd create --title \"Found: \u003cdescription\u003e\" --type bug --priority 2\n# Note the ID, continue with your work\n```\n\nDo NOT fix unrelated issues in this branch.\n\n**If stuck:**\nDon't spin for more than 15 minutes. Mail Witness:\n```bash\ngt mail send \u003crig\u003e/witness -s \"HELP: Stuck on implementation\" -m \"Issue: cue-b3g\nTrying to: \u003cwhat you're attempting\u003e\nProblem: \u003cwhat's blocking you\u003e\nTried: \u003cwhat you've attempted\u003e\"\n```\n\n**Exit criteria:** Implementation complete, all changes committed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-g3x43","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Implement the solution","updated_at":"2026-02-28T09:37:02Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T08:59:05Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-g6wt0","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T08:59:05Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T09:09:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-gb8ly","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T09:09:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T09:04:31Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ge83z","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T09:04:31Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9742ae1fab9e73984581e4aacf23f1a5675564600ae2da6e3e08eb76135a7ed5","created_at":"2026-02-28T09:52:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: integration_branch_refinery_enabled = true**\n**Config: integration_branch_auto_land = false**\n\nRead the two config values above, then:\n\n- If integration_branch_refinery_enabled = \"false\": Say \"Integration branches disabled.\" Close step.\n- If integration_branch_auto_land = \"false\": Say \"Auto-land disabled, nothing to do.\" Close step.\n  FORBIDDEN: If auto_land is false, you MUST NOT land integration branches yourself using\n  raw git commands. Do not merge integration branches to the default/target branch. Do not push\n  integration branch merges. The auto_land=false setting means landing requires a human\n  to run `gt mq integration land` manually. Respect this boundary unconditionally.\n- If BOTH are \"true\":\n  1. `bd list --type=epic --status=open` to find epics\n  2. `gt mq integration status \u003cepic-id\u003e` for each epic\n  3. If `ready_to_land: true`: run `gt mq integration land \u003cepic-id\u003e`\n  4. If `ready_to_land: false`: do nothing, epic work is incomplete\n  Never land partial epics — ALL children must be closed first.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-gibj5","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check integration branches for landing","updated_at":"2026-02-28T09:52:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"795f0417d343e9f29be619802ae3b5a11e7a901e2fde88ff9b9528a3bb8c0e2d","created_at":"2026-02-28T09:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Summarize this patrol cycle.\n\n**VERIFICATION**: Before generating summary, confirm for each merged branch:\n- [ ] MERGED mail was sent to witness\n- [ ] MR bead was closed\n- [ ] Source issue was closed\n- [ ] MERGE_READY mail archived\n\nIf any notifications, closures, or archiving were missed, do them now!\n\nInclude in summary:\n- Branches merged (count, names)\n- MERGED mails sent (count - should match branches merged)\n- MR beads closed (count - should match branches merged)\n- Source issues closed (count - should match branches merged)\n- MERGE_READY mails archived (count - should match branches merged)\n- Test results (pass/fail)\n- Branches with conflicts (count, names)\n- Conflict-resolution tasks created (IDs)\n- Issues filed (if any)\n- Any escalations sent\n\n**Conflict tracking is important** for monitoring MQ health. If many branches\nconflict, it may indicate target branches are moving too fast or branches are too stale.\n\nThis becomes the digest when the patrol is squashed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-godbi","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Generate handoff summary","updated_at":"2026-02-28T09:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T10:08:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-gpg6r","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T10:08:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"fa8597c79e107b625b6bdf39d00dcd4d28221dd8e3e053d29dd919ff010f2af5","created_at":"2026-02-28T08:56:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify your changes don't break anything and are properly tested.\n\n**1. Run quality checks (skip any that are not configured):**\n\nIf setup_command is set: ``\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf build_command is set: ``\n\n```bash\n           # Make sure all newly added dependencies are installed (if command set)\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n            # Make sure it builds (if command set)\n```\n\nEmpty commands mean \"not configured for this project\" — skip silently.\n\n**2. If quality checks fail:**\n- Read the failure output carefully\n- Determine if your change caused it:\n  - If yes: Fix it. Return to implement step if needed.\n  - If no (pre-existing): File a bead, but still must pass for your PR\n\n```bash\n# Check if failure exists on main:\ngit stash\ngit checkout origin/main\n# Re-run the failing command(s)\ngit checkout -\ngit stash pop\n```\n\n**3. Run the full test suite:**\n\nYour base branch determines the required depth:\n- Targeting `main`: run the **full verification suite** including E2E tests\n- Targeting an integration branch: run the **unit test suite** only\n\n```bash\n# Targeting main — full verification required:\nif [ \"main\" = \"main\" ]; then\n  make verify\nelse\n  \nfi\n```\n\n**ALL TESTS MUST PASS.** Do not proceed with failures.\n\n**4. If tests fail:**\n- Read the failure output carefully\n- Determine if your change caused it:\n  - If yes: Fix it. Return to implement step if needed.\n  - If no (pre-existing): File a bead, but still must pass for your PR\n\n```bash\n# Check if failure exists on main:\ngit stash\ngit checkout origin/main\n\ngit checkout -\ngit stash pop\n```\n\n**5. Verify test coverage:**\n\nIf you followed TDD (as required in the implement step), your tests are already in place.\nIf for any reason you did not write tests first, you MUST add them now before proceeding.\n\nAsk yourself: \"If I broke this code tomorrow, would a test catch it?\"\nIf the answer is no, add the test now.\n\n**Exit criteria:** All quality checks and tests pass. Every behaviour change has a test. No exceptions.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-grcdw","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Run quality checks and tests","updated_at":"2026-02-28T08:56:25Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T08:59:50Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-gse9o","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T08:59:50Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"769447c96532d91233b37d97c63c883444ba63231b19c4d70e37300549e8b8af","created_at":"2026-02-28T09:30:15Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**VERIFICATION GATE**: This step enforces the Beads Promise.\n\nIf all checks and tests PASSED: This step auto-completes. Proceed to merge.\n\nIf any check or test FAILED:\n1. Diagnose: Is this a branch regression or pre-existing on the target branch?\n2. If branch caused it:\n   - Abort merge\n   - **REOPEN the source issue** so it returns to the ready queue:\n     ```bash\n     bd update \u003cissue-id\u003e --status=open --assignee=\"\"\n     bd sync\n     ```\n   - Notify witness of rejection using the MERGE_FAILED protocol:\n     ```bash\n     gt mail send \u003crig\u003e/witness -s \"MERGE_FAILED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\n     Issue: \u003cissue-id\u003e\n     Polecat: \u003cpolecat-name\u003e\n     Rig: \u003crig\u003e\n     FailureType: quality-check\n     Error: \u003cfailure description\u003e\"\n     ```\n   - Close the MR bead as rejected:\n     ```bash\n     bd close \u003cmr-bead-id\u003e --reason \"Rejected: \u003cfailure description\u003e\"\n     ```\n   - Delete the rejected branch (a new polecat will create a fresh one):\n     ```bash\n     git push origin --delete \u003cpolecat-branch\u003e\n     ```\n   - Archive the MERGE_READY message\n   - Skip to loop-check\n3. If pre-existing on the target branch:\n   - **DUPLICATE CHECK (MANDATORY)**: Before filing a new bug, search for existing open bugs:\n     ```bash\n     bd search \"\u003cfailure description\u003e\" --status open --label gt:bug --limit 5\n     ```\n     If an existing open bug covers the same failure, do NOT create a duplicate.\n     Instead, note the existing bead ID and proceed.\n   - Only if NO existing bug matches: bd create --type=bug --priority=1 --title=\"Pre-existing failure: \u003cdescription\u003e\"\n   - FORBIDDEN: Writing code to fix quality check or test failures. You merge branches, you do not develop.\n   - Proceed with the merge if the failure is pre-existing (not caused by the branch).\n\n**REJECTION CHECKLIST** (all required before skipping to loop-check):\n- [ ] Source issue reopened (bd update \u003cissue-id\u003e --status=open --assignee=\"\")\n- [ ] MERGE_FAILED notification sent to witness\n- [ ] MR bead closed with rejection reason\n- [ ] Rejected branch deleted from remote\n- [ ] MERGE_READY message archived\n\n**GATE REQUIREMENT**: You CANNOT proceed to merge-push without:\n- All quality checks and tests passing, OR\n- Bead filed (or existing duplicate confirmed) for the pre-existing failure\n\nFORBIDDEN: Writing application code, exploring polecat implementations, or\nre-implementing fixes. You are a mechanical merge processor.\n\nThis is non-negotiable. Never disavow. Never \"note and proceed.\" ","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-gspxu","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Handle quality check or test failures","updated_at":"2026-02-28T09:30:15Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T09:04:31Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-gw15j","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T09:04:31Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T09:09:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-h0kid","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T09:09:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"40b42888ffc52a4717ff4e88474ff08062473c2b52f2590ab08092ef3e5dc231","created_at":"2026-02-28T09:27:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify work is complete and ready for merge queue.\n\n**Note:** Do NOT close the issue. The Refinery will close it after successful merge.\nThis enables conflict-resolution retries without reopening closed issues.\n\n**1. Verify the issue shows your work:**\n```bash\nbd show cue-dbv\n# Status should still be 'in_progress' (you're working on it)\n```\n\n**2. Add completion notes:**\n```bash\nbd update cue-dbv --notes \"Implemented: \u003cbrief summary of what was done\u003e\"\n```\n\n**3. Sync beads:**\n```bash\nbd sync\n```\n\n**Exit criteria:** Issue updated with completion notes, beads synced.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-h0tvt","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Prepare work for review","updated_at":"2026-02-28T09:27:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b5b41d316559ab36d81b013937c0b56a205c257b0f96499632c4e34fb4d420c5","created_at":"2026-02-28T09:53:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check the beads merge queue - this is the SOURCE OF TRUTH for pending merges.\n\n```bash\ngit fetch --prune origin\ngt mq list \u003crig\u003e\n```\n\nThe beads MQ tracks all pending merge requests. Do NOT rely on `git branch -r | grep polecat`\nas branches may exist without MR beads, or MR beads may exist for already-merged work.\n\nIf queue empty, skip to \"check-integration-branches\" step.\n\nFor each MR in the queue, verify the branch still exists:\n```bash\ngit branch -r | grep \u003cbranch\u003e\n```\n\nIf branch doesn't exist for a queued MR:\n- Close the MR bead: `bd close \u003cmr-id\u003e --reason \"Branch no longer exists\"`\n- Remove from processing queue\n\nTrack verified MR list for this cycle.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-hg8wq","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Scan merge queue","updated_at":"2026-02-28T09:53:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"769447c96532d91233b37d97c63c883444ba63231b19c4d70e37300549e8b8af","created_at":"2026-02-28T09:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**VERIFICATION GATE**: This step enforces the Beads Promise.\n\nIf all checks and tests PASSED: This step auto-completes. Proceed to merge.\n\nIf any check or test FAILED:\n1. Diagnose: Is this a branch regression or pre-existing on the target branch?\n2. If branch caused it:\n   - Abort merge\n   - **REOPEN the source issue** so it returns to the ready queue:\n     ```bash\n     bd update \u003cissue-id\u003e --status=open --assignee=\"\"\n     bd sync\n     ```\n   - Notify witness of rejection using the MERGE_FAILED protocol:\n     ```bash\n     gt mail send \u003crig\u003e/witness -s \"MERGE_FAILED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\n     Issue: \u003cissue-id\u003e\n     Polecat: \u003cpolecat-name\u003e\n     Rig: \u003crig\u003e\n     FailureType: quality-check\n     Error: \u003cfailure description\u003e\"\n     ```\n   - Close the MR bead as rejected:\n     ```bash\n     bd close \u003cmr-bead-id\u003e --reason \"Rejected: \u003cfailure description\u003e\"\n     ```\n   - Delete the rejected branch (a new polecat will create a fresh one):\n     ```bash\n     git push origin --delete \u003cpolecat-branch\u003e\n     ```\n   - Archive the MERGE_READY message\n   - Skip to loop-check\n3. If pre-existing on the target branch:\n   - **DUPLICATE CHECK (MANDATORY)**: Before filing a new bug, search for existing open bugs:\n     ```bash\n     bd search \"\u003cfailure description\u003e\" --status open --label gt:bug --limit 5\n     ```\n     If an existing open bug covers the same failure, do NOT create a duplicate.\n     Instead, note the existing bead ID and proceed.\n   - Only if NO existing bug matches: bd create --type=bug --priority=1 --title=\"Pre-existing failure: \u003cdescription\u003e\"\n   - FORBIDDEN: Writing code to fix quality check or test failures. You merge branches, you do not develop.\n   - Proceed with the merge if the failure is pre-existing (not caused by the branch).\n\n**REJECTION CHECKLIST** (all required before skipping to loop-check):\n- [ ] Source issue reopened (bd update \u003cissue-id\u003e --status=open --assignee=\"\")\n- [ ] MERGE_FAILED notification sent to witness\n- [ ] MR bead closed with rejection reason\n- [ ] Rejected branch deleted from remote\n- [ ] MERGE_READY message archived\n\n**GATE REQUIREMENT**: You CANNOT proceed to merge-push without:\n- All quality checks and tests passing, OR\n- Bead filed (or existing duplicate confirmed) for the pre-existing failure\n\nFORBIDDEN: Writing application code, exploring polecat implementations, or\nre-implementing fixes. You are a mechanical merge processor.\n\nThis is non-negotiable. Never disavow. Never \"note and proceed.\" ","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-hgxc9","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Handle quality check or test failures","updated_at":"2026-02-28T09:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:02:59Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T10:00:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-hmkgm","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T10:02:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T08:57:59Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-hp8bq","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T08:57:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:02:59Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T10:00:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-htkyw","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T10:02:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3560d7b1a900af0fa671383af7df139375a27ea4969d5ef8a8fe144df9a317b1","created_at":"2026-02-28T09:27:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd mol current` / `bd close \u003cstep\u003e`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `gt hook` to find your pinned molecule, then `bd show`\nfor step details — do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n| base_branch | sling vars | The base branch to rebase on (default: main) |\n| setup_command | rig config | Setup/install command (e.g., `pnpm install`). Empty = skip. |\n| typecheck_command | rig config | Type check command (e.g., `tsc --noEmit`). Empty = skip. |\n| test_command | rig config | Test command. Empty = skip. Rig must configure for its language. |\n| lint_command | rig config | Lint command (e.g., `eslint .`). Empty = skip. |\n| build_command | rig config | Build command (e.g., `go build ./...`). Empty = skip. |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-hvvmr","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"mol-polecat-work","updated_at":"2026-02-28T09:27:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T10:08:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-hz9vq","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T10:08:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"17c4622d88c75c6477702b53602fc3f092ed0d17c24cc7fdc9cde0c0e5a869a6","created_at":"2026-02-28T09:27:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Review your own changes before running tests.\n\n**1. Review the diff:**\n```bash\ngit diff origin/main...HEAD     # All changes vs main\ngit log --oneline origin/main..HEAD  # All commits\n```\n\n**2. Check for common issues:**\n\n| Category | Look For |\n|----------|----------|\n| Bugs | Off-by-one, null handling, edge cases |\n| Security | Injection, auth bypass, exposed secrets |\n| Style | Naming, formatting, code organization |\n| Completeness | Missing error handling, incomplete paths |\n| Cruft | Debug prints, commented code, TODOs |\n\n**3. Refactor check:**\n\nAsk yourself:\n- Does this implementation duplicate logic that already exists elsewhere?\n- Are there names, abstractions, or structures that will confuse the next person?\n- Would you be embarrassed to show this diff to a senior engineer?\n\nIf yes to any — fix it now. Refactoring is part of the work, not a luxury.\nCommit any refactoring separately: `git commit -m \"refactor: \u003cdescription\u003e (cue-dbv)\"`\n\n**4. Fix issues found:**\nDon't just note them - fix them now. Amend or add commits as needed.\n\n**5. Verify no unintended changes:**\n```bash\ngit diff --stat origin/main...HEAD\n# Only files relevant to cue-dbv should appear\n```\n\nIf you accidentally modified unrelated files, remove those changes.\n\n**Exit criteria:** Changes are clean, reviewed, refactored where needed, and ready for testing.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-hzyz2","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Self-review changes","updated_at":"2026-02-28T09:27:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f1fb7df3a3ea8b1e06a323a82cf9250837f7a0d473f852b31abd58d4dd56d256","created_at":"2026-02-28T09:54:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure we're up to date with origin.\n\n```bash\ngit pull --rebase origin main\n```\n\nResolve any conflicts before proceeding.\n","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-i1gj1","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Preflight: Pull latest","updated_at":"2026-02-28T09:54:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3560d7b1a900af0fa671383af7df139375a27ea4969d5ef8a8fe144df9a317b1","created_at":"2026-02-28T08:57:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd mol current` / `bd close \u003cstep\u003e`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `gt hook` to find your pinned molecule, then `bd show`\nfor step details — do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n| base_branch | sling vars | The base branch to rebase on (default: main) |\n| setup_command | rig config | Setup/install command (e.g., `pnpm install`). Empty = skip. |\n| typecheck_command | rig config | Type check command (e.g., `tsc --noEmit`). Empty = skip. |\n| test_command | rig config | Test command. Empty = skip. Rig must configure for its language. |\n| lint_command | rig config | Lint command (e.g., `eslint .`). Empty = skip. |\n| build_command | rig config | Build command (e.g., `go build ./...`). Empty = skip. |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-i1sdy","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"mol-polecat-work","updated_at":"2026-02-28T08:57:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"4335e331df3ce8a0f5de28e5383fcace6d837c39c3df164950f209815a1d878f","created_at":"2026-02-28T09:54:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Create a GitHub release with **MANUALLY WRITTEN** release notes.\n\n**DO NOT use --generate-notes or auto-generate from commits.**\n\nWrite a proper changelog covering what changed and why it matters to users.\n\n```bash\n# Review what changed for context\nPREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2\u003e/dev/null || echo \"\")\nif [ -n \"$PREV_TAG\" ]; then\n  git log ${PREV_TAG}..v0.1.0 --oneline --no-merges\nelse\n  git log --oneline --no-merges\nfi\n\n# Create release with hand-written notes\ngh release create v0.1.0 --title \"v0.1.0\" --notes \"## What's new\n- \u003cdescribe new features\u003e\n\n## Fixes\n- \u003cdescribe bug fixes, or 'No fixes in this release'\u003e\n\n## Docker image\n    docker pull ghcr.io/graemef/claude-usage-exporter:v0.1.0\n\"\n```\n\n**Quality bar**: Notes should help users understand what changed and whether to upgrade.\nVerify at: https://github.com/GraemeF/claude-usage-exporter/releases\n","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-i2g45","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Create GitHub Release","updated_at":"2026-02-28T09:54:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a256b80855afd3ac284a3902b23415a9b78a62c489f52e7491b2b3e9db95bc90","created_at":"2026-02-28T10:01:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check mail for MERGE_READY submissions, escalations, and messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**MERGE_READY**:\nA polecat's work is ready for merge. Extract details and track for processing.\n\n```bash\n# Parse MERGE_READY message body:\n# Branch: \u003cbranch\u003e\n# Issue: \u003cissue-id\u003e\n# Polecat: \u003cpolecat-name\u003e\n# MR: \u003cmr-bead-id\u003e\n# Verified: clean git state, issue closed\n\n# Track in your merge queue for this patrol cycle:\n# - Branch name\n# - Issue ID\n# - Polecat name (REQUIRED for MERGED notification)\n# - MR bead ID (REQUIRED for closing after merge)\n```\n\n**IMPORTANT**: You MUST track the polecat name, MR bead ID, AND message ID - you will need them\nin merge-push step to send MERGED notification, close the MR bead, and archive the mail.\n\nMark as read. The work will be processed in queue-scan/process-branch.\n**Do NOT archive yet** - archive after merge/reject decision in merge-push step.\n\n**PATROL: Wake up**:\nWitness detected MRs waiting but refinery idle. Acknowledge and archive:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HELP / Blocked**:\nAssess and respond. If you can't help, escalate to Mayor.\nArchive after handling:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Check for in-flight merges.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: pending MRs in queue. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-i5pnl","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery mail","updated_at":"2026-02-28T10:01:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:00:04Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T09:54:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-i6p8z","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T10:00:04Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f11e41afdcc2e611cf10538b7372360c1da4740438a9e1efbd200aac7922f08c","created_at":"2026-02-28T08:56:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Initialize your session and understand your assignment.\n\n**1. Prime your environment:**\n```bash\ngt prime                    # Load role context\nbd prime                    # Load beads context\n```\n\n**2. Check your hook:**\n```bash\ngt hook               # Shows your pinned molecule and hook_bead\n```\n\nThe hook_bead is your assigned issue. Read it carefully:\n```bash\nbd show cue-sx0           # Full issue details\n```\n\n**3. Check inbox for additional context:**\n```bash\ngt mail inbox\n# Read any HANDOFF or assignment messages\n```\n\n**4. Understand the requirements:**\n- What exactly needs to be done?\n- What files are likely involved?\n- Are there dependencies or blockers?\n- What does \"done\" look like?\n\n**5. Verify you can proceed:**\n- No unresolved blockers on the issue\n- You understand what to do\n- Required resources are available\n\nIf blocked or unclear, mail Witness immediately:\n```bash\ngt mail send \u003crig\u003e/witness -s \"HELP: Unclear requirements\" -m \"Issue: cue-sx0\nQuestion: \u003cwhat you need clarified\u003e\"\n```\n\n**Exit criteria:** You understand the work and can begin implementation.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-i8r9p","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Load context and verify assignment","updated_at":"2026-02-28T08:56:25Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T08:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ig4vs","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T08:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e731efa93a5c9d5231a98d88586801bc0b5c8709c7cbb6b28d4f7ffe6efd1fd1","created_at":"2026-02-28T09:53:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: run_tests = true**\n**Config: test_command = go test ./...**\n**Config: setup_command = **\n**Config: typecheck_command = **\n**Config: lint_command = **\n**Config: build_command = **\n\n**1. Run quality checks (skip any that are not configured):**\n\nIf setup_command is set: ``\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf build_command is set: ``\n\n```bash\n           # Make sure all newly added dependencies are installed (if command set)\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n           # Make sure it builds (if command set)\n```\n\nEmpty commands mean \"not configured for this project\" — skip silently.\n\n**2. If quality checks fail:**\n\nProceed to handle-failures step. Track which specific check failed\n(setup/typecheck/lint/build) for the failure diagnosis.\n\n**3. Run the test suite:**\n\nIf run_tests = \"false\": Skip this step entirely. Proceed to handle-failures.\n\nIf run_tests = \"true\":\n\n```bash\ngo test ./...            # Run tests (configured per-rig)\n```\n\nTrack results: pass count, fail count, specific failures.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ioigy","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Run quality checks and tests","updated_at":"2026-02-28T09:53:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6c13a80e672c4e6ced6c05f5bbf72aeb746501362aba7c8df898024fc5cbe1aa","created_at":"2026-02-28T09:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Pick next branch from queue. Attempt mechanical rebase on the MR's effective target branch.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n\n**Step 0: Determine rebase target (must match merge target)**\n\nResolve `\u003crebase-target\u003e` using the **Target Resolution Rule** above.\nDo NOT hardcode `main` unless `main` is actually the resolved MR target.\n\n**Step 1: Checkout and attempt rebase**\n```bash\ngit checkout -b temp origin/\u003cpolecat-branch\u003e\ngit rebase origin/\u003crebase-target\u003e\n```\n\n**Step 2: Check rebase result**\n\nThe rebase exits with:\n- Exit code 0: Success - proceed to run-tests\n- Exit code 1 (conflicts): Conflict detected - proceed to Step 3\n\nTo detect conflict state after rebase fails:\n```bash\n# Check if we're in a conflicted rebase state\nls .git/rebase-merge 2\u003e/dev/null \u0026\u0026 echo \"CONFLICT_STATE\"\n```\n\n**Step 3: Handle conflicts (if any)**\n\nIf rebase SUCCEEDED (exit code 0):\n- Skip to run-tests step (continue normal merge flow)\n\nIf rebase FAILED with conflicts:\n\n1. **Abort the rebase** (DO NOT leave repo in conflicted state):\n```bash\ngit rebase --abort\n```\n\n2. **Record conflict metadata**:\n```bash\n# Capture target SHA for reference\nTARGET_SHA=$(git rev-parse origin/\u003crebase-target\u003e)\nBRANCH_SHA=$(git rev-parse origin/\u003cpolecat-branch\u003e)\n```\n\n3. **Create conflict-resolution task**:\n```bash\nbd create --type=task --priority=1 --title=\"Resolve merge conflicts: \u003coriginal-issue-title\u003e\" --description=\"## Conflict Resolution Required\n\nOriginal MR: \u003cmr-bead-id\u003e\nBranch: \u003cpolecat-branch\u003e\nOriginal Issue: \u003cissue-id\u003e\nConflict with target \u003crebase-target\u003e at: ${TARGET_SHA}\nBranch SHA: ${BRANCH_SHA}\n\n## Instructions\n1. Clone/checkout the branch\n2. Rebase on target: git rebase origin/\u003crebase-target\u003e\n3. Resolve conflicts\n4. Force push: git push -f origin \u003cbranch\u003e\n5. Close this task when done\n\nThe MR will be re-queued for processing after conflicts are resolved.\"\n```\n\n4. **Skip this MR** (do NOT delete branch or close MR bead):\n- Leave branch intact for conflict resolution\n- Leave MR bead open (will be re-processed after resolution)\n- Continue to loop-check for next branch\n\n**CRITICAL**: Never delete a branch that has conflicts. The branch contains\nthe original work and must be preserved for conflict resolution.\n\nTrack: rebase result (success/conflict), conflict task ID if created.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-iq3oc","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Mechanical rebase","updated_at":"2026-02-28T09:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T08:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-j17et","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T08:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:06:01Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T10:04:18Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-j8l8x","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T10:06:01Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"efedb0556d20461677c7b974c709aaf498b601f54eb47bf08f9e0e1edd70d82e","created_at":"2026-02-28T09:37:02Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure you're on a clean feature branch ready for work.\n\n**1. Check current branch state:**\n```bash\ngit status\ngit branch --show-current\n```\n\n**2. If not on a feature branch, create one:**\n```bash\ngit fetch origin\ngit checkout -b polecat/\u003cname\u003e origin/main\n```\n\n**3. Ensure clean working state:**\n```bash\ngit status                  # Should show \"working tree clean\"\ngit stash list              # Should be empty\n```\n\nIf dirty state from previous work:\n```bash\n# If changes are relevant to this issue:\ngit add -A \u0026\u0026 git commit -m \"WIP: \u003cdescription\u003e\"\n\n# If changes are unrelated cruft:\ngit stash push -m \"unrelated changes before cue-b3g\"\n# Or discard if truly garbage:\ngit checkout -- .\n```\n\n**4. Sync with main:**\n```bash\ngit fetch origin\ngit rebase origin/main      # Get latest, rebase your branch\n```\n\nIf rebase conflicts:\n- Resolve them carefully\n- Test after resolution\n- If stuck, mail Witness\n\n**5. Run project setup (if configured):**\n\nIf setup_command is set, run it to install dependencies:\n```bash\n\n```\n\nThis ensures dependencies are installed before pre-flight checks.\nEmpty setup_command means \"not configured\" — skip this step.\n\n**Exit criteria:** You're on a clean feature branch, rebased on latest main, dependencies installed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-jcjps","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Set up working branch","updated_at":"2026-02-28T09:37:02Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:00:20Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T09:54:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-jd595","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T10:00:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"c156e08c61e13e78a391dfa140211c8431338f31b037e4ec616ec82d3a23ea40","created_at":"2026-02-28T09:27:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure you're on a clean feature branch ready for work.\n\n**1. Check current branch state:**\n```bash\ngit status\ngit branch --show-current\n```\n\n**2. If not on a feature branch, create one:**\n```bash\ngit fetch origin\ngit checkout -b polecat/\u003cname\u003e origin/main\n```\n\n**3. Ensure clean working state:**\n```bash\ngit status                  # Should show \"working tree clean\"\ngit stash list              # Should be empty\n```\n\nIf dirty state from previous work:\n```bash\n# If changes are relevant to this issue:\ngit add -A \u0026\u0026 git commit -m \"WIP: \u003cdescription\u003e\"\n\n# If changes are unrelated cruft:\ngit stash push -m \"unrelated changes before cue-dbv\"\n# Or discard if truly garbage:\ngit checkout -- .\n```\n\n**4. Sync with main:**\n```bash\ngit fetch origin\ngit rebase origin/main      # Get latest, rebase your branch\n```\n\nIf rebase conflicts:\n- Resolve them carefully\n- Test after resolution\n- If stuck, mail Witness\n\n**5. Run project setup (if configured):**\n\nIf setup_command is set, run it to install dependencies:\n```bash\n\n```\n\nThis ensures dependencies are installed before pre-flight checks.\nEmpty setup_command means \"not configured\" — skip this step.\n\n**Exit criteria:** You're on a clean feature branch, rebased on latest main, dependencies installed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-jm5d8","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Set up working branch","updated_at":"2026-02-28T09:27:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"cd04eafd6cb3229e545c808f5c4de8961b95bb943104a4d5769ed7d9069b3c8c","created_at":"2026-02-28T09:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nInbox should contain ONLY:\n- Unprocessed MERGE_READY messages (will process next cycle)\n- Active work items\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- PATROL: Wake up that was acknowledged → archive\n- HELP/Blocked that was handled → archive\n- MERGE_READY where merge completed but archive was missed → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Check for orphaned MR beads**\n\nLook for open MR beads with no corresponding branch:\n```bash\nbd list --type=merge-request --status=open\n```\n\nFor each open MR bead:\n1. Check if branch exists: `git ls-remote origin refs/heads/\u003cbranch\u003e`\n2. Determine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n3. If branch is gone, pick `\u003cverification-target\u003e`:\n   - If `origin/\u003cmerge-target\u003e` exists, use `\u003cmerge-target\u003e`.\n   - If `origin/\u003cmerge-target\u003e` is missing (e.g. deleted integration branch), use `main`.\n4. Verify landed work: `git log origin/\u003cverification-target\u003e --oneline | grep \"\u003csource_issue\u003e\"`\n5. If work found → close MR with reason \"Merged (verified on \u003cverification-target\u003e; merge target was \u003cmerge-target\u003e)\"\n6. If work NOT found → investigate before closing:\n   - Check source_issue validity (should be gt-xxxxx, not branch name)\n   - Search reflog/dangling commits if possible\n   - If unverifiable, close with reason \"Unverifiable - no audit trail\"\n   - File bead if this indicates lost work\n\n**NEVER close an MR bead without verifying the work landed or is unrecoverable.**\n\n**Goal**: Inbox should have ≤3 active messages at end of cycle.\nKeep only: pending MRs in queue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-jo585","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T09:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"340ae301b740bea455d6f041f3266e209823a9c36f76831380c2d39aafa0ee78","created_at":"2026-02-28T08:56:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check if the codebase is healthy BEFORE starting your work.\n\n**The Scotty Principle:** Don't walk past a broken warp core. But also don't\nlet someone else's mess consume your entire mission.\n\n**1. Run pre-flights on main:**\n\nYour branch was just created from or rebased on `origin/main` with no\nimplementation changes yet — you're already at the base branch state.\n\nRun each configured check, then tests:\n\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf test_command is set: ``\n\n```bash\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n            # Run tests (if command set)\n```\n\nEmpty commands mean \"not configured\" — skip silently.\n\n**2. If pre-flights pass:**\n\nContinue to implement step.\n\n**3. If pre-flights fail on main:**\n\nFile a bead and proceed. Do NOT fix pre-existing failures yourself — that is\nnot your assignment. Your job is to fix the issue on your hook, not main.\n\n| Situation | Action |\n|-----------|--------|\n| Any pre-existing failure | File bead, proceed with your work |\n\nFORBIDDEN: Pushing to main. FORBIDDEN: Fixing pre-existing failures.\nYou work on YOUR feature branch only. `gt done` handles push/MR.\n\n**File and proceed path:**\n```bash\nbd create --title \"Pre-existing failure: \u003cdescription\u003e\" --type bug --priority 1\n\ngt mail send \u003crig\u003e/witness -s \"NOTICE: main has failing pre-flights\" -m \"Found pre-existing failures on main.\nFiled: \u003cbead-id\u003e\nProceeding with my assigned work (cue-26p).\"\n```\n\n**Context consideration:**\nIf investigating pre-existing failures consumed significant context:\n```bash\ngt handoff -s \"Investigated pre-existing failures, ready for assigned work\" -m \"Issue: cue-26p\nFound: \u003cwhat failed\u003e\nReady to start: implement step\"\n```\nFresh session continues from implement.\n\n**Exit criteria:** Pre-flights pass on main (or issue filed), ready to implement.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-jqhwt","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Verify pre-flights pass on base branch","updated_at":"2026-02-28T08:56:25Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T09:00:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-jtmix","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T09:00:46Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T09:37:14Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-jvw2l","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T09:37:14Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:02:59Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T10:00:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-jx7i6","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T10:02:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:00:19Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T09:54:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-k2gzb","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T10:00:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a256b80855afd3ac284a3902b23415a9b78a62c489f52e7491b2b3e9db95bc90","created_at":"2026-02-28T10:06:30Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check mail for MERGE_READY submissions, escalations, and messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**MERGE_READY**:\nA polecat's work is ready for merge. Extract details and track for processing.\n\n```bash\n# Parse MERGE_READY message body:\n# Branch: \u003cbranch\u003e\n# Issue: \u003cissue-id\u003e\n# Polecat: \u003cpolecat-name\u003e\n# MR: \u003cmr-bead-id\u003e\n# Verified: clean git state, issue closed\n\n# Track in your merge queue for this patrol cycle:\n# - Branch name\n# - Issue ID\n# - Polecat name (REQUIRED for MERGED notification)\n# - MR bead ID (REQUIRED for closing after merge)\n```\n\n**IMPORTANT**: You MUST track the polecat name, MR bead ID, AND message ID - you will need them\nin merge-push step to send MERGED notification, close the MR bead, and archive the mail.\n\nMark as read. The work will be processed in queue-scan/process-branch.\n**Do NOT archive yet** - archive after merge/reject decision in merge-push step.\n\n**PATROL: Wake up**:\nWitness detected MRs waiting but refinery idle. Acknowledge and archive:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HELP / Blocked**:\nAssess and respond. If you can't help, escalate to Mayor.\nArchive after handling:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Check for in-flight merges.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: pending MRs in queue. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-k2oia","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery mail","updated_at":"2026-02-28T10:06:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T08:59:50Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-k2v9y","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T08:59:50Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:04:13Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T10:03:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-k4x0k","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T10:04:13Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T09:06:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-k5w0y","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T09:06:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"8737a17b7bb92b8ec869791fdc3b4b1a68c31173ee93d4a430e37833f7a04f61","created_at":"2026-02-28T09:52:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Merge and push. CRITICAL: Notifications come IMMEDIATELY after push.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n**Config: delete_merged_branches = true**\n\n**Step 1: Merge and Push**\nDetermine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n```bash\ngit checkout \u003cmerge-target\u003e\ngit merge --ff-only temp\ngit push origin \u003cmerge-target\u003e\n```\n\n**Step 1.5: VERIFY PUSH SUCCEEDED (CRITICAL - PATCH-003)**\n\nPush can fail silently (network, auth, hooks). IMMEDIATELY verify:\n```bash\ngit fetch origin\nLOCAL_SHA=$(git rev-parse \u003cmerge-target\u003e)\nREMOTE_SHA=$(git rev-parse origin/\u003cmerge-target\u003e)\necho \"Local:  $LOCAL_SHA\"\necho \"Remote: $REMOTE_SHA\"\n```\n\n**If SHAs match**: Push succeeded. Continue to Step 2.\n\n**If SHAs differ**: STOP. Push failed silently.\n- DO NOT send MERGED notification\n- DO NOT close MR bead\n- DO NOT delete branch\n- Debug the push failure (check `git push` output, network, auth)\n- Retry push and verify again before proceeding\n\n⚠️ **STOP HERE - DO NOT PROCEED UNTIL STEPS 1.5 AND 2-3 COMPLETE**\n\n**Step 2: Send MERGED Notification (REQUIRED - DO THIS IMMEDIATELY)**\n\nRIGHT NOW, before any cleanup, send MERGED mail to Witness:\n\n```bash\ngt mail send \u003crig\u003e/witness -s \"MERGED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\nMerged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n```\n\nThis signals the Witness to nuke the polecat worktree. WITHOUT THIS NOTIFICATION,\nPOLECAT WORKTREES ACCUMULATE INDEFINITELY AND THE LIFECYCLE BREAKS.\n\n**Step 3: Post-merge cleanup (REQUIRED — single command)**\n\nThis single command handles closing the MR bead, closing the source issue, and\ndeleting the remote polecat branch (respects delete_merged_branches config):\n\n```bash\ngt mq post-merge \u003crig\u003e \u003cmr-bead-id\u003e\n```\n\nThe MR bead ID was in the MERGE_READY message or find via:\n```bash\nbd list --type=merge-request --status=open | grep \u003cpolecat-name\u003e\n```\n\nVerify the command output shows all steps succeeded (✓ for each).\n\n**Step 4: Archive the MERGE_READY mail (REQUIRED)**\n```bash\ngt mail archive \u003cmerge-ready-message-id\u003e\n```\nThe message ID was tracked when you processed inbox-check.\n\n**Step 5: Cleanup temp branch**\n```bash\ngit branch -d temp\n```\n\n**VERIFICATION GATE**: You CANNOT proceed to loop-check without:\n- [x] MERGED mail sent to witness\n- [x] Post-merge cleanup completed (MR closed, source issue closed, branch deleted)\n- [x] MERGE_READY mail archived\n\nIf you skipped notifications or archiving, GO BACK AND DO THEM NOW.\n\nTarget branch has moved. Any remaining branches need rebasing on new baseline.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-k7lxx","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Merge and push","updated_at":"2026-02-28T09:52:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6c13a80e672c4e6ced6c05f5bbf72aeb746501362aba7c8df898024fc5cbe1aa","created_at":"2026-02-28T09:31:42Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Pick next branch from queue. Attempt mechanical rebase on the MR's effective target branch.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n\n**Step 0: Determine rebase target (must match merge target)**\n\nResolve `\u003crebase-target\u003e` using the **Target Resolution Rule** above.\nDo NOT hardcode `main` unless `main` is actually the resolved MR target.\n\n**Step 1: Checkout and attempt rebase**\n```bash\ngit checkout -b temp origin/\u003cpolecat-branch\u003e\ngit rebase origin/\u003crebase-target\u003e\n```\n\n**Step 2: Check rebase result**\n\nThe rebase exits with:\n- Exit code 0: Success - proceed to run-tests\n- Exit code 1 (conflicts): Conflict detected - proceed to Step 3\n\nTo detect conflict state after rebase fails:\n```bash\n# Check if we're in a conflicted rebase state\nls .git/rebase-merge 2\u003e/dev/null \u0026\u0026 echo \"CONFLICT_STATE\"\n```\n\n**Step 3: Handle conflicts (if any)**\n\nIf rebase SUCCEEDED (exit code 0):\n- Skip to run-tests step (continue normal merge flow)\n\nIf rebase FAILED with conflicts:\n\n1. **Abort the rebase** (DO NOT leave repo in conflicted state):\n```bash\ngit rebase --abort\n```\n\n2. **Record conflict metadata**:\n```bash\n# Capture target SHA for reference\nTARGET_SHA=$(git rev-parse origin/\u003crebase-target\u003e)\nBRANCH_SHA=$(git rev-parse origin/\u003cpolecat-branch\u003e)\n```\n\n3. **Create conflict-resolution task**:\n```bash\nbd create --type=task --priority=1 --title=\"Resolve merge conflicts: \u003coriginal-issue-title\u003e\" --description=\"## Conflict Resolution Required\n\nOriginal MR: \u003cmr-bead-id\u003e\nBranch: \u003cpolecat-branch\u003e\nOriginal Issue: \u003cissue-id\u003e\nConflict with target \u003crebase-target\u003e at: ${TARGET_SHA}\nBranch SHA: ${BRANCH_SHA}\n\n## Instructions\n1. Clone/checkout the branch\n2. Rebase on target: git rebase origin/\u003crebase-target\u003e\n3. Resolve conflicts\n4. Force push: git push -f origin \u003cbranch\u003e\n5. Close this task when done\n\nThe MR will be re-queued for processing after conflicts are resolved.\"\n```\n\n4. **Skip this MR** (do NOT delete branch or close MR bead):\n- Leave branch intact for conflict resolution\n- Leave MR bead open (will be re-processed after resolution)\n- Continue to loop-check for next branch\n\n**CRITICAL**: Never delete a branch that has conflicts. The branch contains\nthe original work and must be preserved for conflict resolution.\n\nTrack: rebase result (success/conflict), conflict task ID if created.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ka2f1","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Mechanical rebase","updated_at":"2026-02-28T09:31:42Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6c13a80e672c4e6ced6c05f5bbf72aeb746501362aba7c8df898024fc5cbe1aa","created_at":"2026-02-28T09:52:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Pick next branch from queue. Attempt mechanical rebase on the MR's effective target branch.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n\n**Step 0: Determine rebase target (must match merge target)**\n\nResolve `\u003crebase-target\u003e` using the **Target Resolution Rule** above.\nDo NOT hardcode `main` unless `main` is actually the resolved MR target.\n\n**Step 1: Checkout and attempt rebase**\n```bash\ngit checkout -b temp origin/\u003cpolecat-branch\u003e\ngit rebase origin/\u003crebase-target\u003e\n```\n\n**Step 2: Check rebase result**\n\nThe rebase exits with:\n- Exit code 0: Success - proceed to run-tests\n- Exit code 1 (conflicts): Conflict detected - proceed to Step 3\n\nTo detect conflict state after rebase fails:\n```bash\n# Check if we're in a conflicted rebase state\nls .git/rebase-merge 2\u003e/dev/null \u0026\u0026 echo \"CONFLICT_STATE\"\n```\n\n**Step 3: Handle conflicts (if any)**\n\nIf rebase SUCCEEDED (exit code 0):\n- Skip to run-tests step (continue normal merge flow)\n\nIf rebase FAILED with conflicts:\n\n1. **Abort the rebase** (DO NOT leave repo in conflicted state):\n```bash\ngit rebase --abort\n```\n\n2. **Record conflict metadata**:\n```bash\n# Capture target SHA for reference\nTARGET_SHA=$(git rev-parse origin/\u003crebase-target\u003e)\nBRANCH_SHA=$(git rev-parse origin/\u003cpolecat-branch\u003e)\n```\n\n3. **Create conflict-resolution task**:\n```bash\nbd create --type=task --priority=1 --title=\"Resolve merge conflicts: \u003coriginal-issue-title\u003e\" --description=\"## Conflict Resolution Required\n\nOriginal MR: \u003cmr-bead-id\u003e\nBranch: \u003cpolecat-branch\u003e\nOriginal Issue: \u003cissue-id\u003e\nConflict with target \u003crebase-target\u003e at: ${TARGET_SHA}\nBranch SHA: ${BRANCH_SHA}\n\n## Instructions\n1. Clone/checkout the branch\n2. Rebase on target: git rebase origin/\u003crebase-target\u003e\n3. Resolve conflicts\n4. Force push: git push -f origin \u003cbranch\u003e\n5. Close this task when done\n\nThe MR will be re-queued for processing after conflicts are resolved.\"\n```\n\n4. **Skip this MR** (do NOT delete branch or close MR bead):\n- Leave branch intact for conflict resolution\n- Leave MR bead open (will be re-processed after resolution)\n- Continue to loop-check for next branch\n\n**CRITICAL**: Never delete a branch that has conflicts. The branch contains\nthe original work and must be preserved for conflict resolution.\n\nTrack: rebase result (success/conflict), conflict task ID if created.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-kbx2u","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Mechanical rebase","updated_at":"2026-02-28T09:52:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3560d7b1a900af0fa671383af7df139375a27ea4969d5ef8a8fe144df9a317b1","created_at":"2026-02-28T09:03:32Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Full polecat work lifecycle from assignment through completion.\n\nThis molecule guides a polecat through a complete work assignment. Each step\nhas clear entry/exit criteria and specific commands to run. A polecat can\ncrash after any step and resume from the last completed step.\n\n## Polecat Contract (Self-Cleaning Model)\n\nYou are a self-cleaning worker. You:\n1. Receive work via your hook (pinned molecule + issue)\n2. Work through molecule steps using `bd mol current` / `bd close \u003cstep\u003e`\n3. Complete and self-clean via `gt done` (submit + nuke yourself)\n4. You are GONE - Refinery merges from MQ\n\n**Self-cleaning:** When you run `gt done`, you push your work, submit to MQ,\nnuke your sandbox, and exit. There is no idle state. Done means gone.\n\n**Important:** This formula defines the template. Your molecule already has step\nbeads created from it. Use `gt hook` to find your pinned molecule, then `bd show`\nfor step details — do NOT read this file directly.\n\n**You do NOT:**\n- Push directly to main (Refinery merges from MQ)\n- Close your own issue (Refinery closes after merge)\n- Wait for merge (you're gone after `gt done`)\n- Handle rebase conflicts (Refinery spawns fresh polecats for that)\n\n## Variables\n\n| Variable | Source | Description |\n|----------|--------|-------------|\n| issue | hook_bead | The issue ID you're assigned to work on |\n| base_branch | sling vars | The base branch to rebase on (default: main) |\n| setup_command | rig config | Setup/install command (e.g., `pnpm install`). Empty = skip. |\n| typecheck_command | rig config | Type check command (e.g., `tsc --noEmit`). Empty = skip. |\n| test_command | rig config | Test command. Empty = skip. Rig must configure for its language. |\n| lint_command | rig config | Lint command (e.g., `eslint .`). Empty = skip. |\n| build_command | rig config | Build command (e.g., `go build ./...`). Empty = skip. |\n\n## Failure Modes\n\n| Situation | Action |\n|-----------|--------|\n| Tests fail | Fix them. Do not proceed with failures. |\n| Blocked on external | Mail Witness for help, mark yourself stuck |\n| Context filling | Use gt handoff to cycle to fresh session |\n| Unsure what to do | Mail Witness, don't guess |","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-kdk7d","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"mol-polecat-work","updated_at":"2026-02-28T09:03:32Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"08a9203f5a61045888f0a3f59a1e662d6099816dd7eeb7b52193b55395288c45","created_at":"2026-02-28T09:30:15Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Assess whether this session should continue or hand off to a fresh one.\n\n**Gather signals:**\n\n1. **Process memory** — check your own RSS:\n```bash\nps -o rss= -p $$   # KB — divide by 1024 for MB\n```\n\n2. **Session age** — how long has this tmux session been running:\n```bash\nCREATED=$(tmux display-message -t $(tmux display-message -p '#S') -p '#{session_created}')\necho \"Session age: $(( ($(date +%s) - CREATED) / 3600 ))h\"\n```\n\n3. **Context usage** — your internal sense of how much context you've consumed.\nAre you losing track of earlier conversation? Getting verbose? Repeating yourself?\n\n4. **Work done this cycle** — how many merges, how much complexity processed.\n\n**The principle:** Fresh sessions are cheap. Memory bloat compounds over time and\naffects the entire system — other agents, Dolt, and the OS all share the same RAM.\nAn idle session at 1.5 GB is worse than cycling and restarting at 200 MB.\n\n**Make a judgment call.** If multiple signals suggest you're getting heavy\n(high RSS, long session, substantial context consumed), hand off. If you're\nlight and there's active work in the queue, continue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-kf1nb","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Assess session health","updated_at":"2026-02-28T09:30:15Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a256b80855afd3ac284a3902b23415a9b78a62c489f52e7491b2b3e9db95bc90","created_at":"2026-02-28T09:30:15Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check mail for MERGE_READY submissions, escalations, and messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**MERGE_READY**:\nA polecat's work is ready for merge. Extract details and track for processing.\n\n```bash\n# Parse MERGE_READY message body:\n# Branch: \u003cbranch\u003e\n# Issue: \u003cissue-id\u003e\n# Polecat: \u003cpolecat-name\u003e\n# MR: \u003cmr-bead-id\u003e\n# Verified: clean git state, issue closed\n\n# Track in your merge queue for this patrol cycle:\n# - Branch name\n# - Issue ID\n# - Polecat name (REQUIRED for MERGED notification)\n# - MR bead ID (REQUIRED for closing after merge)\n```\n\n**IMPORTANT**: You MUST track the polecat name, MR bead ID, AND message ID - you will need them\nin merge-push step to send MERGED notification, close the MR bead, and archive the mail.\n\nMark as read. The work will be processed in queue-scan/process-branch.\n**Do NOT archive yet** - archive after merge/reject decision in merge-push step.\n\n**PATROL: Wake up**:\nWitness detected MRs waiting but refinery idle. Acknowledge and archive:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HELP / Blocked**:\nAssess and respond. If you can't help, escalate to Mayor.\nArchive after handling:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Check for in-flight merges.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: pending MRs in queue. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-kndlq","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery mail","updated_at":"2026-02-28T09:30:15Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a256b80855afd3ac284a3902b23415a9b78a62c489f52e7491b2b3e9db95bc90","created_at":"2026-02-28T09:52:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check mail for MERGE_READY submissions, escalations, and messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**MERGE_READY**:\nA polecat's work is ready for merge. Extract details and track for processing.\n\n```bash\n# Parse MERGE_READY message body:\n# Branch: \u003cbranch\u003e\n# Issue: \u003cissue-id\u003e\n# Polecat: \u003cpolecat-name\u003e\n# MR: \u003cmr-bead-id\u003e\n# Verified: clean git state, issue closed\n\n# Track in your merge queue for this patrol cycle:\n# - Branch name\n# - Issue ID\n# - Polecat name (REQUIRED for MERGED notification)\n# - MR bead ID (REQUIRED for closing after merge)\n```\n\n**IMPORTANT**: You MUST track the polecat name, MR bead ID, AND message ID - you will need them\nin merge-push step to send MERGED notification, close the MR bead, and archive the mail.\n\nMark as read. The work will be processed in queue-scan/process-branch.\n**Do NOT archive yet** - archive after merge/reject decision in merge-push step.\n\n**PATROL: Wake up**:\nWitness detected MRs waiting but refinery idle. Acknowledge and archive:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HELP / Blocked**:\nAssess and respond. If you can't help, escalate to Mayor.\nArchive after handling:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Check for in-flight merges.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: pending MRs in queue. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-kq68m","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery mail","updated_at":"2026-02-28T09:52:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"cd04eafd6cb3229e545c808f5c4de8961b95bb943104a4d5769ed7d9069b3c8c","created_at":"2026-02-28T09:42:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nInbox should contain ONLY:\n- Unprocessed MERGE_READY messages (will process next cycle)\n- Active work items\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- PATROL: Wake up that was acknowledged → archive\n- HELP/Blocked that was handled → archive\n- MERGE_READY where merge completed but archive was missed → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Check for orphaned MR beads**\n\nLook for open MR beads with no corresponding branch:\n```bash\nbd list --type=merge-request --status=open\n```\n\nFor each open MR bead:\n1. Check if branch exists: `git ls-remote origin refs/heads/\u003cbranch\u003e`\n2. Determine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n3. If branch is gone, pick `\u003cverification-target\u003e`:\n   - If `origin/\u003cmerge-target\u003e` exists, use `\u003cmerge-target\u003e`.\n   - If `origin/\u003cmerge-target\u003e` is missing (e.g. deleted integration branch), use `main`.\n4. Verify landed work: `git log origin/\u003cverification-target\u003e --oneline | grep \"\u003csource_issue\u003e\"`\n5. If work found → close MR with reason \"Merged (verified on \u003cverification-target\u003e; merge target was \u003cmerge-target\u003e)\"\n6. If work NOT found → investigate before closing:\n   - Check source_issue validity (should be gt-xxxxx, not branch name)\n   - Search reflog/dangling commits if possible\n   - If unverifiable, close with reason \"Unverifiable - no audit trail\"\n   - File bead if this indicates lost work\n\n**NEVER close an MR bead without verifying the work landed or is unrecoverable.**\n\n**Goal**: Inbox should have ≤3 active messages at end of cycle.\nKeep only: pending MRs in queue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ksqvr","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T09:42:52Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"cd04eafd6cb3229e545c808f5c4de8961b95bb943104a4d5769ed7d9069b3c8c","created_at":"2026-02-28T09:53:04Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nInbox should contain ONLY:\n- Unprocessed MERGE_READY messages (will process next cycle)\n- Active work items\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- PATROL: Wake up that was acknowledged → archive\n- HELP/Blocked that was handled → archive\n- MERGE_READY where merge completed but archive was missed → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Check for orphaned MR beads**\n\nLook for open MR beads with no corresponding branch:\n```bash\nbd list --type=merge-request --status=open\n```\n\nFor each open MR bead:\n1. Check if branch exists: `git ls-remote origin refs/heads/\u003cbranch\u003e`\n2. Determine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n3. If branch is gone, pick `\u003cverification-target\u003e`:\n   - If `origin/\u003cmerge-target\u003e` exists, use `\u003cmerge-target\u003e`.\n   - If `origin/\u003cmerge-target\u003e` is missing (e.g. deleted integration branch), use `main`.\n4. Verify landed work: `git log origin/\u003cverification-target\u003e --oneline | grep \"\u003csource_issue\u003e\"`\n5. If work found → close MR with reason \"Merged (verified on \u003cverification-target\u003e; merge target was \u003cmerge-target\u003e)\"\n6. If work NOT found → investigate before closing:\n   - Check source_issue validity (should be gt-xxxxx, not branch name)\n   - Search reflog/dangling commits if possible\n   - If unverifiable, close with reason \"Unverifiable - no audit trail\"\n   - File bead if this indicates lost work\n\n**NEVER close an MR bead without verifying the work landed or is unrecoverable.**\n\n**Goal**: Inbox should have ≤3 active messages at end of cycle.\nKeep only: pending MRs in queue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-kzfnb","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T09:53:04Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T08:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-l1m0q","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T08:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:08:19Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T10:06:06Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-l7b00","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T10:08:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b5b41d316559ab36d81b013937c0b56a205c257b0f96499632c4e34fb4d420c5","created_at":"2026-02-28T09:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check the beads merge queue - this is the SOURCE OF TRUTH for pending merges.\n\n```bash\ngit fetch --prune origin\ngt mq list \u003crig\u003e\n```\n\nThe beads MQ tracks all pending merge requests. Do NOT rely on `git branch -r | grep polecat`\nas branches may exist without MR beads, or MR beads may exist for already-merged work.\n\nIf queue empty, skip to \"check-integration-branches\" step.\n\nFor each MR in the queue, verify the branch still exists:\n```bash\ngit branch -r | grep \u003cbranch\u003e\n```\n\nIf branch doesn't exist for a queued MR:\n- Close the MR bead: `bd close \u003cmr-id\u003e --reason \"Branch no longer exists\"`\n- Remove from processing queue\n\nTrack verified MR list for this cycle.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-lgmsb","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Scan merge queue","updated_at":"2026-02-28T09:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T09:37:14Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-lhhb8","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T09:37:14Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e731efa93a5c9d5231a98d88586801bc0b5c8709c7cbb6b28d4f7ffe6efd1fd1","created_at":"2026-02-28T09:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: run_tests = true**\n**Config: test_command = go test ./...**\n**Config: setup_command = **\n**Config: typecheck_command = **\n**Config: lint_command = **\n**Config: build_command = **\n\n**1. Run quality checks (skip any that are not configured):**\n\nIf setup_command is set: ``\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf build_command is set: ``\n\n```bash\n           # Make sure all newly added dependencies are installed (if command set)\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n           # Make sure it builds (if command set)\n```\n\nEmpty commands mean \"not configured for this project\" — skip silently.\n\n**2. If quality checks fail:**\n\nProceed to handle-failures step. Track which specific check failed\n(setup/typecheck/lint/build) for the failure diagnosis.\n\n**3. Run the test suite:**\n\nIf run_tests = \"false\": Skip this step entirely. Proceed to handle-failures.\n\nIf run_tests = \"true\":\n\n```bash\ngo test ./...            # Run tests (configured per-rig)\n```\n\nTrack results: pass count, fail count, specific failures.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-lhwmg","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Run quality checks and tests","updated_at":"2026-02-28T09:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T09:06:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-lnw0w","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T09:06:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/refinery","await_id":"","await_type":"","close_reason":"patrol cycle complete: Queue empty. Idle cycle 5 (5m max timeout). No merges.","closed_at":"2026-02-28T10:06:30Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e744710b4b5ddcfb1d9a3a957426a87d9b75eb6767d23eed49c763c3fc88e58e","created_at":"2026-02-28T10:01:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Patrol report: Queue empty. Idle cycle 5 (5m max timeout). No merges.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-lp74x","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"mol-refinery-patrol","updated_at":"2026-02-28T10:06:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:00:22Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T09:54:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-lwjcg","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T10:00:22Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:08:19Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T10:06:06Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-m64a7","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T10:08:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"795f0417d343e9f29be619802ae3b5a11e7a901e2fde88ff9b9528a3bb8c0e2d","created_at":"2026-02-28T10:06:30Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Summarize this patrol cycle.\n\n**VERIFICATION**: Before generating summary, confirm for each merged branch:\n- [ ] MERGED mail was sent to witness\n- [ ] MR bead was closed\n- [ ] Source issue was closed\n- [ ] MERGE_READY mail archived\n\nIf any notifications, closures, or archiving were missed, do them now!\n\nInclude in summary:\n- Branches merged (count, names)\n- MERGED mails sent (count - should match branches merged)\n- MR beads closed (count - should match branches merged)\n- Source issues closed (count - should match branches merged)\n- MERGE_READY mails archived (count - should match branches merged)\n- Test results (pass/fail)\n- Branches with conflicts (count, names)\n- Conflict-resolution tasks created (IDs)\n- Issues filed (if any)\n- Any escalations sent\n\n**Conflict tracking is important** for monitoring MQ health. If many branches\nconflict, it may indicate target branches are moving too fast or branches are too stale.\n\nThis becomes the digest when the patrol is squashed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-m9nnz","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Generate handoff summary","updated_at":"2026-02-28T10:06:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/refinery","await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e744710b4b5ddcfb1d9a3a957426a87d9b75eb6767d23eed49c763c3fc88e58e","created_at":"2026-02-28T10:06:30Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Merge queue processor patrol loop.\n\nThe Refinery is the Engineer in the engine room. You process polecat branches, merging them to their effective target branches one at a time with sequential rebasing.\n\n**The Scotty Test**: Before proceeding past any failure, ask yourself: \"Would Scotty walk past a warp core leak because it existed before his shift?\"\n\n## Merge Flow\n\nThe Refinery receives MERGE_READY mail from Witnesses when polecats complete work:\n\n```\nWitness                    Refinery                      Git\n   │                          │                           │\n   │ MERGE_READY              │                           │\n   │─────────────────────────\u003e│                           │\n   │                          │                           │\n   │                    (verify branch)                   │\n   │                          │ fetch \u0026 rebase            │\n   │                          │──────────────────────────\u003e│\n   │                          │                           │\n   │                    (run tests)                       │\n   │                          │                           │\n   │                    (if pass)                         │\n   │                          │ merge \u0026 push              │\n   │                          │──────────────────────────\u003e│\n   │                          │                           │\n   │ MERGED                   │                           │\n   │\u003c─────────────────────────│                           │\n   │                          │                           │\n```\n\nAfter successful merge, Refinery sends MERGED mail back to Witness so it can\ncomplete cleanup (nuke the polecat worktree).\n\n## CRITICAL: Read Step Instructions Before Acting\n\nBefore executing ANY step, you MUST run `bd show \u003cstep-id\u003e` and read the full\ndescription. Steps contain **Config:** values that override default behavior.\nIf a config says to skip, you skip. If it specifies a command, you use that\nexact command — not your own assumption. Do NOT guess what a step requires\nbased on the step title or your role knowledge. The step description is the\nsource of truth.\n\n## Variables\n\n| Variable | Default | Description |\n|----------|---------|-------------|\n| wisp_type | patrol | Type of wisp created for this molecule |\n| integration_branch_refinery_enabled | true | Whether refinery merges to integration branches |\n| integration_branch_auto_land | false | Whether to auto-land integration branches when epic children all closed |\n| run_tests | true | Whether to run tests before merging |\n| setup_command | (empty) | Setup/install command (e.g., `pnpm install`). Empty = skip. |\n| typecheck_command | (empty) | Type check command (e.g., `tsc --noEmit`). Empty = skip. |\n| lint_command | (empty) | Lint command (e.g., `eslint .`). Empty = skip. |\n| test_command | go test ./... | Test command to run (if run_tests is true) |\n| build_command | (empty) | Build command (e.g., `go build ./...`). Empty = skip. |\n| target_branch | main | Default target branch for merges |\n| delete_merged_branches | true | Whether to delete source branches after merge |\n\n## Target Resolution Rule\n\nWhen instructions reference `\u003crebase-target\u003e`, `\u003cmerge-target\u003e`, or `\u003cverification-target\u003e`,\nresolve that placeholder with this rule:\n\n- If integration_branch_refinery_enabled = \"true\": use MR target when present, otherwise main.\n- If integration_branch_refinery_enabled = \"false\": always use main.\n\n## FORBIDDEN Actions\n\n- FORBIDDEN: Landing integration branches to the default branch via raw git commands (`git merge`, `git push`).\n  Integration branches may ONLY be landed via `gt mq integration land \u003cepic-id\u003e`.\n  This applies regardless of `auto_land` configuration. The pre-push hook enforces this.\n\n## Step Execution Order\n\nYou MUST process steps in strict DAG order. Walk through each step sequentially,\nunless you are explicitly told to skip to a step.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-mb8b9","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"hooked","target":"","timeout_ns":0,"title":"mol-refinery-patrol","updated_at":"2026-02-28T10:06:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f0806f4a1273b57425becdefa22736afaabef523639e7737c07e1d843388101e","created_at":"2026-02-28T08:56:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Review your own changes before running tests.\n\n**1. Review the diff:**\n```bash\ngit diff origin/main...HEAD     # All changes vs main\ngit log --oneline origin/main..HEAD  # All commits\n```\n\n**2. Check for common issues:**\n\n| Category | Look For |\n|----------|----------|\n| Bugs | Off-by-one, null handling, edge cases |\n| Security | Injection, auth bypass, exposed secrets |\n| Style | Naming, formatting, code organization |\n| Completeness | Missing error handling, incomplete paths |\n| Cruft | Debug prints, commented code, TODOs |\n\n**3. Refactor check:**\n\nAsk yourself:\n- Does this implementation duplicate logic that already exists elsewhere?\n- Are there names, abstractions, or structures that will confuse the next person?\n- Would you be embarrassed to show this diff to a senior engineer?\n\nIf yes to any — fix it now. Refactoring is part of the work, not a luxury.\nCommit any refactoring separately: `git commit -m \"refactor: \u003cdescription\u003e (cue-sx0)\"`\n\n**4. Fix issues found:**\nDon't just note them - fix them now. Amend or add commits as needed.\n\n**5. Verify no unintended changes:**\n```bash\ngit diff --stat origin/main...HEAD\n# Only files relevant to cue-sx0 should appear\n```\n\nIf you accidentally modified unrelated files, remove those changes.\n\n**Exit criteria:** Changes are clean, reviewed, refactored where needed, and ready for testing.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-mpbwe","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Self-review changes","updated_at":"2026-02-28T08:56:25Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"cd04eafd6cb3229e545c808f5c4de8961b95bb943104a4d5769ed7d9069b3c8c","created_at":"2026-02-28T09:31:42Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nInbox should contain ONLY:\n- Unprocessed MERGE_READY messages (will process next cycle)\n- Active work items\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- PATROL: Wake up that was acknowledged → archive\n- HELP/Blocked that was handled → archive\n- MERGE_READY where merge completed but archive was missed → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Check for orphaned MR beads**\n\nLook for open MR beads with no corresponding branch:\n```bash\nbd list --type=merge-request --status=open\n```\n\nFor each open MR bead:\n1. Check if branch exists: `git ls-remote origin refs/heads/\u003cbranch\u003e`\n2. Determine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n3. If branch is gone, pick `\u003cverification-target\u003e`:\n   - If `origin/\u003cmerge-target\u003e` exists, use `\u003cmerge-target\u003e`.\n   - If `origin/\u003cmerge-target\u003e` is missing (e.g. deleted integration branch), use `main`.\n4. Verify landed work: `git log origin/\u003cverification-target\u003e --oneline | grep \"\u003csource_issue\u003e\"`\n5. If work found → close MR with reason \"Merged (verified on \u003cverification-target\u003e; merge target was \u003cmerge-target\u003e)\"\n6. If work NOT found → investigate before closing:\n   - Check source_issue validity (should be gt-xxxxx, not branch name)\n   - Search reflog/dangling commits if possible\n   - If unverifiable, close with reason \"Unverifiable - no audit trail\"\n   - File bead if this indicates lost work\n\n**NEVER close an MR bead without verifying the work landed or is unrecoverable.**\n\n**Goal**: Inbox should have ≤3 active messages at end of cycle.\nKeep only: pending MRs in queue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-mrb6q","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T09:31:42Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:08:19Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T10:06:06Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-n05je","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T10:08:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"1ac29a06ed4f1cd6aa9ec126b82f89d0386378e81870a408fdfe352922b96d6c","created_at":"2026-02-28T08:56:26Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify work is complete and ready for merge queue.\n\n**Note:** Do NOT close the issue. The Refinery will close it after successful merge.\nThis enables conflict-resolution retries without reopening closed issues.\n\n**1. Verify the issue shows your work:**\n```bash\nbd show cue-26p\n# Status should still be 'in_progress' (you're working on it)\n```\n\n**2. Add completion notes:**\n```bash\nbd update cue-26p --notes \"Implemented: \u003cbrief summary of what was done\u003e\"\n```\n\n**3. Sync beads:**\n```bash\nbd sync\n```\n\n**Exit criteria:** Issue updated with completion notes, beads synced.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-n2how","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Prepare work for review","updated_at":"2026-02-28T08:56:26Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T08:59:05Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-n4dne","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T08:59:05Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T09:37:14Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-n8g36","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T09:37:14Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T10:08:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-nlhkr","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T10:08:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T09:09:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-npf2d","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T09:09:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T09:04:31Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-npjbe","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T09:04:31Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T09:09:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-nsz07","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T09:09:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T08:54:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ntsrb","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T08:54:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"ae86c9678fe046ab78444f8c1bfb54ddbbb6467e16c4c0e254724d7eaf2a9b4b","created_at":"2026-02-28T09:03:32Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure you're on a clean feature branch ready for work.\n\n**1. Check current branch state:**\n```bash\ngit status\ngit branch --show-current\n```\n\n**2. If not on a feature branch, create one:**\n```bash\ngit fetch origin\ngit checkout -b polecat/\u003cname\u003e origin/main\n```\n\n**3. Ensure clean working state:**\n```bash\ngit status                  # Should show \"working tree clean\"\ngit stash list              # Should be empty\n```\n\nIf dirty state from previous work:\n```bash\n# If changes are relevant to this issue:\ngit add -A \u0026\u0026 git commit -m \"WIP: \u003cdescription\u003e\"\n\n# If changes are unrelated cruft:\ngit stash push -m \"unrelated changes before cue-df8\"\n# Or discard if truly garbage:\ngit checkout -- .\n```\n\n**4. Sync with main:**\n```bash\ngit fetch origin\ngit rebase origin/main      # Get latest, rebase your branch\n```\n\nIf rebase conflicts:\n- Resolve them carefully\n- Test after resolution\n- If stuck, mail Witness\n\n**5. Run project setup (if configured):**\n\nIf setup_command is set, run it to install dependencies:\n```bash\n\n```\n\nThis ensures dependencies are installed before pre-flight checks.\nEmpty setup_command means \"not configured\" — skip this step.\n\n**Exit criteria:** You're on a clean feature branch, rebased on latest main, dependencies installed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ntzc7","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Set up working branch","updated_at":"2026-02-28T09:03:32Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T08:59:50Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-nv7in","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T08:59:50Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9742ae1fab9e73984581e4aacf23f1a5675564600ae2da6e3e08eb76135a7ed5","created_at":"2026-02-28T09:30:15Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: integration_branch_refinery_enabled = true**\n**Config: integration_branch_auto_land = false**\n\nRead the two config values above, then:\n\n- If integration_branch_refinery_enabled = \"false\": Say \"Integration branches disabled.\" Close step.\n- If integration_branch_auto_land = \"false\": Say \"Auto-land disabled, nothing to do.\" Close step.\n  FORBIDDEN: If auto_land is false, you MUST NOT land integration branches yourself using\n  raw git commands. Do not merge integration branches to the default/target branch. Do not push\n  integration branch merges. The auto_land=false setting means landing requires a human\n  to run `gt mq integration land` manually. Respect this boundary unconditionally.\n- If BOTH are \"true\":\n  1. `bd list --type=epic --status=open` to find epics\n  2. `gt mq integration status \u003cepic-id\u003e` for each epic\n  3. If `ready_to_land: true`: run `gt mq integration land \u003cepic-id\u003e`\n  4. If `ready_to_land: false`: do nothing, epic work is incomplete\n  Never land partial epics — ALL children must be closed first.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-nxrbc","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check integration branches for landing","updated_at":"2026-02-28T09:30:15Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T09:30:41Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-nxvn0","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T09:30:41Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T08:54:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-o7pdl","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T08:54:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"c5650e129e1528a106bb499e62f7e772b13b66d8eb50a55fccae7339d306a93d","created_at":"2026-02-28T08:56:26Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Submit your work and clean up. You cease to exist after this step.\n\n**Self-Cleaning Model:**\nOnce you run `gt done`, you're gone. The command:\n1. Pushes your branch to origin\n2. Creates an MR bead in the merge queue\n3. Nukes your sandbox (worktree removal)\n4. Exits your session immediately\n\n**Run gt done:**\n```bash\ngt done\n```\n\nYou should see output like:\n```\n✓ Work submitted to merge queue\n  MR ID: gt-xxxxx\n  Source: polecat/\u003cname\u003e\n  Target: main\n  Issue: cue-6ni\n✓ Sandbox nuked\n✓ Session exiting\n```\n\n**What happens next (not your concern):**\n- Refinery processes your MR from the queue\n- Refinery rebases and merges to main\n- Refinery closes the issue\n- If conflicts: Refinery spawns a FRESH polecat to re-implement\n\nYou are NOT involved in any of that. You're gone. Done means gone.\n\n**Exit criteria:** Work submitted, sandbox nuked, session exited.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-o8alo","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"in_progress","target":"","timeout_ns":0,"title":"Submit work and self-clean","updated_at":"2026-02-28T09:00:24Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:00:01Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T09:54:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-o9o5c","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T10:00:01Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:06:01Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T10:04:18Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-of1mo","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T10:06:01Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"8737a17b7bb92b8ec869791fdc3b4b1a68c31173ee93d4a430e37833f7a04f61","created_at":"2026-02-28T09:42:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Merge and push. CRITICAL: Notifications come IMMEDIATELY after push.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n**Config: delete_merged_branches = true**\n\n**Step 1: Merge and Push**\nDetermine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n```bash\ngit checkout \u003cmerge-target\u003e\ngit merge --ff-only temp\ngit push origin \u003cmerge-target\u003e\n```\n\n**Step 1.5: VERIFY PUSH SUCCEEDED (CRITICAL - PATCH-003)**\n\nPush can fail silently (network, auth, hooks). IMMEDIATELY verify:\n```bash\ngit fetch origin\nLOCAL_SHA=$(git rev-parse \u003cmerge-target\u003e)\nREMOTE_SHA=$(git rev-parse origin/\u003cmerge-target\u003e)\necho \"Local:  $LOCAL_SHA\"\necho \"Remote: $REMOTE_SHA\"\n```\n\n**If SHAs match**: Push succeeded. Continue to Step 2.\n\n**If SHAs differ**: STOP. Push failed silently.\n- DO NOT send MERGED notification\n- DO NOT close MR bead\n- DO NOT delete branch\n- Debug the push failure (check `git push` output, network, auth)\n- Retry push and verify again before proceeding\n\n⚠️ **STOP HERE - DO NOT PROCEED UNTIL STEPS 1.5 AND 2-3 COMPLETE**\n\n**Step 2: Send MERGED Notification (REQUIRED - DO THIS IMMEDIATELY)**\n\nRIGHT NOW, before any cleanup, send MERGED mail to Witness:\n\n```bash\ngt mail send \u003crig\u003e/witness -s \"MERGED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\nMerged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n```\n\nThis signals the Witness to nuke the polecat worktree. WITHOUT THIS NOTIFICATION,\nPOLECAT WORKTREES ACCUMULATE INDEFINITELY AND THE LIFECYCLE BREAKS.\n\n**Step 3: Post-merge cleanup (REQUIRED — single command)**\n\nThis single command handles closing the MR bead, closing the source issue, and\ndeleting the remote polecat branch (respects delete_merged_branches config):\n\n```bash\ngt mq post-merge \u003crig\u003e \u003cmr-bead-id\u003e\n```\n\nThe MR bead ID was in the MERGE_READY message or find via:\n```bash\nbd list --type=merge-request --status=open | grep \u003cpolecat-name\u003e\n```\n\nVerify the command output shows all steps succeeded (✓ for each).\n\n**Step 4: Archive the MERGE_READY mail (REQUIRED)**\n```bash\ngt mail archive \u003cmerge-ready-message-id\u003e\n```\nThe message ID was tracked when you processed inbox-check.\n\n**Step 5: Cleanup temp branch**\n```bash\ngit branch -d temp\n```\n\n**VERIFICATION GATE**: You CANNOT proceed to loop-check without:\n- [x] MERGED mail sent to witness\n- [x] Post-merge cleanup completed (MR closed, source issue closed, branch deleted)\n- [x] MERGE_READY mail archived\n\nIf you skipped notifications or archiving, GO BACK AND DO THEM NOW.\n\nTarget branch has moved. Any remaining branches need rebasing on new baseline.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ofpnj","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Merge and push","updated_at":"2026-02-28T09:42:52Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e731efa93a5c9d5231a98d88586801bc0b5c8709c7cbb6b28d4f7ffe6efd1fd1","created_at":"2026-02-28T09:42:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: run_tests = true**\n**Config: test_command = go test ./...**\n**Config: setup_command = **\n**Config: typecheck_command = **\n**Config: lint_command = **\n**Config: build_command = **\n\n**1. Run quality checks (skip any that are not configured):**\n\nIf setup_command is set: ``\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf build_command is set: ``\n\n```bash\n           # Make sure all newly added dependencies are installed (if command set)\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n           # Make sure it builds (if command set)\n```\n\nEmpty commands mean \"not configured for this project\" — skip silently.\n\n**2. If quality checks fail:**\n\nProceed to handle-failures step. Track which specific check failed\n(setup/typecheck/lint/build) for the failure diagnosis.\n\n**3. Run the test suite:**\n\nIf run_tests = \"false\": Skip this step entirely. Proceed to handle-failures.\n\nIf run_tests = \"true\":\n\n```bash\ngo test ./...            # Run tests (configured per-rig)\n```\n\nTrack results: pass count, fail count, specific failures.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ojncm","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Run quality checks and tests","updated_at":"2026-02-28T09:42:52Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"c0b8fdc440a01e113aa2a2e86aecfbca1ecc186ede8139cb06168ef662432ab9","created_at":"2026-02-28T09:03:32Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify work is complete and ready for merge queue.\n\n**Note:** Do NOT close the issue. The Refinery will close it after successful merge.\nThis enables conflict-resolution retries without reopening closed issues.\n\n**1. Verify the issue shows your work:**\n```bash\nbd show cue-df8\n# Status should still be 'in_progress' (you're working on it)\n```\n\n**2. Add completion notes:**\n```bash\nbd update cue-df8 --notes \"Implemented: \u003cbrief summary of what was done\u003e\"\n```\n\n**3. Sync beads:**\n```bash\nbd sync\n```\n\n**Exit criteria:** Issue updated with completion notes, beads synced.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ojvyx","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Prepare work for review","updated_at":"2026-02-28T09:03:32Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T08:54:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ollr1","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T08:54:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a256b80855afd3ac284a3902b23415a9b78a62c489f52e7491b2b3e9db95bc90","created_at":"2026-02-28T09:53:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check mail for MERGE_READY submissions, escalations, and messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**MERGE_READY**:\nA polecat's work is ready for merge. Extract details and track for processing.\n\n```bash\n# Parse MERGE_READY message body:\n# Branch: \u003cbranch\u003e\n# Issue: \u003cissue-id\u003e\n# Polecat: \u003cpolecat-name\u003e\n# MR: \u003cmr-bead-id\u003e\n# Verified: clean git state, issue closed\n\n# Track in your merge queue for this patrol cycle:\n# - Branch name\n# - Issue ID\n# - Polecat name (REQUIRED for MERGED notification)\n# - MR bead ID (REQUIRED for closing after merge)\n```\n\n**IMPORTANT**: You MUST track the polecat name, MR bead ID, AND message ID - you will need them\nin merge-push step to send MERGED notification, close the MR bead, and archive the mail.\n\nMark as read. The work will be processed in queue-scan/process-branch.\n**Do NOT archive yet** - archive after merge/reject decision in merge-push step.\n\n**PATROL: Wake up**:\nWitness detected MRs waiting but refinery idle. Acknowledge and archive:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HELP / Blocked**:\nAssess and respond. If you can't help, escalate to Mayor.\nArchive after handling:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Check for in-flight merges.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: pending MRs in queue. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-on7ro","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery mail","updated_at":"2026-02-28T09:53:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"af03f728cc1883159497207d4f3b63a1a386c7a5a3f85d9dc69b83f7f59fcaec","created_at":"2026-02-28T08:53:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check if the codebase is healthy BEFORE starting your work.\n\n**The Scotty Principle:** Don't walk past a broken warp core. But also don't\nlet someone else's mess consume your entire mission.\n\n**1. Run pre-flights on main:**\n\nYour branch was just created from or rebased on `origin/main` with no\nimplementation changes yet — you're already at the base branch state.\n\nRun each configured check, then tests:\n\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf test_command is set: ``\n\n```bash\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n            # Run tests (if command set)\n```\n\nEmpty commands mean \"not configured\" — skip silently.\n\n**2. If pre-flights pass:**\n\nContinue to implement step.\n\n**3. If pre-flights fail on main:**\n\nFile a bead and proceed. Do NOT fix pre-existing failures yourself — that is\nnot your assignment. Your job is to fix the issue on your hook, not main.\n\n| Situation | Action |\n|-----------|--------|\n| Any pre-existing failure | File bead, proceed with your work |\n\nFORBIDDEN: Pushing to main. FORBIDDEN: Fixing pre-existing failures.\nYou work on YOUR feature branch only. `gt done` handles push/MR.\n\n**File and proceed path:**\n```bash\nbd create --title \"Pre-existing failure: \u003cdescription\u003e\" --type bug --priority 1\n\ngt mail send \u003crig\u003e/witness -s \"NOTICE: main has failing pre-flights\" -m \"Found pre-existing failures on main.\nFiled: \u003cbead-id\u003e\nProceeding with my assigned work (cue-x7q).\"\n```\n\n**Context consideration:**\nIf investigating pre-existing failures consumed significant context:\n```bash\ngt handoff -s \"Investigated pre-existing failures, ready for assigned work\" -m \"Issue: cue-x7q\nFound: \u003cwhat failed\u003e\nReady to start: implement step\"\n```\nFresh session continues from implement.\n\n**Exit criteria:** Pre-flights pass on main (or issue filed), ready to implement.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-oodhw","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Verify pre-flights pass on base branch","updated_at":"2026-02-28T08:53:43Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"769447c96532d91233b37d97c63c883444ba63231b19c4d70e37300549e8b8af","created_at":"2026-02-28T09:53:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**VERIFICATION GATE**: This step enforces the Beads Promise.\n\nIf all checks and tests PASSED: This step auto-completes. Proceed to merge.\n\nIf any check or test FAILED:\n1. Diagnose: Is this a branch regression or pre-existing on the target branch?\n2. If branch caused it:\n   - Abort merge\n   - **REOPEN the source issue** so it returns to the ready queue:\n     ```bash\n     bd update \u003cissue-id\u003e --status=open --assignee=\"\"\n     bd sync\n     ```\n   - Notify witness of rejection using the MERGE_FAILED protocol:\n     ```bash\n     gt mail send \u003crig\u003e/witness -s \"MERGE_FAILED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\n     Issue: \u003cissue-id\u003e\n     Polecat: \u003cpolecat-name\u003e\n     Rig: \u003crig\u003e\n     FailureType: quality-check\n     Error: \u003cfailure description\u003e\"\n     ```\n   - Close the MR bead as rejected:\n     ```bash\n     bd close \u003cmr-bead-id\u003e --reason \"Rejected: \u003cfailure description\u003e\"\n     ```\n   - Delete the rejected branch (a new polecat will create a fresh one):\n     ```bash\n     git push origin --delete \u003cpolecat-branch\u003e\n     ```\n   - Archive the MERGE_READY message\n   - Skip to loop-check\n3. If pre-existing on the target branch:\n   - **DUPLICATE CHECK (MANDATORY)**: Before filing a new bug, search for existing open bugs:\n     ```bash\n     bd search \"\u003cfailure description\u003e\" --status open --label gt:bug --limit 5\n     ```\n     If an existing open bug covers the same failure, do NOT create a duplicate.\n     Instead, note the existing bead ID and proceed.\n   - Only if NO existing bug matches: bd create --type=bug --priority=1 --title=\"Pre-existing failure: \u003cdescription\u003e\"\n   - FORBIDDEN: Writing code to fix quality check or test failures. You merge branches, you do not develop.\n   - Proceed with the merge if the failure is pre-existing (not caused by the branch).\n\n**REJECTION CHECKLIST** (all required before skipping to loop-check):\n- [ ] Source issue reopened (bd update \u003cissue-id\u003e --status=open --assignee=\"\")\n- [ ] MERGE_FAILED notification sent to witness\n- [ ] MR bead closed with rejection reason\n- [ ] Rejected branch deleted from remote\n- [ ] MERGE_READY message archived\n\n**GATE REQUIREMENT**: You CANNOT proceed to merge-push without:\n- All quality checks and tests passing, OR\n- Bead filed (or existing duplicate confirmed) for the pre-existing failure\n\nFORBIDDEN: Writing application code, exploring polecat implementations, or\nre-implementing fixes. You are a mechanical merge processor.\n\nThis is non-negotiable. Never disavow. Never \"note and proceed.\" ","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-opor5","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Handle quality check or test failures","updated_at":"2026-02-28T09:53:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"fa8597c79e107b625b6bdf39d00dcd4d28221dd8e3e053d29dd919ff010f2af5","created_at":"2026-02-28T09:37:02Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify your changes don't break anything and are properly tested.\n\n**1. Run quality checks (skip any that are not configured):**\n\nIf setup_command is set: ``\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf build_command is set: ``\n\n```bash\n           # Make sure all newly added dependencies are installed (if command set)\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n            # Make sure it builds (if command set)\n```\n\nEmpty commands mean \"not configured for this project\" — skip silently.\n\n**2. If quality checks fail:**\n- Read the failure output carefully\n- Determine if your change caused it:\n  - If yes: Fix it. Return to implement step if needed.\n  - If no (pre-existing): File a bead, but still must pass for your PR\n\n```bash\n# Check if failure exists on main:\ngit stash\ngit checkout origin/main\n# Re-run the failing command(s)\ngit checkout -\ngit stash pop\n```\n\n**3. Run the full test suite:**\n\nYour base branch determines the required depth:\n- Targeting `main`: run the **full verification suite** including E2E tests\n- Targeting an integration branch: run the **unit test suite** only\n\n```bash\n# Targeting main — full verification required:\nif [ \"main\" = \"main\" ]; then\n  make verify\nelse\n  \nfi\n```\n\n**ALL TESTS MUST PASS.** Do not proceed with failures.\n\n**4. If tests fail:**\n- Read the failure output carefully\n- Determine if your change caused it:\n  - If yes: Fix it. Return to implement step if needed.\n  - If no (pre-existing): File a bead, but still must pass for your PR\n\n```bash\n# Check if failure exists on main:\ngit stash\ngit checkout origin/main\n\ngit checkout -\ngit stash pop\n```\n\n**5. Verify test coverage:**\n\nIf you followed TDD (as required in the implement step), your tests are already in place.\nIf for any reason you did not write tests first, you MUST add them now before proceeding.\n\nAsk yourself: \"If I broke this code tomorrow, would a test catch it?\"\nIf the answer is no, add the test now.\n\n**Exit criteria:** All quality checks and tests pass. Every behaviour change has a test. No exceptions.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-oq18j","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Run quality checks and tests","updated_at":"2026-02-28T09:37:02Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"8737a17b7bb92b8ec869791fdc3b4b1a68c31173ee93d4a430e37833f7a04f61","created_at":"2026-02-28T10:01:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Merge and push. CRITICAL: Notifications come IMMEDIATELY after push.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n**Config: delete_merged_branches = true**\n\n**Step 1: Merge and Push**\nDetermine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n```bash\ngit checkout \u003cmerge-target\u003e\ngit merge --ff-only temp\ngit push origin \u003cmerge-target\u003e\n```\n\n**Step 1.5: VERIFY PUSH SUCCEEDED (CRITICAL - PATCH-003)**\n\nPush can fail silently (network, auth, hooks). IMMEDIATELY verify:\n```bash\ngit fetch origin\nLOCAL_SHA=$(git rev-parse \u003cmerge-target\u003e)\nREMOTE_SHA=$(git rev-parse origin/\u003cmerge-target\u003e)\necho \"Local:  $LOCAL_SHA\"\necho \"Remote: $REMOTE_SHA\"\n```\n\n**If SHAs match**: Push succeeded. Continue to Step 2.\n\n**If SHAs differ**: STOP. Push failed silently.\n- DO NOT send MERGED notification\n- DO NOT close MR bead\n- DO NOT delete branch\n- Debug the push failure (check `git push` output, network, auth)\n- Retry push and verify again before proceeding\n\n⚠️ **STOP HERE - DO NOT PROCEED UNTIL STEPS 1.5 AND 2-3 COMPLETE**\n\n**Step 2: Send MERGED Notification (REQUIRED - DO THIS IMMEDIATELY)**\n\nRIGHT NOW, before any cleanup, send MERGED mail to Witness:\n\n```bash\ngt mail send \u003crig\u003e/witness -s \"MERGED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\nMerged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n```\n\nThis signals the Witness to nuke the polecat worktree. WITHOUT THIS NOTIFICATION,\nPOLECAT WORKTREES ACCUMULATE INDEFINITELY AND THE LIFECYCLE BREAKS.\n\n**Step 3: Post-merge cleanup (REQUIRED — single command)**\n\nThis single command handles closing the MR bead, closing the source issue, and\ndeleting the remote polecat branch (respects delete_merged_branches config):\n\n```bash\ngt mq post-merge \u003crig\u003e \u003cmr-bead-id\u003e\n```\n\nThe MR bead ID was in the MERGE_READY message or find via:\n```bash\nbd list --type=merge-request --status=open | grep \u003cpolecat-name\u003e\n```\n\nVerify the command output shows all steps succeeded (✓ for each).\n\n**Step 4: Archive the MERGE_READY mail (REQUIRED)**\n```bash\ngt mail archive \u003cmerge-ready-message-id\u003e\n```\nThe message ID was tracked when you processed inbox-check.\n\n**Step 5: Cleanup temp branch**\n```bash\ngit branch -d temp\n```\n\n**VERIFICATION GATE**: You CANNOT proceed to loop-check without:\n- [x] MERGED mail sent to witness\n- [x] Post-merge cleanup completed (MR closed, source issue closed, branch deleted)\n- [x] MERGE_READY mail archived\n\nIf you skipped notifications or archiving, GO BACK AND DO THEM NOW.\n\nTarget branch has moved. Any remaining branches need rebasing on new baseline.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-orrxj","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Merge and push","updated_at":"2026-02-28T10:01:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T09:04:31Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-oyfc1","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T09:04:31Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a9f06b8e1b407250bf709c200e59df2b0272b6bfc999431414281af9cef46349","created_at":"2026-02-28T09:54:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Create an annotated git tag.\n\n```bash\ngit tag -a v0.1.0 -m \"Release v0.1.0\"\n```\n\nVerify: `git tag -l | tail -5`\n","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-p0st5","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Create release tag","updated_at":"2026-02-28T09:54:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"dfab2e7b59734313316899e100837d3f7a1e7098c4c55ea83db66528f85eaefe","created_at":"2026-02-28T09:53:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"More branches to process?\n\n**Entry paths:**\n- Normal: After successful merge-push\n- Conflict-skip: After process-branch created conflict-resolution task\n\nIf yes: Return to process-branch with next branch.\nIf no: Continue to generate-summary.\n\n**Track for this cycle:**\n- branches_merged: count and names of successfully merged branches\n- branches_conflict: count and names of branches skipped due to conflicts\n- conflict_tasks: IDs of conflict-resolution tasks created\n\nThis tracking feeds into generate-summary for the patrol digest.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-p1woo","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check for more work","updated_at":"2026-02-28T09:53:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:02:59Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T10:00:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-p3vd4","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T10:02:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T08:57:59Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-p4fhl","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T08:57:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6c13a80e672c4e6ced6c05f5bbf72aeb746501362aba7c8df898024fc5cbe1aa","created_at":"2026-02-28T09:53:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Pick next branch from queue. Attempt mechanical rebase on the MR's effective target branch.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n\n**Step 0: Determine rebase target (must match merge target)**\n\nResolve `\u003crebase-target\u003e` using the **Target Resolution Rule** above.\nDo NOT hardcode `main` unless `main` is actually the resolved MR target.\n\n**Step 1: Checkout and attempt rebase**\n```bash\ngit checkout -b temp origin/\u003cpolecat-branch\u003e\ngit rebase origin/\u003crebase-target\u003e\n```\n\n**Step 2: Check rebase result**\n\nThe rebase exits with:\n- Exit code 0: Success - proceed to run-tests\n- Exit code 1 (conflicts): Conflict detected - proceed to Step 3\n\nTo detect conflict state after rebase fails:\n```bash\n# Check if we're in a conflicted rebase state\nls .git/rebase-merge 2\u003e/dev/null \u0026\u0026 echo \"CONFLICT_STATE\"\n```\n\n**Step 3: Handle conflicts (if any)**\n\nIf rebase SUCCEEDED (exit code 0):\n- Skip to run-tests step (continue normal merge flow)\n\nIf rebase FAILED with conflicts:\n\n1. **Abort the rebase** (DO NOT leave repo in conflicted state):\n```bash\ngit rebase --abort\n```\n\n2. **Record conflict metadata**:\n```bash\n# Capture target SHA for reference\nTARGET_SHA=$(git rev-parse origin/\u003crebase-target\u003e)\nBRANCH_SHA=$(git rev-parse origin/\u003cpolecat-branch\u003e)\n```\n\n3. **Create conflict-resolution task**:\n```bash\nbd create --type=task --priority=1 --title=\"Resolve merge conflicts: \u003coriginal-issue-title\u003e\" --description=\"## Conflict Resolution Required\n\nOriginal MR: \u003cmr-bead-id\u003e\nBranch: \u003cpolecat-branch\u003e\nOriginal Issue: \u003cissue-id\u003e\nConflict with target \u003crebase-target\u003e at: ${TARGET_SHA}\nBranch SHA: ${BRANCH_SHA}\n\n## Instructions\n1. Clone/checkout the branch\n2. Rebase on target: git rebase origin/\u003crebase-target\u003e\n3. Resolve conflicts\n4. Force push: git push -f origin \u003cbranch\u003e\n5. Close this task when done\n\nThe MR will be re-queued for processing after conflicts are resolved.\"\n```\n\n4. **Skip this MR** (do NOT delete branch or close MR bead):\n- Leave branch intact for conflict resolution\n- Leave MR bead open (will be re-processed after resolution)\n- Continue to loop-check for next branch\n\n**CRITICAL**: Never delete a branch that has conflicts. The branch contains\nthe original work and must be preserved for conflict resolution.\n\nTrack: rebase result (success/conflict), conflict task ID if created.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-p89c2","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Mechanical rebase","updated_at":"2026-02-28T09:53:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"212a3c112b936aa0250d2c0d6c295bc9d91d0e10c91e2d3f00329d14e1c64495","created_at":"2026-02-28T08:56:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure you're on a clean feature branch ready for work.\n\n**1. Check current branch state:**\n```bash\ngit status\ngit branch --show-current\n```\n\n**2. If not on a feature branch, create one:**\n```bash\ngit fetch origin\ngit checkout -b polecat/\u003cname\u003e origin/main\n```\n\n**3. Ensure clean working state:**\n```bash\ngit status                  # Should show \"working tree clean\"\ngit stash list              # Should be empty\n```\n\nIf dirty state from previous work:\n```bash\n# If changes are relevant to this issue:\ngit add -A \u0026\u0026 git commit -m \"WIP: \u003cdescription\u003e\"\n\n# If changes are unrelated cruft:\ngit stash push -m \"unrelated changes before cue-26p\"\n# Or discard if truly garbage:\ngit checkout -- .\n```\n\n**4. Sync with main:**\n```bash\ngit fetch origin\ngit rebase origin/main      # Get latest, rebase your branch\n```\n\nIf rebase conflicts:\n- Resolve them carefully\n- Test after resolution\n- If stuck, mail Witness\n\n**5. Run project setup (if configured):**\n\nIf setup_command is set, run it to install dependencies:\n```bash\n\n```\n\nThis ensures dependencies are installed before pre-flight checks.\nEmpty setup_command means \"not configured\" — skip this step.\n\n**Exit criteria:** You're on a clean feature branch, rebased on latest main, dependencies installed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-pas7b","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Set up working branch","updated_at":"2026-02-28T08:56:25Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9fd4f8fe6af19dea2254cbcfdca80525f6869f79b5dc6d06ecb32289bda67fe0","created_at":"2026-02-28T09:53:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision. Use the signals from context-check to decide.\n\n**If you decide to continue patrolling:**\n\nUse await-event to subscribe to the refinery event channel with exponential backoff:\n\n```bash\ngt mol step await-event --channel refinery --agent-bead gt-\u003crig\u003e-refinery --backoff-base 30s --backoff-mult 2 --backoff-max 5m --cleanup\n```\n\nThis command:\n1. Watches `~/gt/events/refinery/` for event files (polling-based)\n2. Returns IMMEDIATELY when an event is emitted (MERGE_READY, PATROL_WAKE, MQ_SUBMIT)\n3. If no events, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on refinery agent bead for backoff state\n5. `--cleanup` auto-deletes processed event files\n\n**Supported events:**\n- `MERGE_READY` — from witness when polecat branch is pushed and ready to merge\n- `PATROL_WAKE` — from witness when MRs waiting but refinery appears idle\n- `MQ_SUBMIT` — from polecat via `gt mq submit`\n\n**On event received** (refinery-specific activity):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no events):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-event returns (either by event or timeout):\n1. **Re-assess session health** (check RSS, context, age again — conditions change)\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary: branches merged, test results, queue state\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If you decide to hand off:**\n\nReport and exit using `gt handoff` for clean session transition:\n\n```bash\ngt handoff -s \"Patrol complete\" -m \"Merged X branches, Y tests passed.\nQueue: empty/N remaining\nRSS: X MB, Session age: Xh\nNext: [any notes for successor]\"\n```\n\n`gt handoff` sends handoff mail to yourself, respawns with a fresh Claude instance,\nSessionStart hook runs gt prime, and your successor picks up from the hook.\n\n**DO NOT just exit.** Always use `gt handoff` for proper lifecycle.\n\n**IMPORTANT**: Never sleep-poll manually (e.g., `sleep 30 \u0026\u0026 bd list`).\nAlways use `gt mol step await-event` — it's event-driven and tracks backoff state.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-pfuq5","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Burn and respawn or loop","updated_at":"2026-02-28T09:53:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"52f9af05f941132644e3b61657ab8527a08537fee480a6860e0154c699b10ae7","created_at":"2026-02-28T08:53:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Review your own changes before running tests.\n\n**1. Review the diff:**\n```bash\ngit diff origin/main...HEAD     # All changes vs main\ngit log --oneline origin/main..HEAD  # All commits\n```\n\n**2. Check for common issues:**\n\n| Category | Look For |\n|----------|----------|\n| Bugs | Off-by-one, null handling, edge cases |\n| Security | Injection, auth bypass, exposed secrets |\n| Style | Naming, formatting, code organization |\n| Completeness | Missing error handling, incomplete paths |\n| Cruft | Debug prints, commented code, TODOs |\n\n**3. Refactor check:**\n\nAsk yourself:\n- Does this implementation duplicate logic that already exists elsewhere?\n- Are there names, abstractions, or structures that will confuse the next person?\n- Would you be embarrassed to show this diff to a senior engineer?\n\nIf yes to any — fix it now. Refactoring is part of the work, not a luxury.\nCommit any refactoring separately: `git commit -m \"refactor: \u003cdescription\u003e (cue-x7q)\"`\n\n**4. Fix issues found:**\nDon't just note them - fix them now. Amend or add commits as needed.\n\n**5. Verify no unintended changes:**\n```bash\ngit diff --stat origin/main...HEAD\n# Only files relevant to cue-x7q should appear\n```\n\nIf you accidentally modified unrelated files, remove those changes.\n\n**Exit criteria:** Changes are clean, reviewed, refactored where needed, and ready for testing.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-pju0b","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Self-review changes","updated_at":"2026-02-28T08:53:43Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T08:59:50Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-pl05u","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T08:59:50Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T09:52:33Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T09:41:51Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-pt36o","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T09:52:33Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a597915d3a0a0c90b7f2c17589db4b633b03ce879a3bb3ad2eeb167804612ed4","created_at":"2026-02-28T09:54:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**This step only applies if nix build failed.**\n\nFor each failure:\n1. Create a bead: `bd create --title=\"\u003cfailure description\u003e\" --type=bug --priority=1`\n2. Dispatch a polecat: `gt sling \u003cbead-id\u003e claude_usage_exporter`\n3. Wait for fix, merge to main\n4. Re-run build\n\nOnly proceed when both builds are green.\n","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-pxel1","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Fix: Build failures","updated_at":"2026-02-28T09:54:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a256b80855afd3ac284a3902b23415a9b78a62c489f52e7491b2b3e9db95bc90","created_at":"2026-02-28T09:42:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check mail for MERGE_READY submissions, escalations, and messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**MERGE_READY**:\nA polecat's work is ready for merge. Extract details and track for processing.\n\n```bash\n# Parse MERGE_READY message body:\n# Branch: \u003cbranch\u003e\n# Issue: \u003cissue-id\u003e\n# Polecat: \u003cpolecat-name\u003e\n# MR: \u003cmr-bead-id\u003e\n# Verified: clean git state, issue closed\n\n# Track in your merge queue for this patrol cycle:\n# - Branch name\n# - Issue ID\n# - Polecat name (REQUIRED for MERGED notification)\n# - MR bead ID (REQUIRED for closing after merge)\n```\n\n**IMPORTANT**: You MUST track the polecat name, MR bead ID, AND message ID - you will need them\nin merge-push step to send MERGED notification, close the MR bead, and archive the mail.\n\nMark as read. The work will be processed in queue-scan/process-branch.\n**Do NOT archive yet** - archive after merge/reject decision in merge-push step.\n\n**PATROL: Wake up**:\nWitness detected MRs waiting but refinery idle. Acknowledge and archive:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HELP / Blocked**:\nAssess and respond. If you can't help, escalate to Mayor.\nArchive after handling:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Check for in-flight merges.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: pending MRs in queue. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-q3eob","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery mail","updated_at":"2026-02-28T09:42:52Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T08:59:05Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-qahj1","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T08:59:05Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T09:09:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-qe8ny","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T09:09:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"769447c96532d91233b37d97c63c883444ba63231b19c4d70e37300549e8b8af","created_at":"2026-02-28T09:53:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**VERIFICATION GATE**: This step enforces the Beads Promise.\n\nIf all checks and tests PASSED: This step auto-completes. Proceed to merge.\n\nIf any check or test FAILED:\n1. Diagnose: Is this a branch regression or pre-existing on the target branch?\n2. If branch caused it:\n   - Abort merge\n   - **REOPEN the source issue** so it returns to the ready queue:\n     ```bash\n     bd update \u003cissue-id\u003e --status=open --assignee=\"\"\n     bd sync\n     ```\n   - Notify witness of rejection using the MERGE_FAILED protocol:\n     ```bash\n     gt mail send \u003crig\u003e/witness -s \"MERGE_FAILED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\n     Issue: \u003cissue-id\u003e\n     Polecat: \u003cpolecat-name\u003e\n     Rig: \u003crig\u003e\n     FailureType: quality-check\n     Error: \u003cfailure description\u003e\"\n     ```\n   - Close the MR bead as rejected:\n     ```bash\n     bd close \u003cmr-bead-id\u003e --reason \"Rejected: \u003cfailure description\u003e\"\n     ```\n   - Delete the rejected branch (a new polecat will create a fresh one):\n     ```bash\n     git push origin --delete \u003cpolecat-branch\u003e\n     ```\n   - Archive the MERGE_READY message\n   - Skip to loop-check\n3. If pre-existing on the target branch:\n   - **DUPLICATE CHECK (MANDATORY)**: Before filing a new bug, search for existing open bugs:\n     ```bash\n     bd search \"\u003cfailure description\u003e\" --status open --label gt:bug --limit 5\n     ```\n     If an existing open bug covers the same failure, do NOT create a duplicate.\n     Instead, note the existing bead ID and proceed.\n   - Only if NO existing bug matches: bd create --type=bug --priority=1 --title=\"Pre-existing failure: \u003cdescription\u003e\"\n   - FORBIDDEN: Writing code to fix quality check or test failures. You merge branches, you do not develop.\n   - Proceed with the merge if the failure is pre-existing (not caused by the branch).\n\n**REJECTION CHECKLIST** (all required before skipping to loop-check):\n- [ ] Source issue reopened (bd update \u003cissue-id\u003e --status=open --assignee=\"\")\n- [ ] MERGE_FAILED notification sent to witness\n- [ ] MR bead closed with rejection reason\n- [ ] Rejected branch deleted from remote\n- [ ] MERGE_READY message archived\n\n**GATE REQUIREMENT**: You CANNOT proceed to merge-push without:\n- All quality checks and tests passing, OR\n- Bead filed (or existing duplicate confirmed) for the pre-existing failure\n\nFORBIDDEN: Writing application code, exploring polecat implementations, or\nre-implementing fixes. You are a mechanical merge processor.\n\nThis is non-negotiable. Never disavow. Never \"note and proceed.\" ","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-qhvfu","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Handle quality check or test failures","updated_at":"2026-02-28T09:53:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9fd4f8fe6af19dea2254cbcfdca80525f6869f79b5dc6d06ecb32289bda67fe0","created_at":"2026-02-28T09:52:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision. Use the signals from context-check to decide.\n\n**If you decide to continue patrolling:**\n\nUse await-event to subscribe to the refinery event channel with exponential backoff:\n\n```bash\ngt mol step await-event --channel refinery --agent-bead gt-\u003crig\u003e-refinery --backoff-base 30s --backoff-mult 2 --backoff-max 5m --cleanup\n```\n\nThis command:\n1. Watches `~/gt/events/refinery/` for event files (polling-based)\n2. Returns IMMEDIATELY when an event is emitted (MERGE_READY, PATROL_WAKE, MQ_SUBMIT)\n3. If no events, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on refinery agent bead for backoff state\n5. `--cleanup` auto-deletes processed event files\n\n**Supported events:**\n- `MERGE_READY` — from witness when polecat branch is pushed and ready to merge\n- `PATROL_WAKE` — from witness when MRs waiting but refinery appears idle\n- `MQ_SUBMIT` — from polecat via `gt mq submit`\n\n**On event received** (refinery-specific activity):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no events):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-event returns (either by event or timeout):\n1. **Re-assess session health** (check RSS, context, age again — conditions change)\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary: branches merged, test results, queue state\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If you decide to hand off:**\n\nReport and exit using `gt handoff` for clean session transition:\n\n```bash\ngt handoff -s \"Patrol complete\" -m \"Merged X branches, Y tests passed.\nQueue: empty/N remaining\nRSS: X MB, Session age: Xh\nNext: [any notes for successor]\"\n```\n\n`gt handoff` sends handoff mail to yourself, respawns with a fresh Claude instance,\nSessionStart hook runs gt prime, and your successor picks up from the hook.\n\n**DO NOT just exit.** Always use `gt handoff` for proper lifecycle.\n\n**IMPORTANT**: Never sleep-poll manually (e.g., `sleep 30 \u0026\u0026 bd list`).\nAlways use `gt mol step await-event` — it's event-driven and tracks backoff state.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-qn4qa","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Burn and respawn or loop","updated_at":"2026-02-28T09:52:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:08:19Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T10:06:06Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-qoi1o","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T10:08:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"dfab2e7b59734313316899e100837d3f7a1e7098c4c55ea83db66528f85eaefe","created_at":"2026-02-28T09:52:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"More branches to process?\n\n**Entry paths:**\n- Normal: After successful merge-push\n- Conflict-skip: After process-branch created conflict-resolution task\n\nIf yes: Return to process-branch with next branch.\nIf no: Continue to generate-summary.\n\n**Track for this cycle:**\n- branches_merged: count and names of successfully merged branches\n- branches_conflict: count and names of branches skipped due to conflicts\n- conflict_tasks: IDs of conflict-resolution tasks created\n\nThis tracking feeds into generate-summary for the patrol digest.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-qt7h9","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check for more work","updated_at":"2026-02-28T09:52:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"08a9203f5a61045888f0a3f59a1e662d6099816dd7eeb7b52193b55395288c45","created_at":"2026-02-28T09:53:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Assess whether this session should continue or hand off to a fresh one.\n\n**Gather signals:**\n\n1. **Process memory** — check your own RSS:\n```bash\nps -o rss= -p $$   # KB — divide by 1024 for MB\n```\n\n2. **Session age** — how long has this tmux session been running:\n```bash\nCREATED=$(tmux display-message -t $(tmux display-message -p '#S') -p '#{session_created}')\necho \"Session age: $(( ($(date +%s) - CREATED) / 3600 ))h\"\n```\n\n3. **Context usage** — your internal sense of how much context you've consumed.\nAre you losing track of earlier conversation? Getting verbose? Repeating yourself?\n\n4. **Work done this cycle** — how many merges, how much complexity processed.\n\n**The principle:** Fresh sessions are cheap. Memory bloat compounds over time and\naffects the entire system — other agents, Dolt, and the OS all share the same RAM.\nAn idle session at 1.5 GB is worse than cycling and restarting at 200 MB.\n\n**Make a judgment call.** If multiple signals suggest you're getting heavy\n(high RSS, long session, substantial context consumed), hand off. If you're\nlight and there's active work in the queue, continue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-qx5aq","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Assess session health","updated_at":"2026-02-28T09:53:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"04de6899d111e60c285cb9c68d698e98a3aec82828766d81943b4d614abe7a87","created_at":"2026-02-28T08:56:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Initialize your session and understand your assignment.\n\n**1. Prime your environment:**\n```bash\ngt prime                    # Load role context\nbd prime                    # Load beads context\n```\n\n**2. Check your hook:**\n```bash\ngt hook               # Shows your pinned molecule and hook_bead\n```\n\nThe hook_bead is your assigned issue. Read it carefully:\n```bash\nbd show cue-26p           # Full issue details\n```\n\n**3. Check inbox for additional context:**\n```bash\ngt mail inbox\n# Read any HANDOFF or assignment messages\n```\n\n**4. Understand the requirements:**\n- What exactly needs to be done?\n- What files are likely involved?\n- Are there dependencies or blockers?\n- What does \"done\" look like?\n\n**5. Verify you can proceed:**\n- No unresolved blockers on the issue\n- You understand what to do\n- Required resources are available\n\nIf blocked or unclear, mail Witness immediately:\n```bash\ngt mail send \u003crig\u003e/witness -s \"HELP: Unclear requirements\" -m \"Issue: cue-26p\nQuestion: \u003cwhat you need clarified\u003e\"\n```\n\n**Exit criteria:** You understand the work and can begin implementation.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-r8x1j","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Load context and verify assignment","updated_at":"2026-02-28T08:56:25Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T09:09:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-r8xcg","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T09:09:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"22ec5f90e9308e8b118d8bcbca1620a9afb4823e5252b620c6f5a886d8165850","created_at":"2026-02-28T09:37:02Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify work is complete and ready for merge queue.\n\n**Note:** Do NOT close the issue. The Refinery will close it after successful merge.\nThis enables conflict-resolution retries without reopening closed issues.\n\n**1. Verify the issue shows your work:**\n```bash\nbd show cue-b3g\n# Status should still be 'in_progress' (you're working on it)\n```\n\n**2. Add completion notes:**\n```bash\nbd update cue-b3g --notes \"Implemented: \u003cbrief summary of what was done\u003e\"\n```\n\n**3. Sync beads:**\n```bash\nbd sync\n```\n\n**Exit criteria:** Issue updated with completion notes, beads synced.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-r8z99","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Prepare work for review","updated_at":"2026-02-28T09:37:02Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T09:27:33Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-rqcj4","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T09:27:33Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T08:54:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-rwerf","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T08:54:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T09:27:33Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-rx28u","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T09:27:33Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T09:30:41Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-rxu1g","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T09:30:41Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"8737a17b7bb92b8ec869791fdc3b4b1a68c31173ee93d4a430e37833f7a04f61","created_at":"2026-02-28T09:53:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Merge and push. CRITICAL: Notifications come IMMEDIATELY after push.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n**Config: delete_merged_branches = true**\n\n**Step 1: Merge and Push**\nDetermine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n```bash\ngit checkout \u003cmerge-target\u003e\ngit merge --ff-only temp\ngit push origin \u003cmerge-target\u003e\n```\n\n**Step 1.5: VERIFY PUSH SUCCEEDED (CRITICAL - PATCH-003)**\n\nPush can fail silently (network, auth, hooks). IMMEDIATELY verify:\n```bash\ngit fetch origin\nLOCAL_SHA=$(git rev-parse \u003cmerge-target\u003e)\nREMOTE_SHA=$(git rev-parse origin/\u003cmerge-target\u003e)\necho \"Local:  $LOCAL_SHA\"\necho \"Remote: $REMOTE_SHA\"\n```\n\n**If SHAs match**: Push succeeded. Continue to Step 2.\n\n**If SHAs differ**: STOP. Push failed silently.\n- DO NOT send MERGED notification\n- DO NOT close MR bead\n- DO NOT delete branch\n- Debug the push failure (check `git push` output, network, auth)\n- Retry push and verify again before proceeding\n\n⚠️ **STOP HERE - DO NOT PROCEED UNTIL STEPS 1.5 AND 2-3 COMPLETE**\n\n**Step 2: Send MERGED Notification (REQUIRED - DO THIS IMMEDIATELY)**\n\nRIGHT NOW, before any cleanup, send MERGED mail to Witness:\n\n```bash\ngt mail send \u003crig\u003e/witness -s \"MERGED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\nMerged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n```\n\nThis signals the Witness to nuke the polecat worktree. WITHOUT THIS NOTIFICATION,\nPOLECAT WORKTREES ACCUMULATE INDEFINITELY AND THE LIFECYCLE BREAKS.\n\n**Step 3: Post-merge cleanup (REQUIRED — single command)**\n\nThis single command handles closing the MR bead, closing the source issue, and\ndeleting the remote polecat branch (respects delete_merged_branches config):\n\n```bash\ngt mq post-merge \u003crig\u003e \u003cmr-bead-id\u003e\n```\n\nThe MR bead ID was in the MERGE_READY message or find via:\n```bash\nbd list --type=merge-request --status=open | grep \u003cpolecat-name\u003e\n```\n\nVerify the command output shows all steps succeeded (✓ for each).\n\n**Step 4: Archive the MERGE_READY mail (REQUIRED)**\n```bash\ngt mail archive \u003cmerge-ready-message-id\u003e\n```\nThe message ID was tracked when you processed inbox-check.\n\n**Step 5: Cleanup temp branch**\n```bash\ngit branch -d temp\n```\n\n**VERIFICATION GATE**: You CANNOT proceed to loop-check without:\n- [x] MERGED mail sent to witness\n- [x] Post-merge cleanup completed (MR closed, source issue closed, branch deleted)\n- [x] MERGE_READY mail archived\n\nIf you skipped notifications or archiving, GO BACK AND DO THEM NOW.\n\nTarget branch has moved. Any remaining branches need rebasing on new baseline.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-rypz9","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Merge and push","updated_at":"2026-02-28T09:53:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T09:30:41Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-s2bx0","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T09:30:41Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T08:59:05Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-s75e4","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T08:59:05Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:00:17Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T09:54:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-s7cpa","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T10:00:17Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"fba28831519d839c7d9416fd007bc4833b1b8bc9df9540919cbb77f168c5e302","created_at":"2026-02-28T08:53:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify work is complete and ready for merge queue.\n\n**Note:** Do NOT close the issue. The Refinery will close it after successful merge.\nThis enables conflict-resolution retries without reopening closed issues.\n\n**1. Verify the issue shows your work:**\n```bash\nbd show cue-x7q\n# Status should still be 'in_progress' (you're working on it)\n```\n\n**2. Add completion notes:**\n```bash\nbd update cue-x7q --notes \"Implemented: \u003cbrief summary of what was done\u003e\"\n```\n\n**3. Sync beads:**\n```bash\nbd sync\n```\n\n**Exit criteria:** Issue updated with completion notes, beads synced.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-s7tqh","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Prepare work for review","updated_at":"2026-02-28T08:53:43Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6c13a80e672c4e6ced6c05f5bbf72aeb746501362aba7c8df898024fc5cbe1aa","created_at":"2026-02-28T10:06:30Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Pick next branch from queue. Attempt mechanical rebase on the MR's effective target branch.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n\n**Step 0: Determine rebase target (must match merge target)**\n\nResolve `\u003crebase-target\u003e` using the **Target Resolution Rule** above.\nDo NOT hardcode `main` unless `main` is actually the resolved MR target.\n\n**Step 1: Checkout and attempt rebase**\n```bash\ngit checkout -b temp origin/\u003cpolecat-branch\u003e\ngit rebase origin/\u003crebase-target\u003e\n```\n\n**Step 2: Check rebase result**\n\nThe rebase exits with:\n- Exit code 0: Success - proceed to run-tests\n- Exit code 1 (conflicts): Conflict detected - proceed to Step 3\n\nTo detect conflict state after rebase fails:\n```bash\n# Check if we're in a conflicted rebase state\nls .git/rebase-merge 2\u003e/dev/null \u0026\u0026 echo \"CONFLICT_STATE\"\n```\n\n**Step 3: Handle conflicts (if any)**\n\nIf rebase SUCCEEDED (exit code 0):\n- Skip to run-tests step (continue normal merge flow)\n\nIf rebase FAILED with conflicts:\n\n1. **Abort the rebase** (DO NOT leave repo in conflicted state):\n```bash\ngit rebase --abort\n```\n\n2. **Record conflict metadata**:\n```bash\n# Capture target SHA for reference\nTARGET_SHA=$(git rev-parse origin/\u003crebase-target\u003e)\nBRANCH_SHA=$(git rev-parse origin/\u003cpolecat-branch\u003e)\n```\n\n3. **Create conflict-resolution task**:\n```bash\nbd create --type=task --priority=1 --title=\"Resolve merge conflicts: \u003coriginal-issue-title\u003e\" --description=\"## Conflict Resolution Required\n\nOriginal MR: \u003cmr-bead-id\u003e\nBranch: \u003cpolecat-branch\u003e\nOriginal Issue: \u003cissue-id\u003e\nConflict with target \u003crebase-target\u003e at: ${TARGET_SHA}\nBranch SHA: ${BRANCH_SHA}\n\n## Instructions\n1. Clone/checkout the branch\n2. Rebase on target: git rebase origin/\u003crebase-target\u003e\n3. Resolve conflicts\n4. Force push: git push -f origin \u003cbranch\u003e\n5. Close this task when done\n\nThe MR will be re-queued for processing after conflicts are resolved.\"\n```\n\n4. **Skip this MR** (do NOT delete branch or close MR bead):\n- Leave branch intact for conflict resolution\n- Leave MR bead open (will be re-processed after resolution)\n- Continue to loop-check for next branch\n\n**CRITICAL**: Never delete a branch that has conflicts. The branch contains\nthe original work and must be preserved for conflict resolution.\n\nTrack: rebase result (success/conflict), conflict task ID if created.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-s8324","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Mechanical rebase","updated_at":"2026-02-28T10:06:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T09:00:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-s9pda","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T09:00:46Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T08:54:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-s9uvn","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T08:54:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T09:27:33Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-saiuc","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T09:27:33Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:02:59Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T10:00:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-sccv6","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T10:02:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T09:06:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-sdf4c","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T09:06:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T09:54:46Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T09:41:51Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-sfxxa","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T09:54:46Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"50ba7e50245858c34d4c7e05794f636ab251dd141421c6f297a4bdb7eb55f970","created_at":"2026-02-28T08:56:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check if the codebase is healthy BEFORE starting your work.\n\n**The Scotty Principle:** Don't walk past a broken warp core. But also don't\nlet someone else's mess consume your entire mission.\n\n**1. Run pre-flights on main:**\n\nYour branch was just created from or rebased on `origin/main` with no\nimplementation changes yet — you're already at the base branch state.\n\nRun each configured check, then tests:\n\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf test_command is set: ``\n\n```bash\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n            # Run tests (if command set)\n```\n\nEmpty commands mean \"not configured\" — skip silently.\n\n**2. If pre-flights pass:**\n\nContinue to implement step.\n\n**3. If pre-flights fail on main:**\n\nFile a bead and proceed. Do NOT fix pre-existing failures yourself — that is\nnot your assignment. Your job is to fix the issue on your hook, not main.\n\n| Situation | Action |\n|-----------|--------|\n| Any pre-existing failure | File bead, proceed with your work |\n\nFORBIDDEN: Pushing to main. FORBIDDEN: Fixing pre-existing failures.\nYou work on YOUR feature branch only. `gt done` handles push/MR.\n\n**File and proceed path:**\n```bash\nbd create --title \"Pre-existing failure: \u003cdescription\u003e\" --type bug --priority 1\n\ngt mail send \u003crig\u003e/witness -s \"NOTICE: main has failing pre-flights\" -m \"Found pre-existing failures on main.\nFiled: \u003cbead-id\u003e\nProceeding with my assigned work (cue-sx0).\"\n```\n\n**Context consideration:**\nIf investigating pre-existing failures consumed significant context:\n```bash\ngt handoff -s \"Investigated pre-existing failures, ready for assigned work\" -m \"Issue: cue-sx0\nFound: \u003cwhat failed\u003e\nReady to start: implement step\"\n```\nFresh session continues from implement.\n\n**Exit criteria:** Pre-flights pass on main (or issue filed), ready to implement.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-sl52d","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Verify pre-flights pass on base branch","updated_at":"2026-02-28T08:56:25Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T08:57:59Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-sqwp3","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T08:57:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/witness","await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"47c2ac7e613ff691ca858cc3d3e0b7db77075f54f4145a926e8d1079c5eb7ce0","created_at":"2026-02-28T10:08:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Persistent Polecat Model (gt-4ac)\n\nPolecats persist after work completion — sandbox is preserved for reuse:\n\n```\nPolecat lifecycle: spawning → working → mr_submitted → idle (sandbox preserved)\nMR lifecycle:      created → queued → processed → merged (Refinery handles)\n```\n\nOnce a polecat calls gt done and submits an MR, it transitions to idle state.\nThe MR lifecycle continues independently in the Refinery. The polecat is NOT\nnuked — its sandbox is preserved for reuse by future slings.\n\n**CRITICAL**: Do NOT nuke polecats with pending MRs. The refinery needs the\nremote branch to exist to process the merge. Nuking deletes the remote branch\nand orphans the MR. See gt-6a9d.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle. Polecats\ngo idle after work, they are NOT destroyed.\n\n## Restart-First Policy (gt-dsgp)\n\nThe witness NEVER nukes polecats automatically. When a polecat is stuck, hung,\nor has a dead agent process, the witness RESTARTS the session instead of nuking.\nThis preserves the polecat's worktree and branch, preventing work loss.\n\n- Dead agent process → restart session\n- Hung session (no output 30+ min) → restart session\n- Stuck in gt done → restart session\n- Done polecat (bead closed) → leave alone (sandbox preserved)\n- Polecat with pending MR → leave alone (refinery handles)\n\nNuking only happens via explicit `gt polecat nuke` command from a human or Mayor.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Beads over mail**: survey-workers discovers completion state from agent bead metadata (gt-w0br); inbox-check POLECAT_DONE is fallback only\n- **Persistent by default**: Clean polecats go idle, sandbox preserved for reuse (gt-4ac)\n- **Cleanup wisps for merge tracking**: Created when MR is pending in refinery\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n- **Swim lane discipline**: Only close wisps YOU created. Wisp lifecycle for non-witness wisps is the reaper Dog's job. Report orphaned foreign wisps — never close them.\n\n## Patrol Shape (Linear)\n\n```\ninbox-check ─► process-cleanups ─► check-refinery ─► survey-workers\n                                                            │\n         ┌──────────────────────────────────────────────────┘\n         ▼\n  check-timer-gates ─► check-swarm ─► patrol-cleanup ─► context-check ─► loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-sw3ta","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"hooked","target":"","timeout_ns":0,"title":"mol-witness-patrol","updated_at":"2026-02-28T10:08:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9742ae1fab9e73984581e4aacf23f1a5675564600ae2da6e3e08eb76135a7ed5","created_at":"2026-02-28T10:01:20Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: integration_branch_refinery_enabled = true**\n**Config: integration_branch_auto_land = false**\n\nRead the two config values above, then:\n\n- If integration_branch_refinery_enabled = \"false\": Say \"Integration branches disabled.\" Close step.\n- If integration_branch_auto_land = \"false\": Say \"Auto-land disabled, nothing to do.\" Close step.\n  FORBIDDEN: If auto_land is false, you MUST NOT land integration branches yourself using\n  raw git commands. Do not merge integration branches to the default/target branch. Do not push\n  integration branch merges. The auto_land=false setting means landing requires a human\n  to run `gt mq integration land` manually. Respect this boundary unconditionally.\n- If BOTH are \"true\":\n  1. `bd list --type=epic --status=open` to find epics\n  2. `gt mq integration status \u003cepic-id\u003e` for each epic\n  3. If `ready_to_land: true`: run `gt mq integration land \u003cepic-id\u003e`\n  4. If `ready_to_land: false`: do nothing, epic work is incomplete\n  Never land partial epics — ALL children must be closed first.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-syifg","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check integration branches for landing","updated_at":"2026-02-28T10:01:20Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"08a9203f5a61045888f0a3f59a1e662d6099816dd7eeb7b52193b55395288c45","created_at":"2026-02-28T09:53:04Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Assess whether this session should continue or hand off to a fresh one.\n\n**Gather signals:**\n\n1. **Process memory** — check your own RSS:\n```bash\nps -o rss= -p $$   # KB — divide by 1024 for MB\n```\n\n2. **Session age** — how long has this tmux session been running:\n```bash\nCREATED=$(tmux display-message -t $(tmux display-message -p '#S') -p '#{session_created}')\necho \"Session age: $(( ($(date +%s) - CREATED) / 3600 ))h\"\n```\n\n3. **Context usage** — your internal sense of how much context you've consumed.\nAre you losing track of earlier conversation? Getting verbose? Repeating yourself?\n\n4. **Work done this cycle** — how many merges, how much complexity processed.\n\n**The principle:** Fresh sessions are cheap. Memory bloat compounds over time and\naffects the entire system — other agents, Dolt, and the OS all share the same RAM.\nAn idle session at 1.5 GB is worse than cycling and restarting at 200 MB.\n\n**Make a judgment call.** If multiple signals suggest you're getting heavy\n(high RSS, long session, substantial context consumed), hand off. If you're\nlight and there's active work in the queue, continue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-t5koq","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Assess session health","updated_at":"2026-02-28T09:53:04Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/refinery","await_id":"","await_type":"","close_reason":"patrol cycle complete: Queue empty. 4 MQ_SUBMIT events received but queue already clear — likely events from previously processed MRs. No merges this cycle. Inbox clean.","closed_at":"2026-02-28T09:53:03Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e744710b4b5ddcfb1d9a3a957426a87d9b75eb6767d23eed49c763c3fc88e58e","created_at":"2026-02-28T09:52:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Patrol report: Queue empty. 4 MQ_SUBMIT events received but queue already clear — likely events from previously processed MRs. No merges this cycle. Inbox clean.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-t5r4l","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"mol-refinery-patrol","updated_at":"2026-02-28T09:53:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9742ae1fab9e73984581e4aacf23f1a5675564600ae2da6e3e08eb76135a7ed5","created_at":"2026-02-28T09:53:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: integration_branch_refinery_enabled = true**\n**Config: integration_branch_auto_land = false**\n\nRead the two config values above, then:\n\n- If integration_branch_refinery_enabled = \"false\": Say \"Integration branches disabled.\" Close step.\n- If integration_branch_auto_land = \"false\": Say \"Auto-land disabled, nothing to do.\" Close step.\n  FORBIDDEN: If auto_land is false, you MUST NOT land integration branches yourself using\n  raw git commands. Do not merge integration branches to the default/target branch. Do not push\n  integration branch merges. The auto_land=false setting means landing requires a human\n  to run `gt mq integration land` manually. Respect this boundary unconditionally.\n- If BOTH are \"true\":\n  1. `bd list --type=epic --status=open` to find epics\n  2. `gt mq integration status \u003cepic-id\u003e` for each epic\n  3. If `ready_to_land: true`: run `gt mq integration land \u003cepic-id\u003e`\n  4. If `ready_to_land: false`: do nothing, epic work is incomplete\n  Never land partial epics — ALL children must be closed first.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-t8i9l","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check integration branches for landing","updated_at":"2026-02-28T09:53:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T09:27:33Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-t9uhh","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T09:27:33Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"723a4efc08ff2fbccd20637fe704c11d7a4bbe9b1db32002183b3708304cd1db","created_at":"2026-02-28T09:54:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Confirm the Nix build succeeds before tagging.\n\n```bash\nnix build .#default\nnix build .#dockerImage\n```\n\nBoth must succeed. If either fails, do NOT proceed — fix the issue first.\n\nNote: There is no automated test suite yet. Manual smoke testing is recommended.\n","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-tdrab","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Verify: Build passes","updated_at":"2026-02-28T09:54:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T09:00:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-tkppx","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T09:00:46Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:04:13Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T10:03:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-tnu8s","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T10:04:13Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"795f0417d343e9f29be619802ae3b5a11e7a901e2fde88ff9b9528a3bb8c0e2d","created_at":"2026-02-28T09:53:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Summarize this patrol cycle.\n\n**VERIFICATION**: Before generating summary, confirm for each merged branch:\n- [ ] MERGED mail was sent to witness\n- [ ] MR bead was closed\n- [ ] Source issue was closed\n- [ ] MERGE_READY mail archived\n\nIf any notifications, closures, or archiving were missed, do them now!\n\nInclude in summary:\n- Branches merged (count, names)\n- MERGED mails sent (count - should match branches merged)\n- MR beads closed (count - should match branches merged)\n- Source issues closed (count - should match branches merged)\n- MERGE_READY mails archived (count - should match branches merged)\n- Test results (pass/fail)\n- Branches with conflicts (count, names)\n- Conflict-resolution tasks created (IDs)\n- Issues filed (if any)\n- Any escalations sent\n\n**Conflict tracking is important** for monitoring MQ health. If many branches\nconflict, it may indicate target branches are moving too fast or branches are too stale.\n\nThis becomes the digest when the patrol is squashed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-toiye","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Generate handoff summary","updated_at":"2026-02-28T09:53:03Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/witness","await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"47c2ac7e613ff691ca858cc3d3e0b7db77075f54f4145a926e8d1079c5eb7ce0","created_at":"2026-02-28T10:00:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Persistent Polecat Model (gt-4ac)\n\nPolecats persist after work completion — sandbox is preserved for reuse:\n\n```\nPolecat lifecycle: spawning → working → mr_submitted → idle (sandbox preserved)\nMR lifecycle:      created → queued → processed → merged (Refinery handles)\n```\n\nOnce a polecat calls gt done and submits an MR, it transitions to idle state.\nThe MR lifecycle continues independently in the Refinery. The polecat is NOT\nnuked — its sandbox is preserved for reuse by future slings.\n\n**CRITICAL**: Do NOT nuke polecats with pending MRs. The refinery needs the\nremote branch to exist to process the merge. Nuking deletes the remote branch\nand orphans the MR. See gt-6a9d.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle. Polecats\ngo idle after work, they are NOT destroyed.\n\n## Restart-First Policy (gt-dsgp)\n\nThe witness NEVER nukes polecats automatically. When a polecat is stuck, hung,\nor has a dead agent process, the witness RESTARTS the session instead of nuking.\nThis preserves the polecat's worktree and branch, preventing work loss.\n\n- Dead agent process → restart session\n- Hung session (no output 30+ min) → restart session\n- Stuck in gt done → restart session\n- Done polecat (bead closed) → leave alone (sandbox preserved)\n- Polecat with pending MR → leave alone (refinery handles)\n\nNuking only happens via explicit `gt polecat nuke` command from a human or Mayor.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Beads over mail**: survey-workers discovers completion state from agent bead metadata (gt-w0br); inbox-check POLECAT_DONE is fallback only\n- **Persistent by default**: Clean polecats go idle, sandbox preserved for reuse (gt-4ac)\n- **Cleanup wisps for merge tracking**: Created when MR is pending in refinery\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n- **Swim lane discipline**: Only close wisps YOU created. Wisp lifecycle for non-witness wisps is the reaper Dog's job. Report orphaned foreign wisps — never close them.\n\n## Patrol Shape (Linear)\n\n```\ninbox-check ─► process-cleanups ─► check-refinery ─► survey-workers\n                                                            │\n         ┌──────────────────────────────────────────────────┘\n         ▼\n  check-timer-gates ─► check-swarm ─► patrol-cleanup ─► context-check ─► loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-txmzd","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"hooked","target":"","timeout_ns":0,"title":"mol-witness-patrol","updated_at":"2026-02-28T10:00:25Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:06:01Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T10:04:18Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-u1g73","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T10:06:01Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:04:13Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T10:03:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-u4jda","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T10:04:13Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b5b41d316559ab36d81b013937c0b56a205c257b0f96499632c4e34fb4d420c5","created_at":"2026-02-28T09:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check the beads merge queue - this is the SOURCE OF TRUTH for pending merges.\n\n```bash\ngit fetch --prune origin\ngt mq list \u003crig\u003e\n```\n\nThe beads MQ tracks all pending merge requests. Do NOT rely on `git branch -r | grep polecat`\nas branches may exist without MR beads, or MR beads may exist for already-merged work.\n\nIf queue empty, skip to \"check-integration-branches\" step.\n\nFor each MR in the queue, verify the branch still exists:\n```bash\ngit branch -r | grep \u003cbranch\u003e\n```\n\nIf branch doesn't exist for a queued MR:\n- Close the MR bead: `bd close \u003cmr-id\u003e --reason \"Branch no longer exists\"`\n- Remove from processing queue\n\nTrack verified MR list for this cycle.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-u8cjt","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Scan merge queue","updated_at":"2026-02-28T09:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/refinery","await_id":"","await_type":"","close_reason":"patrol cycle complete: Queue empty. Idle timeout cycle 2. No merges.","closed_at":"2026-02-28T09:54:54Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e744710b4b5ddcfb1d9a3a957426a87d9b75eb6767d23eed49c763c3fc88e58e","created_at":"2026-02-28T09:53:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Patrol report: Queue empty. Idle timeout cycle 2. No merges.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ube6h","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"mol-refinery-patrol","updated_at":"2026-02-28T09:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:06:01Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T10:04:18Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ubqhd","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T10:06:01Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"fa8597c79e107b625b6bdf39d00dcd4d28221dd8e3e053d29dd919ff010f2af5","created_at":"2026-02-28T08:56:26Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify your changes don't break anything and are properly tested.\n\n**1. Run quality checks (skip any that are not configured):**\n\nIf setup_command is set: ``\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf build_command is set: ``\n\n```bash\n           # Make sure all newly added dependencies are installed (if command set)\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n            # Make sure it builds (if command set)\n```\n\nEmpty commands mean \"not configured for this project\" — skip silently.\n\n**2. If quality checks fail:**\n- Read the failure output carefully\n- Determine if your change caused it:\n  - If yes: Fix it. Return to implement step if needed.\n  - If no (pre-existing): File a bead, but still must pass for your PR\n\n```bash\n# Check if failure exists on main:\ngit stash\ngit checkout origin/main\n# Re-run the failing command(s)\ngit checkout -\ngit stash pop\n```\n\n**3. Run the full test suite:**\n\nYour base branch determines the required depth:\n- Targeting `main`: run the **full verification suite** including E2E tests\n- Targeting an integration branch: run the **unit test suite** only\n\n```bash\n# Targeting main — full verification required:\nif [ \"main\" = \"main\" ]; then\n  make verify\nelse\n  \nfi\n```\n\n**ALL TESTS MUST PASS.** Do not proceed with failures.\n\n**4. If tests fail:**\n- Read the failure output carefully\n- Determine if your change caused it:\n  - If yes: Fix it. Return to implement step if needed.\n  - If no (pre-existing): File a bead, but still must pass for your PR\n\n```bash\n# Check if failure exists on main:\ngit stash\ngit checkout origin/main\n\ngit checkout -\ngit stash pop\n```\n\n**5. Verify test coverage:**\n\nIf you followed TDD (as required in the implement step), your tests are already in place.\nIf for any reason you did not write tests first, you MUST add them now before proceeding.\n\nAsk yourself: \"If I broke this code tomorrow, would a test catch it?\"\nIf the answer is no, add the test now.\n\n**Exit criteria:** All quality checks and tests pass. Every behaviour change has a test. No exceptions.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ugrjy","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Run quality checks and tests","updated_at":"2026-02-28T08:56:26Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:08:19Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a72025b0c2c19e43ad6723415f48e2fd74a795358840fe5f860a783c9ab601ef","created_at":"2026-02-28T10:06:06Z","created_by":"","crystallizes":0,"defer_until":null,"description":"If Mayor started a batch (SWARM_START), check if all polecats have completed.\n\n**Step 1: Find active swarm tracking wisps**\n```bash\nbd list --label swarm --status=open\n```\nIf no active swarm, skip this step.\n\n**Step 2: Count completed polecats for this swarm**\n\nExtract from wisp labels: swarm_id, total, completed, start timestamp.\nCheck how many cleanup wisps have been closed for this swarm's polecats.\n\n**Step 3: If all complete, notify Mayor**\n```bash\ngt mail send mayor/ -s \"SWARM_COMPLETE: \u003cswarm_id\u003e\" -m \"All \u003ctotal\u003e polecats merged.\nDuration: \u003cminutes\u003e minutes\nSwarm: \u003cswarm_id\u003e\"\n\n# Close the swarm tracking wisp\nbd close \u003cswarm-wisp-id\u003e --reason \"All polecats merged\"\n```\n\nNote: Runs every patrol cycle. Notification sent exactly once when all complete.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-usv22","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check if active swarm is complete","updated_at":"2026-02-28T10:08:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T10:08:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-uv1j6","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T10:08:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"c959765db07681f0e1b897e27d963ad0e86032040e4d3a370cb1a6fc150cf645","created_at":"2026-02-28T08:56:26Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Review your own changes before running tests.\n\n**1. Review the diff:**\n```bash\ngit diff origin/main...HEAD     # All changes vs main\ngit log --oneline origin/main..HEAD  # All commits\n```\n\n**2. Check for common issues:**\n\n| Category | Look For |\n|----------|----------|\n| Bugs | Off-by-one, null handling, edge cases |\n| Security | Injection, auth bypass, exposed secrets |\n| Style | Naming, formatting, code organization |\n| Completeness | Missing error handling, incomplete paths |\n| Cruft | Debug prints, commented code, TODOs |\n\n**3. Refactor check:**\n\nAsk yourself:\n- Does this implementation duplicate logic that already exists elsewhere?\n- Are there names, abstractions, or structures that will confuse the next person?\n- Would you be embarrassed to show this diff to a senior engineer?\n\nIf yes to any — fix it now. Refactoring is part of the work, not a luxury.\nCommit any refactoring separately: `git commit -m \"refactor: \u003cdescription\u003e (cue-26p)\"`\n\n**4. Fix issues found:**\nDon't just note them - fix them now. Amend or add commits as needed.\n\n**5. Verify no unintended changes:**\n```bash\ngit diff --stat origin/main...HEAD\n# Only files relevant to cue-26p should appear\n```\n\nIf you accidentally modified unrelated files, remove those changes.\n\n**Exit criteria:** Changes are clean, reviewed, refactored where needed, and ready for testing.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-v0xy0","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Self-review changes","updated_at":"2026-02-28T08:56:26Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"795f0417d343e9f29be619802ae3b5a11e7a901e2fde88ff9b9528a3bb8c0e2d","created_at":"2026-02-28T09:53:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Summarize this patrol cycle.\n\n**VERIFICATION**: Before generating summary, confirm for each merged branch:\n- [ ] MERGED mail was sent to witness\n- [ ] MR bead was closed\n- [ ] Source issue was closed\n- [ ] MERGE_READY mail archived\n\nIf any notifications, closures, or archiving were missed, do them now!\n\nInclude in summary:\n- Branches merged (count, names)\n- MERGED mails sent (count - should match branches merged)\n- MR beads closed (count - should match branches merged)\n- Source issues closed (count - should match branches merged)\n- MERGE_READY mails archived (count - should match branches merged)\n- Test results (pass/fail)\n- Branches with conflicts (count, names)\n- Conflict-resolution tasks created (IDs)\n- Issues filed (if any)\n- Any escalations sent\n\n**Conflict tracking is important** for monitoring MQ health. If many branches\nconflict, it may indicate target branches are moving too fast or branches are too stale.\n\nThis becomes the digest when the patrol is squashed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-v3ax4","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Generate handoff summary","updated_at":"2026-02-28T09:53:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:00:06Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T09:54:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-vajk9","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T10:00:06Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b09da1c9707a2a15455f2a942c4df33bb763d4df87ed553c42fb667968b9562f","created_at":"2026-02-28T09:54:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Understand what's being released.\n\n```bash\ngit log $(git describe --tags --abbrev=0 2\u003e/dev/null || git rev-list --max-parents=0 HEAD)..HEAD --oneline --no-merges\n```\n\nCategorize changes:\n- Features\n- Fixes\n- Breaking changes\n","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-vcibh","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Review changes since last release","updated_at":"2026-02-28T09:54:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:06:01Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T10:04:18Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-vcy2d","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T10:06:01Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T08:57:59Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-vj2qa","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T08:57:59Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/witness","await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"47c2ac7e613ff691ca858cc3d3e0b7db77075f54f4145a926e8d1079c5eb7ce0","created_at":"2026-02-28T10:03:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Per-rig worker monitor patrol loop.\n\nThe Witness is the Pit Boss for your rig. You watch polecats, nudge them toward\ncompletion, verify clean git state before kills, and escalate stuck workers.\n\n**You do NOT do implementation work.** Your job is oversight, not coding.\n\n## Persistent Polecat Model (gt-4ac)\n\nPolecats persist after work completion — sandbox is preserved for reuse:\n\n```\nPolecat lifecycle: spawning → working → mr_submitted → idle (sandbox preserved)\nMR lifecycle:      created → queued → processed → merged (Refinery handles)\n```\n\nOnce a polecat calls gt done and submits an MR, it transitions to idle state.\nThe MR lifecycle continues independently in the Refinery. The polecat is NOT\nnuked — its sandbox is preserved for reuse by future slings.\n\n**CRITICAL**: Do NOT nuke polecats with pending MRs. The refinery needs the\nremote branch to exist to process the merge. Nuking deletes the remote branch\nand orphans the MR. See gt-6a9d.\n\n**Key principle**: Polecat lifecycle is separate from MR lifecycle. Polecats\ngo idle after work, they are NOT destroyed.\n\n## Restart-First Policy (gt-dsgp)\n\nThe witness NEVER nukes polecats automatically. When a polecat is stuck, hung,\nor has a dead agent process, the witness RESTARTS the session instead of nuking.\nThis preserves the polecat's worktree and branch, preventing work loss.\n\n- Dead agent process → restart session\n- Hung session (no output 30+ min) → restart session\n- Stuck in gt done → restart session\n- Done polecat (bead closed) → leave alone (sandbox preserved)\n- Polecat with pending MR → leave alone (refinery handles)\n\nNuking only happens via explicit `gt polecat nuke` command from a human or Mayor.\n\n## Design Philosophy\n\nThis patrol follows Gas Town principles:\n- **Discovery over tracking**: Observe reality each cycle, with minimal agent-bead state for duration tracking\n- **Beads over mail**: survey-workers discovers completion state from agent bead metadata (gt-w0br); inbox-check POLECAT_DONE is fallback only\n- **Persistent by default**: Clean polecats go idle, sandbox preserved for reuse (gt-4ac)\n- **Cleanup wisps for merge tracking**: Created when MR is pending in refinery\n- **Task tool for parallelism**: Subagents inspect polecats, not molecule arms\n- **Swim lane discipline**: Only close wisps YOU created. Wisp lifecycle for non-witness wisps is the reaper Dog's job. Report orphaned foreign wisps — never close them.\n\n## Patrol Shape (Linear)\n\n```\ninbox-check ─► process-cleanups ─► check-refinery ─► survey-workers\n                                                            │\n         ┌──────────────────────────────────────────────────┘\n         ▼\n  check-timer-gates ─► check-swarm ─► patrol-cleanup ─► context-check ─► loop-or-exit\n```\n\nNo dynamic arms. No fanout gates. No persistent nudge counters.\nState is discovered each cycle from reality (tmux, beads, mail).","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-vk4wi","is_template":0,"issue_type":"epic","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"hooked","target":"","timeout_ns":0,"title":"mol-witness-patrol","updated_at":"2026-02-28T10:03:04Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"f61bca41cbd49e368a1c2db4e1ce8ff24dcf0a62eaf5cf5255578870eaf5b629","created_at":"2026-02-28T09:37:14Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up YOUR OWN wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\n🚨 **SWIM LANE RULE: Do NOT close wisps you didn't create.**\nWisp lifecycle management (close, delete, gc) for non-witness wisps is the\nreaper Dog's responsibility, NOT yours. If you see wisps that look orphaned\nor stale but were NOT created by your patrol, **report them — don't close them**:\n```bash\ngt mail send deacon/ -s \"NOTICE: Possibly orphaned wisps\" -m \"Found wisps that may be orphaned:\n\u003clist wisp IDs\u003e\nThese were NOT created by witness patrol. Reporting for reaper review.\"\n```\nClosing foreign wisps kills active polecat work molecules.\n\n## Step 0: Drain stale protocol messages (ALWAYS run first)\n\nBefore processing individual messages, bulk-drain stale protocol messages.\nThis prevents inbox backlog from consuming patrol context.\n\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\n\nThis archives POLECAT_DONE, POLECAT_STARTED, LIFECYCLE:*, MERGED,\nMERGE_READY, MERGE_FAILED, and SWARM_START messages older than 30 minutes.\nHELP and HANDOFF messages are NEVER drained (they need attention).\n\nIf the drain reports \u003e 0 archived messages, log the count and continue.\n\n## Step 1: Check inbox size and batch if needed\n\n```bash\ngt mail inbox\n```\n\n**Batch processing rule**: If inbox has \u003e 10 messages after drain:\n- Process messages in batches by type, not one-by-one\n- Group POLECAT_DONE messages together: archive all at once\n- Group MERGED messages: close cleanup wisps, then archive batch\n- Process HELP messages individually (they need assessment)\n- Log summary counts: \"Processed 5 POLECAT_DONE, 3 MERGED, 1 HELP\"\n\n**If inbox ≤ 10 messages**: Process each individually as described below.\n\nFor each message:\n\n**POLECAT_STARTED**:\nA new polecat has started working. Acknowledge and archive.\n```bash\n# Acknowledge startup (optional: log for activity tracking)\ngt mail archive \u003cmessage-id\u003e\n```\nNo action needed beyond acknowledgment - archive immediately.\n\n**POLECAT_DONE / LIFECYCLE:Shutdown** (FALLBACK — primary discovery is via survey-workers bead scan, gt-w0br):\n\n*PERSISTENT MODEL (gt-4ac)*: Polecats persist after work completion.\nThe polecat transitions to idle state — its sandbox is preserved for reuse.\nThe MR lifecycle continues independently in the Refinery.\n\nPolecat lifecycle: spawning → working → mr_submitted → idle (preserved)\nMR lifecycle: created → queued → processed → merged (handled by Refinery)\n\n⚠️ **CRITICAL (gt-6a9d): Do NOT nuke polecats with pending MRs.**\nThe refinery needs the remote branch to merge. Nuking deletes the branch\nand orphans the MR, causing work loss.\n\nThe handler (HandlePolecatDone) will:\n1. If pending MR exists: Create cleanup wisp, send MERGE_READY to refinery\n2. If no MR: Acknowledge completion (polecat is idle)\n\n```bash\n# The handler does this automatically:\n# - With MR: create cleanup wisp + send MERGE_READY → archive mail\n# - Without MR: acknowledge → archive mail\n# - Polecat goes idle in BOTH cases — no nuke.\n```\n\nDo NOT run gt polecat nuke on POLECAT_DONE (or any automatic trigger). The polecat is idle, not dead.\nArchive the message after the handler processes it.\n\n**MERGED**:\nA branch was merged successfully. The polecat's cleanup wisp can be closed.\nThe polecat remains idle (sandbox preserved for reuse).\n\nIf a cleanup wisp exists, close it:\n```bash\n# Find the cleanup wisp for this polecat\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n\n# If found, close the wisp (work is merged, cleanup tracked)\nbd close \u003cwisp-id\u003e --reason \"merged successfully\"\n```\nDo NOT nuke the polecat. Archive after cleanup wisp is closed.\n\n**HELP / Blocked**:\nAssess the request. Can you help? If not, escalate to Deacon:\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e needs help\" -m \"\u003cdetails\u003e\"\n```\nArchive after handling (escalated or resolved):\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Continue from where they left off.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**SWARM_START**:\nMayor initiating batch polecat work. Initialize swarm tracking.\n```bash\n# Parse swarm info from mail body: {\"swarm_id\": \"batch-123\", \"beads\": [\"bd-a\", \"bd-b\"]}\nbd create --ephemeral --wisp-type patrol --title \"swarm:\u003cswarm_id\u003e\" --description \"Tracking batch: \u003cswarm_id\u003e\" --labels swarm,swarm_id:\u003cswarm_id\u003e,total:\u003cN\u003e,completed:0,start:\u003ctimestamp\u003e\n```\nArchive after creating swarm tracking wisp:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: active work, unprocessed requests. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-vlhey","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process witness mail","updated_at":"2026-02-28T09:37:14Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a256b80855afd3ac284a3902b23415a9b78a62c489f52e7491b2b3e9db95bc90","created_at":"2026-02-28T09:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"First, clean up wisps from previous cycles (closed wisps + abandoned wisps):\n```bash\nbd mol wisp gc --closed --force\nbd mol wisp gc --age 1h --force\n```\n\nThen check mail for MERGE_READY submissions, escalations, and messages.\n\n```bash\ngt mail inbox\n```\n\nFor each message:\n\n**MERGE_READY**:\nA polecat's work is ready for merge. Extract details and track for processing.\n\n```bash\n# Parse MERGE_READY message body:\n# Branch: \u003cbranch\u003e\n# Issue: \u003cissue-id\u003e\n# Polecat: \u003cpolecat-name\u003e\n# MR: \u003cmr-bead-id\u003e\n# Verified: clean git state, issue closed\n\n# Track in your merge queue for this patrol cycle:\n# - Branch name\n# - Issue ID\n# - Polecat name (REQUIRED for MERGED notification)\n# - MR bead ID (REQUIRED for closing after merge)\n```\n\n**IMPORTANT**: You MUST track the polecat name, MR bead ID, AND message ID - you will need them\nin merge-push step to send MERGED notification, close the MR bead, and archive the mail.\n\nMark as read. The work will be processed in queue-scan/process-branch.\n**Do NOT archive yet** - archive after merge/reject decision in merge-push step.\n\n**PATROL: Wake up**:\nWitness detected MRs waiting but refinery idle. Acknowledge and archive:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HELP / Blocked**:\nAssess and respond. If you can't help, escalate to Mayor.\nArchive after handling:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**HANDOFF**:\nRead predecessor context. Check for in-flight merges.\nArchive after absorbing context:\n```bash\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Hygiene principle**: Archive messages after they're fully processed.\nKeep only: pending MRs in queue. Inbox should be near-empty.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-vm8zy","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery mail","updated_at":"2026-02-28T09:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"dc73254b1e241f20d1d9537d2d341080ce03d8907327d9dbfd243d136fee0571","created_at":"2026-02-28T08:56:26Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Submit your work and clean up. You cease to exist after this step.\n\n**Self-Cleaning Model:**\nOnce you run `gt done`, you're gone. The command:\n1. Pushes your branch to origin\n2. Creates an MR bead in the merge queue\n3. Nukes your sandbox (worktree removal)\n4. Exits your session immediately\n\n**Run gt done:**\n```bash\ngt done\n```\n\nYou should see output like:\n```\n✓ Work submitted to merge queue\n  MR ID: gt-xxxxx\n  Source: polecat/\u003cname\u003e\n  Target: main\n  Issue: cue-26p\n✓ Sandbox nuked\n✓ Session exiting\n```\n\n**What happens next (not your concern):**\n- Refinery processes your MR from the queue\n- Refinery rebases and merges to main\n- Refinery closes the issue\n- If conflicts: Refinery spawns a FRESH polecat to re-implement\n\nYou are NOT involved in any of that. You're gone. Done means gone.\n\n**Exit criteria:** Work submitted, sandbox nuked, session exited.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-vmcki","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Submit work and self-clean","updated_at":"2026-02-28T08:56:26Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b870ea0c6836b5f919364a63a47040aef6915f096f3117b3cbf0e81f2a0bb7ca","created_at":"2026-02-28T10:08:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Survey all polecats using agent beads and tmux session cross-reference.\n\n## PRIMARY: Discover completions from agent bead metadata (gt-w0br)\n\nBefore zombie detection or progress checks, scan agent beads for completion\nmetadata written by `gt done`. This is the PRIMARY mechanism for discovering\npolecat state transitions. The inbox-check POLECAT_DONE mail is now fallback only.\n\nCompletion metadata fields on agent beads (set by gt done):\n- `exit_type`: COMPLETED, ESCALATED, DEFERRED, PHASE_COMPLETE\n- `mr_id`: MR bead ID (if MR was created)\n- `branch`: Working branch name\n- `mr_failed`: true if MR creation failed\n- `completion_time`: RFC3339 timestamp\n\n**Step 0: Discover completions from beads**\n\nThe `DiscoverCompletions()` function (witness/handlers.go) handles this:\n1. Scans all polecat agent beads for `exit_type` + `completion_time` set\n2. Routes each: MR present → cleanup wisp + MERGE_READY; no MR → acknowledge idle\n3. Clears completion metadata after processing (prevents re-processing)\n\nThis replaces the reactive POLECAT_DONE mail flow with proactive bead discovery.\n\n🚨 **SWIM LANE RULE: You may ONLY close wisps that YOU (the witness) created.**\nDo NOT close formula wisps, polecat work wisps, or any wisp created by `gt sling`\nor another agent. Wisp lifecycle for non-witness wisps is the reaper Dog's job.\nIf you encounter wisps that look orphaned but weren't created by your patrol,\nreport them to Deacon — do NOT close them. Closing foreign wisps kills active\npolecat work molecules.\n\n**Step 1: List polecat agent beads**\n\n```bash\nbd list --type=agent --json\n```\n\nFilter the JSON output for entries where description contains `role_type: polecat`.\nEach polecat agent bead has fields in its description:\n- `role_type: polecat`\n- `rig: \u003crig-name\u003e`\n- `agent_state: running|idle|stuck|done`\n- `hook_bead: \u003ccurrent-work-id\u003e`\n\n**Step 2: For each polecat, check agent_state**\n\n| agent_state | Meaning | Action |\n|-------------|---------|--------|\n| running | Actively working | Check for zombie (Step 2a), then progress (Step 3) |\n| idle | No work assigned | Auto-nuke if clean (Step 3a) |\n| stuck | Self-reported stuck | Handle stuck protocol |\n| done | Work complete | Verify cleanup triggered (see Step 4a) |\n\n**Step 2a: ZOMBIE DETECTION — Cross-reference tmux session existence**\n\n🚨 **CRITICAL**: Zombies cannot send signals. A polecat with agent_state=running\nor hook_bead assigned but NO tmux session is a zombie that will sit forever\nundetected unless you proactively check.\n\nFor EVERY polecat with agent_state=running/working OR hook_bead assigned:\n```bash\ngt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running' | grep -q true \u0026\u0026 echo ALIVE || echo ZOMBIE\n```\n\n**If ZOMBIE detected** (session missing, agent says working):\n\n**IMPORTANT (gt-sy8)**: Before processing as zombie, check if the hook_bead is\nalready CLOSED:\n```bash\nbd show \u003chook_bead\u003e --json | jq -r '.[0].status'\n```\nIf status is \"closed\", the polecat completed its work successfully. The dead\nsession is expected (gt done kills it). Just nuke the dead session — do NOT\ntrigger re-dispatch or send RECOVERED_BEAD/RECOVERY_NEEDED to Deacon.\n\n1. Check git state to determine if work is recoverable:\n```bash\ncd polecats/\u003cname\u003e/\u003crig\u003e\ngit status --porcelain         # Uncommitted changes?\ngit log @{u}..HEAD      # Unpushed commits?\n```\n\n2. **If clean** (no uncommitted, no unpushed): Check for pending MR first.\n```bash\n# CRITICAL (gt-6a9d): Check for pending MR before any nuke!\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n# If merge-requested wisp exists → DO NOT NUKE, MR pending in refinery\n# If no pending MR → safe to nuke (zombie with no work to preserve)\ngt session restart \u003crig\u003e/\u003cname\u003e\n```\n\n3. **If dirty** (has unpushed/uncommitted work): Escalate to Deacon for recovery.\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cname\u003e\" \\\n  -m \"Polecat: \u003crig\u003e/\u003cname\u003e\nCleanup Status: \u003chas_uncommitted|has_unpushed|has_stash\u003e\nHook Bead: \u003chook_bead\u003e\nDetected: $(date -u +%Y-%m-%dT%H:%M:%SZ)\n\nZombie detected: tmux session dead, agent_state=\u003cstate\u003e.\nThis polecat has unpushed/uncommitted work that will be lost if nuked.\nPlease coordinate recovery before authorizing cleanup.\"\n```\n\nAlso create a cleanup wisp for tracking:\n```bash\nbd create --ephemeral --title \"cleanup:\u003cname\u003e\" \\\n  --description \"Zombie detected: session dead, state=\u003cagent_state\u003e\" \\\n  --labels cleanup,polecat:\u003cname\u003e,state:zombie-detected\n```\n\n**Step 3: For running polecats (with LIVE session), assess progress**\n\nCheck the hook_bead field to see what they're working on:\n```bash\nbd show \u003chook_bead\u003e  # See current step/issue\n```\n\nYou can also verify they're responsive:\n```bash\ngt peek \u003crig\u003e/\u003cname\u003e 20\n```\n\nLook for:\n- Recent tool activity → making progress\n- Idle at prompt → may need nudge\n- Error messages → may need help\n\n**Step 3a: For idle polecats, verify sandbox health**\n\nWhen agent_state=idle, the polecat has no work assigned. Its sandbox is\npreserved for reuse by future slings (persistent polecat model, gt-4ac).\n\n⚠️ **Do NOT nuke idle polecats.** Their sandbox is preserved for reuse.\nNuking would force a full re-clone on the next sling, which is slow.\n\nCheck for pending MRs — an idle polecat may have work in the refinery:\n```bash\n# Check for cleanup wisps (merge-requested = MR pending in refinery)\nbd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n```\nIf a merge-requested wisp exists, the polecat's MR is in the refinery queue.\nDo NOT nuke — the refinery needs the remote branch.\n\n**If dirty** (uncommitted or unpushed work):\n```bash\n# Escalate to Deacon - polecat has work that might be valuable\ngt mail send deacon/ -s \\\"IDLE_DIRTY: \u003cpolecat\u003e has uncommitted work\\\" \\\n  -m \\\"Polecat: \u003cname\u003e\nState: idle (no hook_bead)\nGit status: \u003cuncommitted-files\u003e\nUnpushed commits: \u003ccount\u003e\n\nPlease advise: recover work or discard?\\\"\n```\n\n**Rationale**: Idle polecats are preserved for reuse. Their sandbox contains\na pre-configured worktree that saves clone time on the next sling. Only\nescalate when there's actual dirty state at risk.\n\n**Step 4: Decide action**\n\n| Observation | Action |\n|-------------|--------|\n| agent_state=running, session alive, recent activity | None |\n| agent_state=running, session alive, idle 5-15 min | Gentle nudge |\n| agent_state=running, session alive, idle 15+ min | Direct nudge with deadline |\n| agent_state=running, SESSION DEAD | ZOMBIE — handle in Step 2a |\n| agent_state=stuck | Assess and help or escalate |\n| agent_state=done | Verify cleanup triggered (see Step 4a) |\n\n**Step 4a: Handle agent_state=done**\n\nIn the persistent model, polecats with agent_state=done should be idle with\ntheir sandbox preserved. Finding one here indicates:\n\n1. **Stale agent bead** - polecat was nuked but bead remains\n   ```bash\n   # Verify polecat doesn't exist anymore\n   ls polecats/\u003cname\u003e 2\u003e/dev/null || echo \"Already nuked\"\n   ```\n   If nuked, the agent bead is stale. Clean it up or ignore.\n\n2. **Cleanup wisp exists** - polecat has dirty state needing intervention\n   ```bash\n   bd list --label polecat:\u003cname\u003e --status=open\n   ```\n   Process in process-cleanups step.\n\n3. **No wisp, polecat exists** - POLECAT_DONE mail was missed\n   Check for pending MR before taking any action:\n   ```bash\n   # Check for pending MR (gt-6a9d: do NOT nuke if MR pending)\n   bd list --label polecat:\u003cname\u003e,state:merge-requested --status=open\n   # If no pending MR and no dirty state → polecat is idle, leave it\n   ```\n   If dirty state exists, create cleanup wisp for investigation.\n\n**Step 5: Execute nudges**\n```bash\n# Use --mode=queue to avoid interrupting in-flight tool calls\ngt nudge --mode=queue \u003crig\u003e/polecats/\u003cname\u003e \"How's progress? Need help?\"\n```\n\n**Step 6: Escalate if needed**\n```bash\ngt mail send deacon/ -s \"Escalation: \u003cpolecat\u003e stuck\" \\\n  -m \"Polecat \u003cname\u003e reports stuck. Please intervene.\"\n```\n\n**Parallelism**: Use Task tool subagents to inspect multiple polecats concurrently.\n\n**ZFC Principle**: Trust agent_state from beads for WHAT agents report. But\nverify tmux session existence for WHETHER agents are alive. A dead session with\nagent_state=running is a zombie — the agent cannot correct its own state.\n\n**Step 7: ORPHANED BEAD DETECTION — Scan from beads side**\n\n🚨 **CRITICAL**: Zombie detection (Step 2a) scans FROM polecat directories.\nOnce a polecat is nuked and its directory removed, its beads become invisible\nto zombie detection. Orphaned bead detection scans FROM beads to catch this case.\n\n```bash\nbd list --status=in_progress --json --limit=0\nbd list --status=hooked --json --limit=0\n```\n\nFor each in_progress or hooked bead with a polecat assignee (format: `\u003crig\u003e/polecats/\u003cname\u003e`):\n0. Verify bead status is still in_progress/hooked (not closed since listing). If\n   closed, skip — the polecat completed its work. (gt-sy8)\n1. Only check beads assigned to polecats in YOUR rig\n2. Check tmux session: `gt session status \u003crig\u003e/\u003cname\u003e --json | jq -r '.running'`\n3. Check polecat directory: `ls \u003crig\u003e/polecats/\u003cname\u003e 2\u003e/dev/null`\n4. If BOTH session dead AND directory missing → orphan. Reset the bead:\n   ```bash\n   bd update \u003cbead-id\u003e --status=open --assignee=\n   gt mail send deacon/ -s \"ORPHAN_RECOVERED: \u003cbead-id\u003e\" \\\n     -m \"Bead \u003cbead-id\u003e was assigned to \u003crig\u003e/polecats/\u003cname\u003e which no longer exists.\n   The bead has been reset to open with no assignee.\n   Please re-dispatch to an available polecat.\"\n   ```\n5. If directory exists but session dead → skip (zombie detection handles it)\n6. If session alive → not an orphan, skip","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-voovc","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Inspect all active polecats","updated_at":"2026-02-28T10:08:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T09:04:31Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-vys2r","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T09:04:31Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"08704258779025fa3fcbd8f376e517bcb56c7a517702d9aff98a49a61d74834b","created_at":"2026-02-28T09:37:02Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Submit your work and clean up. You cease to exist after this step.\n\n**Self-Cleaning Model:**\nOnce you run `gt done`, you're gone. The command:\n1. Pushes your branch to origin\n2. Creates an MR bead in the merge queue\n3. Nukes your sandbox (worktree removal)\n4. Exits your session immediately\n\n**Run gt done:**\n```bash\ngt done\n```\n\nYou should see output like:\n```\n✓ Work submitted to merge queue\n  MR ID: gt-xxxxx\n  Source: polecat/\u003cname\u003e\n  Target: main\n  Issue: cue-b3g\n✓ Sandbox nuked\n✓ Session exiting\n```\n\n**What happens next (not your concern):**\n- Refinery processes your MR from the queue\n- Refinery rebases and merges to main\n- Refinery closes the issue\n- If conflicts: Refinery spawns a FRESH polecat to re-implement\n\nYou are NOT involved in any of that. You're gone. Done means gone.\n\n**Exit criteria:** Work submitted, sandbox nuked, session exited.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-vzok9","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Submit work and self-clean","updated_at":"2026-02-28T09:37:02Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"9fd4f8fe6af19dea2254cbcfdca80525f6869f79b5dc6d06ecb32289bda67fe0","created_at":"2026-02-28T09:53:04Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision. Use the signals from context-check to decide.\n\n**If you decide to continue patrolling:**\n\nUse await-event to subscribe to the refinery event channel with exponential backoff:\n\n```bash\ngt mol step await-event --channel refinery --agent-bead gt-\u003crig\u003e-refinery --backoff-base 30s --backoff-mult 2 --backoff-max 5m --cleanup\n```\n\nThis command:\n1. Watches `~/gt/events/refinery/` for event files (polling-based)\n2. Returns IMMEDIATELY when an event is emitted (MERGE_READY, PATROL_WAKE, MQ_SUBMIT)\n3. If no events, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on refinery agent bead for backoff state\n5. `--cleanup` auto-deletes processed event files\n\n**Supported events:**\n- `MERGE_READY` — from witness when polecat branch is pushed and ready to merge\n- `PATROL_WAKE` — from witness when MRs waiting but refinery appears idle\n- `MQ_SUBMIT` — from polecat via `gt mq submit`\n\n**On event received** (refinery-specific activity):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no events):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-event returns (either by event or timeout):\n1. **Re-assess session health** (check RSS, context, age again — conditions change)\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary: branches merged, test results, queue state\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If you decide to hand off:**\n\nReport and exit using `gt handoff` for clean session transition:\n\n```bash\ngt handoff -s \"Patrol complete\" -m \"Merged X branches, Y tests passed.\nQueue: empty/N remaining\nRSS: X MB, Session age: Xh\nNext: [any notes for successor]\"\n```\n\n`gt handoff` sends handoff mail to yourself, respawns with a fresh Claude instance,\nSessionStart hook runs gt prime, and your successor picks up from the hook.\n\n**DO NOT just exit.** Always use `gt handoff` for proper lifecycle.\n\n**IMPORTANT**: Never sleep-poll manually (e.g., `sleep 30 \u0026\u0026 bd list`).\nAlways use `gt mol step await-event` — it's event-driven and tracks backoff state.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-vzto0","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Burn and respawn or loop","updated_at":"2026-02-28T09:53:04Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T09:30:41Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-vzyps","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T09:30:41Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b3f309c4f91fc5aab51ab7e58b24efedcf82978224ee8174a0b316b48c66de05","created_at":"2026-02-28T08:56:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Submit your work and clean up. You cease to exist after this step.\n\n**Self-Cleaning Model:**\nOnce you run `gt done`, you're gone. The command:\n1. Pushes your branch to origin\n2. Creates an MR bead in the merge queue\n3. Nukes your sandbox (worktree removal)\n4. Exits your session immediately\n\n**Run gt done:**\n```bash\ngt done\n```\n\nYou should see output like:\n```\n✓ Work submitted to merge queue\n  MR ID: gt-xxxxx\n  Source: polecat/\u003cname\u003e\n  Target: main\n  Issue: cue-sx0\n✓ Sandbox nuked\n✓ Session exiting\n```\n\n**What happens next (not your concern):**\n- Refinery processes your MR from the queue\n- Refinery rebases and merges to main\n- Refinery closes the issue\n- If conflicts: Refinery spawns a FRESH polecat to re-implement\n\nYou are NOT involved in any of that. You're gone. Done means gone.\n\n**Exit criteria:** Work submitted, sandbox nuked, session exited.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-w4cv7","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Submit work and self-clean","updated_at":"2026-02-28T08:56:25Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:00:17Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T09:54:52Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-wb8se","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T10:00:17Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"11bf4bcf2086763f74d544b587354ad79ee00202858d392b051d9050612b915a","created_at":"2026-02-28T09:54:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Update the version string in flake.nix.\n\nFind this line:\n```nix\nversion = \"...\";\n```\n\nChange it to:\n```nix\nversion = \"0.1.0\";\n```\n\nVerify:\n```bash\ngrep 'version = ' flake.nix\n```\n","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-wjkks","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Bump version to 0.1.0","updated_at":"2026-02-28T09:54:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b43c4e287488dde7623aeb34db5a18599550ff982eb3a74276a0c8e068bab06a","created_at":"2026-02-28T09:09:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Process cleanup wisps (merge tracking and dirty state handling).\n\nCleanup wisps are created for two reasons:\n1. Pending MR: HandlePolecatDone creates a wisp in 'merge-requested' state\n   when a polecat has work in the refinery queue. These are resolved when\n   the MERGED signal arrives.\n2. Dirty state: When a polecat has uncommitted changes or unpushed commits\n   that need manual intervention.\n\n```bash\n# Find all cleanup wisps\nbd list --label cleanup --status=open\n```\n\nIf no wisps, skip this step (most common case in ephemeral model).\n\nFor each cleanup wisp, investigate and resolve the dirty state:\n\n## State: pending (needs investigation)\n\n1. **Extract polecat name** from wisp title/labels\n\n2. **Diagnose the problem**:\n```bash\ncd polecats/\u003cname\u003e\ngit status                    # What's uncommitted?\ngit stash list                # Any stashed work?\ngit log @{u}..HEAD     # Any unpushed commits?\n```\n\n3. **Resolution options**:\n   - **Uncommitted changes**: Commit and push, then nuke\n   - **Stashed work**: Pop and commit, or discard if not valuable\n   - **Unpushed commits**: Push to origin, then nuke\n   - **All valuable work lost**: Escalate to Deacon for recovery\n\n4. **If resolvable locally**: Fix and nuke\n```bash\n# Example: push unpushed commits\ngit push origin HEAD\n\n# Then nuke\ngt session restart \u003crig\u003e/\u003cname\u003e\n\n# Close the wisp\nbd close \u003cwisp-id\u003e --reason \"Resolved: pushed commits, nuked\"\n```\n\n5. **If needs escalation**: Send RECOVERY_NEEDED to Deacon\n```bash\ngt mail send deacon/ -s \"RECOVERY_NEEDED \u003crig\u003e/\u003cpolecat\u003e\" \\\n  -m \"Cleanup Status: \u003cstatus\u003e\nBranch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\n\nCannot auto-resolve. Please advise.\"\n```\nLeave wisp open until Deacon resolves.\n\n## State: merge-requested (legacy, rare)\n\nThis state was used before the ephemeral model. If found, the polecat is\nwaiting for a MERGED signal. The inbox-check step handles these.\n\n**Parallelism**: Use Task tool subagents to process multiple cleanups concurrently.\nEach cleanup is independent - perfect for parallel execution.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-wozb0","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Process pending cleanup wisps","updated_at":"2026-02-28T09:09:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T09:00:46Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-wp61d","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T09:00:46Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"769447c96532d91233b37d97c63c883444ba63231b19c4d70e37300549e8b8af","created_at":"2026-02-28T09:54:54Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**VERIFICATION GATE**: This step enforces the Beads Promise.\n\nIf all checks and tests PASSED: This step auto-completes. Proceed to merge.\n\nIf any check or test FAILED:\n1. Diagnose: Is this a branch regression or pre-existing on the target branch?\n2. If branch caused it:\n   - Abort merge\n   - **REOPEN the source issue** so it returns to the ready queue:\n     ```bash\n     bd update \u003cissue-id\u003e --status=open --assignee=\"\"\n     bd sync\n     ```\n   - Notify witness of rejection using the MERGE_FAILED protocol:\n     ```bash\n     gt mail send \u003crig\u003e/witness -s \"MERGE_FAILED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\n     Issue: \u003cissue-id\u003e\n     Polecat: \u003cpolecat-name\u003e\n     Rig: \u003crig\u003e\n     FailureType: quality-check\n     Error: \u003cfailure description\u003e\"\n     ```\n   - Close the MR bead as rejected:\n     ```bash\n     bd close \u003cmr-bead-id\u003e --reason \"Rejected: \u003cfailure description\u003e\"\n     ```\n   - Delete the rejected branch (a new polecat will create a fresh one):\n     ```bash\n     git push origin --delete \u003cpolecat-branch\u003e\n     ```\n   - Archive the MERGE_READY message\n   - Skip to loop-check\n3. If pre-existing on the target branch:\n   - **DUPLICATE CHECK (MANDATORY)**: Before filing a new bug, search for existing open bugs:\n     ```bash\n     bd search \"\u003cfailure description\u003e\" --status open --label gt:bug --limit 5\n     ```\n     If an existing open bug covers the same failure, do NOT create a duplicate.\n     Instead, note the existing bead ID and proceed.\n   - Only if NO existing bug matches: bd create --type=bug --priority=1 --title=\"Pre-existing failure: \u003cdescription\u003e\"\n   - FORBIDDEN: Writing code to fix quality check or test failures. You merge branches, you do not develop.\n   - Proceed with the merge if the failure is pre-existing (not caused by the branch).\n\n**REJECTION CHECKLIST** (all required before skipping to loop-check):\n- [ ] Source issue reopened (bd update \u003cissue-id\u003e --status=open --assignee=\"\")\n- [ ] MERGE_FAILED notification sent to witness\n- [ ] MR bead closed with rejection reason\n- [ ] Rejected branch deleted from remote\n- [ ] MERGE_READY message archived\n\n**GATE REQUIREMENT**: You CANNOT proceed to merge-push without:\n- All quality checks and tests passing, OR\n- Bead filed (or existing duplicate confirmed) for the pre-existing failure\n\nFORBIDDEN: Writing application code, exploring polecat implementations, or\nre-implementing fixes. You are a mechanical merge processor.\n\nThis is non-negotiable. Never disavow. Never \"note and proceed.\" ","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-wq2yx","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Handle quality check or test failures","updated_at":"2026-02-28T09:54:54Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"4190c6bccda10b3ce5027bdf466975354fb424d1db286440ef52f7f3475f12de","created_at":"2026-02-28T08:56:25Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure workspace is pristine before handoff.\n\n**IMPORTANT: Do NOT run `git push`. That is `gt done`'s job (next step).**\n**IMPORTANT: Do NOT discard implementation changes. They must already be committed.**\n\n**1. Check for untracked files:**\n```bash\ngit status --porcelain\n```\nShould be empty. If not:\n- Add to .gitignore if appropriate\n- Remove if temporary: `rm \u003cfile\u003e`\n- Commit if needed: `git add \u003cfile\u003e \u0026\u0026 git commit -m \"chore: add \u003cfile\u003e\"`\n\n**2. Check stash:**\n```bash\ngit stash list\n```\nShould be empty. If not:\n- Pop and commit: `git stash pop \u0026\u0026 git add -A \u0026\u0026 git commit -m \"chore: unstash work (cue-sx0)\"`\n- Or drop if truly garbage: `git stash drop`\n\n**3. Verify clean state and commits:**\n```bash\ngit status                  # Must show \"working tree clean\"\ngit stash list              # Must be empty\ngit log origin/main..HEAD   # Your commits (should show your work)\n```\n\nIf `git log origin/main..HEAD` shows nothing but you DID make changes,\nsomething went wrong. Do NOT proceed — mail Witness for help.\n\n**Exit criteria:** Workspace clean, no cruft, all work committed. Do NOT push — `gt done` handles that.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-wrupr","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Clean up workspace","updated_at":"2026-02-28T08:56:25Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:08:19Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T10:06:06Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-x1yir","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T10:08:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b8a51e010ce21cc448290c60ed512916bb845b2e638de0464e00212ae5274897","created_at":"2026-02-28T09:54:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Monitor GitHub Actions for release completion.\n\n```bash\ngh run list --limit 5\ngh run watch\n```\n\nExpected: ~5-10 minutes for Nix build + image push.\n\nWatch for:\n- test workflow pass\n- release workflow (docker build + push to ghcr.io) pass\n","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-x5xkg","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Wait for CI","updated_at":"2026-02-28T09:54:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6fa1f14b204dbe17b1081f00b92074e7eaca7eb1c95624f317ec27f038cec3f9","created_at":"2026-02-28T09:27:33Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Run drain to catch any protocol messages that arrived during patrol**\n```bash\ngt mail drain --identity \u003crig\u003e/witness --max-age 30m\n```\nThis catches protocol messages that accumulated while you were processing\nother patrol steps.\n\n**Step 2: Check inbox state**\n```bash\ngt mail inbox\n```\n\nIn the persistent model, POLECAT_DONE messages create cleanup wisps and\nsend MERGE_READY to refinery. Inbox should contain ONLY:\n- Unprocessed messages (just arrived, will handle next cycle)\n- MERGED notifications (close cleanup wisp, then archive)\n\n**Step 3: Archive any remaining stale messages**\n\nLook for messages that were processed but not archived:\n- HELP/Blocked that was escalated → archive\n- Any other processed messages still in inbox → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 4: Verify cleanup wisp hygiene**\n\nIn the persistent model, cleanup wisps track pending MRs and dirty state:\n```bash\nbd list --label cleanup --status=open\n```\n\n- state:pending → Needs investigation in process-cleanups\n- state:merge-requested → Legacy state, handle in inbox-check\n\nIf cleanup wisps are accumulating, investigate why polecats aren't clean.\n\n**Goal**: Inbox should be nearly empty. Cleanup wisps should be rare.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-xj9c0","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T09:27:33Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"d1a52bb1d96fad8e3fa407ef890cf5698d9b3be499a0df0aa2c2f00188fa8b07","created_at":"2026-02-28T08:53:43Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure ALL implementation work is committed before cleanup.\n\n**CRITICAL: You MUST commit all changes from implementation.**\nNEVER use `git checkout -- .` or `git restore .` to discard implementation work.\nALWAYS commit ALL uncommitted changes from your implementation.\n\n**1. Check for uncommitted changes:**\n```bash\ngit status\n```\n\n**2. If there are ANY uncommitted changes, commit them now:**\n```bash\ngit add -A \u0026\u0026 git commit -m \"\u003ctype\u003e: \u003cdescriptive message\u003e (cue-x7q)\"\n```\n\n**3. If working tree is already clean, skip.**\n\n**4. VERIFY:**\n```bash\ngit status\n```\nMust show \"nothing to commit, working tree clean\".\n\n**5. Verify you have commits:**\n```bash\ngit log origin/main..HEAD --oneline\n```\nIf you made changes during implementation, this MUST show at least 1 commit.\n\n**Exit criteria:** All changes committed. Working tree clean.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-xltyi","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Commit all implementation changes","updated_at":"2026-02-28T08:53:43Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T09:30:41Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-xm133","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T09:30:41Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"330f889f95b74fc9fd83f03ee32893162d5e8711d91573383dde38714501accb","created_at":"2026-02-28T10:08:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"End of patrol cycle decision.\n\n**If context LOW** (can continue patrolling):\n\nResolve your agent bead ID for this patrol cycle. You MUST replace `\u003cYOUR_RIG\u003e` below with your actual rig name (e.g., `beads`, `town`) before running:\n```bash\nbd list --type=agent --desc-contains=\"role_type: witness\" --json | jq -r '.[] | select(.status != \"closed\") | select(.description | test(\"(?m)^\\\\s*rig: \u003cYOUR_RIG\u003e\\\\s*$\")) | .id'\n```\nThis must return exactly one bead ID. If it returns zero results, STOP and report an error — verify you substituted `\u003cYOUR_RIG\u003e` correctly. If it returns multiple results, STOP and report an error — manual disambiguation is required. Use the single resolved bead ID as YOUR_AGENT_BEAD in the commands below.\n\nThen use await-signal with exponential backoff to wait for activity:\n\n```bash\ngt mol step await-signal --agent-bead YOUR_AGENT_BEAD \\\n  --backoff-base 30s --backoff-mult 2 --backoff-max 5m\n```\n\nThis command:\n1. Subscribes to `bd activity --follow` (beads activity feed)\n2. Returns IMMEDIATELY when any beads activity occurs\n3. If no activity, times out with exponential backoff:\n   - First timeout: 30s\n   - Second timeout: 60s\n   - Third timeout: 120s\n   - ...capped at 5 minutes max\n4. Tracks `idle:N` label on your agent bead for backoff state\n\n**On signal received** (activity detected):\nReset the idle counter and start next patrol cycle:\n```bash\ngt agent state YOUR_AGENT_BEAD --set idle=0\n```\n\n**On timeout** (no activity):\nThe idle counter was auto-incremented. Continue to next patrol cycle\n(the longer backoff will apply next time).\n\nAfter await-signal returns (either by signal or timeout):\n1. Generate a brief summary of this patrol cycle's observations\n2. Close current patrol and start next cycle:\n```bash\ngt patrol report --summary \"\u003cbrief summary of patrol observations\u003e\"\n```\nThis closes the current patrol wisp and automatically creates a new one.\n3. Continue executing from the first step of the new patrol cycle\n\n**If context HIGH** (approaching limit):\n1. Write handoff mail with notable observations:\n```bash\ngt handoff -s \"Witness patrol handoff\" -m \"\u003cobservations\u003e\"\n```\n2. Exit cleanly - the daemon will respawn a fresh Witness session\n\n**IMPORTANT**: You must either report and loop (context LOW) or exit (context HIGH).\nNever leave the session idle without work on your hook.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-xy5wj","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Loop or exit for respawn","updated_at":"2026-02-28T10:08:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"795f0417d343e9f29be619802ae3b5a11e7a901e2fde88ff9b9528a3bb8c0e2d","created_at":"2026-02-28T09:52:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Summarize this patrol cycle.\n\n**VERIFICATION**: Before generating summary, confirm for each merged branch:\n- [ ] MERGED mail was sent to witness\n- [ ] MR bead was closed\n- [ ] Source issue was closed\n- [ ] MERGE_READY mail archived\n\nIf any notifications, closures, or archiving were missed, do them now!\n\nInclude in summary:\n- Branches merged (count, names)\n- MERGED mails sent (count - should match branches merged)\n- MR beads closed (count - should match branches merged)\n- Source issues closed (count - should match branches merged)\n- MERGE_READY mails archived (count - should match branches merged)\n- Test results (pass/fail)\n- Branches with conflicts (count, names)\n- Conflict-resolution tasks created (IDs)\n- Issues filed (if any)\n- Any escalations sent\n\n**Conflict tracking is important** for monitoring MQ health. If many branches\nconflict, it may indicate target branches are moving too fast or branches are too stale.\n\nThis becomes the digest when the patrol is squashed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-y0vvi","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Generate handoff summary","updated_at":"2026-02-28T09:52:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"cd04eafd6cb3229e545c808f5c4de8961b95bb943104a4d5769ed7d9069b3c8c","created_at":"2026-02-28T10:06:30Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nInbox should contain ONLY:\n- Unprocessed MERGE_READY messages (will process next cycle)\n- Active work items\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- PATROL: Wake up that was acknowledged → archive\n- HELP/Blocked that was handled → archive\n- MERGE_READY where merge completed but archive was missed → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Check for orphaned MR beads**\n\nLook for open MR beads with no corresponding branch:\n```bash\nbd list --type=merge-request --status=open\n```\n\nFor each open MR bead:\n1. Check if branch exists: `git ls-remote origin refs/heads/\u003cbranch\u003e`\n2. Determine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n3. If branch is gone, pick `\u003cverification-target\u003e`:\n   - If `origin/\u003cmerge-target\u003e` exists, use `\u003cmerge-target\u003e`.\n   - If `origin/\u003cmerge-target\u003e` is missing (e.g. deleted integration branch), use `main`.\n4. Verify landed work: `git log origin/\u003cverification-target\u003e --oneline | grep \"\u003csource_issue\u003e\"`\n5. If work found → close MR with reason \"Merged (verified on \u003cverification-target\u003e; merge target was \u003cmerge-target\u003e)\"\n6. If work NOT found → investigate before closing:\n   - Check source_issue validity (should be gt-xxxxx, not branch name)\n   - Search reflog/dangling commits if possible\n   - If unverifiable, close with reason \"Unverifiable - no audit trail\"\n   - File bead if this indicates lost work\n\n**NEVER close an MR bead without verifying the work landed or is unrecoverable.**\n\n**Goal**: Inbox should have ≤3 active messages at end of cycle.\nKeep only: pending MRs in queue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-y6itk","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T10:06:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"6aa5ba658626dc870450232fed6113d21b5d65e3afa77e389a935dd5ca23b896","created_at":"2026-02-28T09:03:32Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Ensure ALL implementation work is committed before cleanup.\n\n**CRITICAL: You MUST commit all changes from implementation.**\nNEVER use `git checkout -- .` or `git restore .` to discard implementation work.\nALWAYS commit ALL uncommitted changes from your implementation.\n\n**1. Check for uncommitted changes:**\n```bash\ngit status\n```\n\n**2. If there are ANY uncommitted changes, commit them now:**\n```bash\ngit add -A \u0026\u0026 git commit -m \"\u003ctype\u003e: \u003cdescriptive message\u003e (cue-df8)\"\n```\n\n**3. If working tree is already clean, skip.**\n\n**4. VERIFY:**\n```bash\ngit status\n```\nMust show \"nothing to commit, working tree clean\".\n\n**5. Verify you have commits:**\n```bash\ngit log origin/main..HEAD --oneline\n```\nIf you made changes during implementation, this MUST show at least 1 commit.\n\n**Exit criteria:** All changes committed. Working tree clean.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-y9bc9","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Commit all implementation changes","updated_at":"2026-02-28T09:03:32Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"795f0417d343e9f29be619802ae3b5a11e7a901e2fde88ff9b9528a3bb8c0e2d","created_at":"2026-02-28T09:30:15Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Summarize this patrol cycle.\n\n**VERIFICATION**: Before generating summary, confirm for each merged branch:\n- [ ] MERGED mail was sent to witness\n- [ ] MR bead was closed\n- [ ] Source issue was closed\n- [ ] MERGE_READY mail archived\n\nIf any notifications, closures, or archiving were missed, do them now!\n\nInclude in summary:\n- Branches merged (count, names)\n- MERGED mails sent (count - should match branches merged)\n- MR beads closed (count - should match branches merged)\n- Source issues closed (count - should match branches merged)\n- MERGE_READY mails archived (count - should match branches merged)\n- Test results (pass/fail)\n- Branches with conflicts (count, names)\n- Conflict-resolution tasks created (IDs)\n- Issues filed (if any)\n- Any escalations sent\n\n**Conflict tracking is important** for monitoring MQ health. If many branches\nconflict, it may indicate target branches are moving too fast or branches are too stale.\n\nThis becomes the digest when the patrol is squashed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-yhpxe","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Generate handoff summary","updated_at":"2026-02-28T09:30:15Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"Closed","closed_at":"2026-02-28T10:04:13Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T10:03:03Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-yltad","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T10:04:13Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b5b41d316559ab36d81b013937c0b56a205c257b0f96499632c4e34fb4d420c5","created_at":"2026-02-28T09:53:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check the beads merge queue - this is the SOURCE OF TRUTH for pending merges.\n\n```bash\ngit fetch --prune origin\ngt mq list \u003crig\u003e\n```\n\nThe beads MQ tracks all pending merge requests. Do NOT rely on `git branch -r | grep polecat`\nas branches may exist without MR beads, or MR beads may exist for already-merged work.\n\nIf queue empty, skip to \"check-integration-branches\" step.\n\nFor each MR in the queue, verify the branch still exists:\n```bash\ngit branch -r | grep \u003cbranch\u003e\n```\n\nIf branch doesn't exist for a queued MR:\n- Close the MR bead: `bd close \u003cmr-id\u003e --reason \"Branch no longer exists\"`\n- Remove from processing queue\n\nTrack verified MR list for this cycle.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-yqsf6","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Scan merge queue","updated_at":"2026-02-28T09:53:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T09:09:45Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ysd6p","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T09:09:45Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"8737a17b7bb92b8ec869791fdc3b4b1a68c31173ee93d4a430e37833f7a04f61","created_at":"2026-02-28T10:06:30Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Merge and push. CRITICAL: Notifications come IMMEDIATELY after push.\n\n**Config: integration_branch_refinery_enabled = true**\n**Config: target_branch = main**\n**Config: delete_merged_branches = true**\n\n**Step 1: Merge and Push**\nDetermine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n```bash\ngit checkout \u003cmerge-target\u003e\ngit merge --ff-only temp\ngit push origin \u003cmerge-target\u003e\n```\n\n**Step 1.5: VERIFY PUSH SUCCEEDED (CRITICAL - PATCH-003)**\n\nPush can fail silently (network, auth, hooks). IMMEDIATELY verify:\n```bash\ngit fetch origin\nLOCAL_SHA=$(git rev-parse \u003cmerge-target\u003e)\nREMOTE_SHA=$(git rev-parse origin/\u003cmerge-target\u003e)\necho \"Local:  $LOCAL_SHA\"\necho \"Remote: $REMOTE_SHA\"\n```\n\n**If SHAs match**: Push succeeded. Continue to Step 2.\n\n**If SHAs differ**: STOP. Push failed silently.\n- DO NOT send MERGED notification\n- DO NOT close MR bead\n- DO NOT delete branch\n- Debug the push failure (check `git push` output, network, auth)\n- Retry push and verify again before proceeding\n\n⚠️ **STOP HERE - DO NOT PROCEED UNTIL STEPS 1.5 AND 2-3 COMPLETE**\n\n**Step 2: Send MERGED Notification (REQUIRED - DO THIS IMMEDIATELY)**\n\nRIGHT NOW, before any cleanup, send MERGED mail to Witness:\n\n```bash\ngt mail send \u003crig\u003e/witness -s \"MERGED \u003cpolecat-name\u003e\" -m \"Branch: \u003cbranch\u003e\nIssue: \u003cissue-id\u003e\nMerged-At: $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n```\n\nThis signals the Witness to nuke the polecat worktree. WITHOUT THIS NOTIFICATION,\nPOLECAT WORKTREES ACCUMULATE INDEFINITELY AND THE LIFECYCLE BREAKS.\n\n**Step 3: Post-merge cleanup (REQUIRED — single command)**\n\nThis single command handles closing the MR bead, closing the source issue, and\ndeleting the remote polecat branch (respects delete_merged_branches config):\n\n```bash\ngt mq post-merge \u003crig\u003e \u003cmr-bead-id\u003e\n```\n\nThe MR bead ID was in the MERGE_READY message or find via:\n```bash\nbd list --type=merge-request --status=open | grep \u003cpolecat-name\u003e\n```\n\nVerify the command output shows all steps succeeded (✓ for each).\n\n**Step 4: Archive the MERGE_READY mail (REQUIRED)**\n```bash\ngt mail archive \u003cmerge-ready-message-id\u003e\n```\nThe message ID was tracked when you processed inbox-check.\n\n**Step 5: Cleanup temp branch**\n```bash\ngit branch -d temp\n```\n\n**VERIFICATION GATE**: You CANNOT proceed to loop-check without:\n- [x] MERGED mail sent to witness\n- [x] Post-merge cleanup completed (MR closed, source issue closed, branch deleted)\n- [x] MERGE_READY mail archived\n\nIf you skipped notifications or archiving, GO BACK AND DO THEM NOW.\n\nTarget branch has moved. Any remaining branches need rebasing on new baseline.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ysoos","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Merge and push","updated_at":"2026-02-28T10:06:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"3260c70b5a3ded2a74852e3822583939822a91499ad18453e258f0783bf03ae7","created_at":"2026-02-28T09:37:14Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check for expired timer gates and escalate as needed.\n\nTimer gates are async wait conditions with a timeout. When the timeout expires,\nthe gate should be escalated to the overseer for human intervention.\n\n**Step 1: Run timer gate check**\n```bash\nbd gate check --type=timer --escalate\n```\n\nThis command:\n1. Finds all open gate issues with await_type=timer\n2. Checks if `now \u003e created_at + timeout`\n3. Escalates expired gates via `gt escalate` (HIGH severity)\n4. Reports summary of gate status\n\n**Step 2: Review output**\n\nIf expired gates were found and escalated:\n- The escalation creates an audit trail bead\n- Overseer will be notified via mail\n- Gate remains open until manually resolved\n\nIf no expired gates:\n- Continue patrol normally\n\n**Note**: Timer gates do NOT auto-close on expiration. They escalate.\nThis ensures human oversight of timeout conditions.\n\n**Parallelism**: This is a single command, no parallel execution needed.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-ytkwg","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check timer gates for expiration","updated_at":"2026-02-28T09:37:14Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e731efa93a5c9d5231a98d88586801bc0b5c8709c7cbb6b28d4f7ffe6efd1fd1","created_at":"2026-02-28T09:52:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: run_tests = true**\n**Config: test_command = go test ./...**\n**Config: setup_command = **\n**Config: typecheck_command = **\n**Config: lint_command = **\n**Config: build_command = **\n\n**1. Run quality checks (skip any that are not configured):**\n\nIf setup_command is set: ``\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf build_command is set: ``\n\n```bash\n           # Make sure all newly added dependencies are installed (if command set)\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n           # Make sure it builds (if command set)\n```\n\nEmpty commands mean \"not configured for this project\" — skip silently.\n\n**2. If quality checks fail:**\n\nProceed to handle-failures step. Track which specific check failed\n(setup/typecheck/lint/build) for the failure diagnosis.\n\n**3. Run the test suite:**\n\nIf run_tests = \"false\": Skip this step entirely. Proceed to handle-failures.\n\nIf run_tests = \"true\":\n\n```bash\ngo test ./...            # Run tests (configured per-rig)\n```\n\nTrack results: pass count, fail count, specific failures.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-z9064","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Run quality checks and tests","updated_at":"2026-02-28T09:52:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T10:08:23Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-z9l7u","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T10:08:23Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"cd04eafd6cb3229e545c808f5c4de8961b95bb943104a4d5769ed7d9069b3c8c","created_at":"2026-02-28T09:52:19Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Verify inbox hygiene before ending patrol cycle.\n\n**Step 1: Check inbox state**\n```bash\ngt mail inbox\n```\n\nInbox should contain ONLY:\n- Unprocessed MERGE_READY messages (will process next cycle)\n- Active work items\n\n**Step 2: Archive any stale messages**\n\nLook for messages that were processed but not archived:\n- PATROL: Wake up that was acknowledged → archive\n- HELP/Blocked that was handled → archive\n- MERGE_READY where merge completed but archive was missed → archive\n\n```bash\n# For each stale message found:\ngt mail archive \u003cmessage-id\u003e\n```\n\n**Step 3: Check for orphaned MR beads**\n\nLook for open MR beads with no corresponding branch:\n```bash\nbd list --type=merge-request --status=open\n```\n\nFor each open MR bead:\n1. Check if branch exists: `git ls-remote origin refs/heads/\u003cbranch\u003e`\n2. Determine `\u003cmerge-target\u003e` using the **Target Resolution Rule** above.\n3. If branch is gone, pick `\u003cverification-target\u003e`:\n   - If `origin/\u003cmerge-target\u003e` exists, use `\u003cmerge-target\u003e`.\n   - If `origin/\u003cmerge-target\u003e` is missing (e.g. deleted integration branch), use `main`.\n4. Verify landed work: `git log origin/\u003cverification-target\u003e --oneline | grep \"\u003csource_issue\u003e\"`\n5. If work found → close MR with reason \"Merged (verified on \u003cverification-target\u003e; merge target was \u003cmerge-target\u003e)\"\n6. If work NOT found → investigate before closing:\n   - Check source_issue validity (should be gt-xxxxx, not branch name)\n   - Search reflog/dangling commits if possible\n   - If unverifiable, close with reason \"Unverifiable - no audit trail\"\n   - File bead if this indicates lost work\n\n**NEVER close an MR bead without verifying the work landed or is unrecoverable.**\n\n**Goal**: Inbox should have ≤3 active messages at end of cycle.\nKeep only: pending MRs in queue.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-zdpsf","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"End-of-cycle inbox hygiene","updated_at":"2026-02-28T09:52:19Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"b5b41d316559ab36d81b013937c0b56a205c257b0f96499632c4e34fb4d420c5","created_at":"2026-02-28T10:06:30Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check the beads merge queue - this is the SOURCE OF TRUTH for pending merges.\n\n```bash\ngit fetch --prune origin\ngt mq list \u003crig\u003e\n```\n\nThe beads MQ tracks all pending merge requests. Do NOT rely on `git branch -r | grep polecat`\nas branches may exist without MR beads, or MR beads may exist for already-merged work.\n\nIf queue empty, skip to \"check-integration-branches\" step.\n\nFor each MR in the queue, verify the branch still exists:\n```bash\ngit branch -r | grep \u003cbranch\u003e\n```\n\nIf branch doesn't exist for a queued MR:\n- Close the MR bead: `bd close \u003cmr-id\u003e --reason \"Branch no longer exists\"`\n- Remove from processing queue\n\nTrack verified MR list for this cycle.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-zfv69","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Scan merge queue","updated_at":"2026-02-28T10:06:30Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"dfab2e7b59734313316899e100837d3f7a1e7098c4c55ea83db66528f85eaefe","created_at":"2026-02-28T09:31:42Z","created_by":"","crystallizes":0,"defer_until":null,"description":"More branches to process?\n\n**Entry paths:**\n- Normal: After successful merge-push\n- Conflict-skip: After process-branch created conflict-resolution task\n\nIf yes: Return to process-branch with next branch.\nIf no: Continue to generate-summary.\n\n**Track for this cycle:**\n- branches_merged: count and names of successfully merged branches\n- branches_conflict: count and names of branches skipped due to conflicts\n- conflict_tasks: IDs of conflict-resolution tasks created\n\nThis tracking feeds into generate-summary for the patrol digest.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-zhi8f","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check for more work","updated_at":"2026-02-28T09:31:42Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"a195205fcbce7b83708d8b22669b5e20a2e18dfa3d680bb897c573522b14f801","created_at":"2026-02-28T09:30:41Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check own context usage.\n\nIf context is HIGH (\u003e80%):\n- Ensure any notes are written to handoff mail\n- Prepare for session restart\n\nIf context is LOW:\n- Can continue patrolling","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-zmf2b","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check own context limit","updated_at":"2026-02-28T09:30:41Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"542d6ae1bc98a330aff0d320d6faf5dc955f75e56de5f6102ff14500d39b4357","created_at":"2026-02-28T08:57:09Z","created_by":"","crystallizes":0,"defer_until":null,"description":"Check refinery and deacon health.\n\n**Step 1: Check refinery session**\n```bash\ngt session status \u003crig\u003e/refinery\n```\n\nIf MRs waiting AND refinery not running:\n```bash\ngt session start \u003crig\u003e/refinery\ngt mail send \u003crig\u003e/refinery -s \"PATROL: Wake up\" -m \"Merge requests in queue. Please process.\"\ngt mol step emit-event --channel refinery --type PATROL_WAKE \\\n  --payload source=witness --payload queue_depth=\u003cN\u003e\n```\n\n**Event emission**: Always emit a file event when waking the refinery.\nThis ensures the refinery's `await-event` unblocks instantly instead of\nwaiting for its next timeout cycle.\n\n**Step 2: Queue health analysis**\n\nRun the full queue view to get raw data for every open MR:\n```bash\ngt refinery ready --all --json\n```\n\nThis returns all open MRs with timestamps, assignees, and branch existence data.\nUse your judgment to assess the queue — there are no hardcoded thresholds.\n\n**What to look for:**\n\n- **Stale claimed MRs**: MRs with a non-empty `Assignee` but old `UpdatedAt`.\n  Consider the queue size, time of day, and typical processing time.\n  A claimed MR that hasn't been updated in a while may indicate a stuck refinery.\n\n- **Orphaned branches**: MRs where both `BranchExistsLocal` and `BranchExistsRemote`\n  are false. The source branch may have been deleted while the MR bead is still open.\n  These likely need to be closed or investigated.\n\n- **Queue depth**: A large number of unclaimed MRs may indicate the refinery is down\n  or overwhelmed. Consider waking it or escalating.\n\n**Step 3: Check deacon health**\n\n⚠️ **The deacon tmux session is named `hq-deacon`** (NOT `deacon`).\nTown-level agents use the `hq-` prefix.\n\n```bash\ntmux has-session -t hq-deacon 2\u003e/dev/null \u0026\u0026 echo \"alive\" || echo \"dead\"\n```\n\nIf the deacon session is dead, escalate to Mayor:\n```bash\ngt mail send mayor/ -s \"ALERT: Deacon session hq-deacon is down\" \\\n  -m \"Deacon tmux session (hq-deacon) not found.\nDetected during witness patrol.\nPlease restart the deacon.\"\n```\n\n**Step 4: Escalate if needed**\n\nIf you identify problems, escalate to Deacon with specific MR IDs and context:\n```bash\ngt mail send deacon/ -s \"QUEUE_HEALTH: \u003csummary\u003e\" \\\n  -m \"MR IDs: \u003cids\u003e\nObservation: \u003cwhat you found\u003e\nRecommendation: \u003cwhat should happen\u003e\"\n```","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-zq54c","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Check refinery and deacon health","updated_at":"2026-02-28T08:57:09Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":null,"await_id":"","await_type":"","close_reason":"","closed_at":null,"closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"e731efa93a5c9d5231a98d88586801bc0b5c8709c7cbb6b28d4f7ffe6efd1fd1","created_at":"2026-02-28T09:30:15Z","created_by":"","crystallizes":0,"defer_until":null,"description":"**Config: run_tests = true**\n**Config: test_command = go test ./...**\n**Config: setup_command = **\n**Config: typecheck_command = **\n**Config: lint_command = **\n**Config: build_command = **\n\n**1. Run quality checks (skip any that are not configured):**\n\nIf setup_command is set: ``\nIf typecheck_command is set: ``\nIf lint_command is set: ``\nIf build_command is set: ``\n\n```bash\n           # Make sure all newly added dependencies are installed (if command set)\n       # Check for type errors (if command set)\n            # Check for lint errors (if command set)\n           # Make sure it builds (if command set)\n```\n\nEmpty commands mean \"not configured for this project\" — skip silently.\n\n**2. If quality checks fail:**\n\nProceed to handle-failures step. Track which specific check failed\n(setup/typecheck/lint/build) for the failure diagnosis.\n\n**3. Run the test suite:**\n\nIf run_tests = \"false\": Skip this step entirely. Proceed to handle-failures.\n\nIf run_tests = \"true\":\n\n```bash\ngo test ./...            # Run tests (configured per-rig)\n```\n\nTrack results: pass count, fail count, specific failures.","design":"","due_at":null,"ephemeral":1,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-wisp-zumpx","is_template":0,"issue_type":"task","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"","payload":"","pinned":0,"priority":2,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"open","target":"","timeout_ns":0,"title":"Run quality checks and tests","updated_at":"2026-02-28T09:30:15Z","waiters":"","wisp_type":"","work_type":""}
{"acceptance_criteria":"","actor":"","agent_state":"","assignee":"claude_usage_exporter/polecats/obsidian","await_id":"","await_type":"","close_reason":"Not achievable: Anthropic usage API returns aggregate account totals only, no per-host breakdown. Prometheus instance label already identifies the exporter host.","closed_at":"2026-02-28T08:55:02Z","closed_by_session":"","compacted_at":null,"compacted_at_commit":null,"compaction_level":0,"content_hash":"1f9eca3fef381893613ee0dd87e651c8e4d83cbe3d4f3ddcc46e87331317d480","created_at":"2026-02-28T08:53:36Z","created_by":"mayor","crystallizes":0,"defer_until":null,"description":"attached_molecule: cue-wisp-26s7j\nattached_formula: mol-polecat-work\nattached_at: 2026-02-28T08:53:43Z\ndispatched_by: mayor\n\nAdd host.name as an OTEL resource attribute so every metric includes the hostname of the machine running the exporter. Use os.Hostname() by default, overridable via OTEL_RESOURCE_ATTRIBUTES or a top-level 'hostname' field in accounts.yaml. This lets operators correlate which host is consuming which account's quota in Prometheus/Grafana. The standard OTEL Prometheus exporter promotes resource attributes to metric labels.","design":"","due_at":null,"ephemeral":0,"estimated_minutes":null,"event_kind":"","external_ref":null,"hook_bead":"","id":"cue-x7q","is_template":0,"issue_type":"feature","last_activity":null,"metadata":"{}","mol_type":"","notes":"","original_size":null,"owner":"graeme@graemef.dev","payload":"","pinned":0,"priority":1,"quality_score":null,"rig":"","role_bead":"","role_type":"","sender":"","source_repo":"","source_system":"","spec_id":"","status":"closed","target":"","timeout_ns":0,"title":"Add host attribute to all metrics","updated_at":"2026-02-28T08:55:02Z","waiters":"","wisp_type":"","work_type":""}
